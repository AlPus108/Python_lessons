# №2 в пакете

# В связке с:
# 1 my_muth_module.py
# 2 main_exe.py
# 3 __init__.py
# 4 Moduli_Pakety
# 5 math_op
# 6 math_func

# 1
# импортируем модуль my_math_module.py
import my_math_module
# При таком импорте, у нас импортируются все ф-и, но через точку

print(my_math_module.my_add(3, 8))  # 11  - вызвали ф-ю my_add() из модуля my_math_module и передали ей два параметра

# Проверим ф-ю чисел Фибаначчи. У нее есть ряд свойств, которые можно проверять

# Используем язык маттех - язык для написания математических формул. Он интуитиво понятный
# (f_n)^2 + (f_{n+1})^2 = f_{2n+1}  -- f = первый член в квадрате + второй член в квадрате

n = 10
# и вызываем ф-ю Фибаначчи
print(my_math_module.fib_num_l(n) ** 2 + my_math_module.fib_num_l(n + 1) ** 2)
print(my_math_module.fib_num_l(2 * n + 1))
# получаем одникаковые значения

# 2 --> возвращаемся обратно во вкладку my_math_module
# 3 --> Вернулись из my_math_module, там мы написали проверочный код
# Теперь здесь, мы запустим main на исполнение, то запуститься проверочный код в модуле my_math_module и результат
# мы получим здесь, так как мы импортировали тот модуль my_math_module в этот main
# Но, что делать, если нам это не надо. Нам надо, чтобы код на исполнение в модуле my_math_module исполнянлся
# только тогда, когда вызываем файл my_math_module именно для исполнения?
# Возвращаемся в my_math_module 4-->

# 5 --> А если мы запустим этот модуль main, здесь также выведется значение переменной __main__, которая находится
# в модуле my_math_module, но теперь у нее значение будет my_math_module
# То есть эта переменная связывает два этих модуля и в каждом модуле она показывает связанный с ним модуль.

# Так что все, что вы пишите в модуле для исполнения, какие-то тесты или проверка чего-то,
# все это необходимо писать под условием if __name__ == '__main__':
# иначе, этот код будет исполняться каждый раз, когда вы импортируете модуль. --> 6/1

# 7 --> Переход из вкладки Moduli_Pakety
# В дирриктории с этим скриптом мы создадим пакет:
# Создаем как обычный файл через ПКМ выбираем new - Directory - называем Pocket
# В пакете должен находится файл __init__.py. Щелкаем по названию пакета правой кнопкой мыши
# new - Python File - называем __init__
# Пока оставим его пустым. Чуть позже заполним
# Также в папке Pocket созаем пакеты чрез ПКМ - new - Python File - называем:
# math_op.py
# math_func
# В math_op копируем математические ф-и из вкладки my_math_module --> math_op 7/1
# 7/2 - вернулись из файла math_op
# В math_func копируем ф-ю вычисления ряда чисел Фибоначчи  --> 7/3 переходим в math_func
# 7/4 - вернулись из файла math_func
# Теперь этот пакет Pocket, в котором файлы __init__.py и два модуля, мы можем импортировать

# 6/1
# Первый сопособ инпартирования - помодульно
# from Pocket import math_op

# И дальше, чтобы воспользоваться ф-ями из этого пакета, пишем через '.'
# print(math_op.my_add(1,2))

# Но, модуль может называться как-то сложно и ф-я тоже может иметь сложное, громоздкое название.
# Поэтому можно делать более длинный импорт

# from Pocket.math_op import my_add
# и дальше уже можно обращаться к ф-и напрямую без указания модуля, в котором она лежит
# print(my_add(3,5))

# И все же это не очень удобно. Есть риск пересечения названий ф-и из разных модулей.
# И от этого надо как-то себя уберечь. Поэтому лучше пользоваться первым способом. Он безопасней.
# Но, если мы уверены, что названия наших функций уникальны, тогда пользуйтесь вторым способом.

# Но, можно пользоваться и страндартным сопособом вызова функций без приставок.
# Для этого надо в __init__.py кинуть импорт ф-й, которые мы будем использовать без приставок.
# 8 --> __init__.py

#  9 --> Теперь мы можем применить третий вариант вызова ф-й, используя __init__.py
from Pocket import my_add, my_math_module

# И теперь мы вызываем ф-ю my_add без лишних приставок
print(my_add(8,6))

# но ф-ю my_div() сейчас мы так вызвать не можем, потому что она не прописана в __init__.py
# После прописки в __init__.py
# Вызываем
from Pocket import my_div

# теперь работает
print(my_div(24,2))


# Какие пакеты мы можем импортировать? Как узнать, где они находятся?
# Они находятся в нескольких дирректориях. Чтобы эти дирректории увидеть, надо воспользоваться услугами пакета sys
import sys

print(sys.path)  # будет возвращен список со всеми дирректориями, где интерпретатор Питона ищет запрашиваемый пакет.

# Вы можете где-то отдельно хранить свои пакеты и добавлять в sys.path методом .append любую дирректорию,
# откуда вы хотите подтаскивать пакет. sys.path, это обычный лист/список
# sys.path.append('.......')

# Так же еще бывают более сложные конструкции пакетов, когда в пакете хранится другой пакет.
# Но с ними мы работать будем редко или вообще не будем.
# В них ничего слжного нет. Просто добавляете поддирректорию и в этой поддирректории храните модули и файл __init__.py
# Их подгрузка такая же.
