import random

# СЛОВАРИ
# Это структура данных, которая содержит неупорядоченную последовательность.
# Если в списках элементы упорядочены по индексам, то в Словарях объекты распалагаются в парах: ключ-значение
# Словари напоминают списки, но есть одно принцимпиальное различие: они состоят из ключей и значений.
# Ключ, это тот элемент, по котрому мы получаем значение

dictionaty_list = {'name': 'Ariel'}  # сначала ключ 'name', потом значение 'Ariel' в фигурных скобках
# ключ является не изменяемым объектом, тогда как значение может быть любым объектом.
# В словаре не может быть одинаковых ключей, тогда как их значения могут повторяться (совпадать).
# в качестве значения можно использовать объекты любого типа, в том числе списки и сами словари.
# В словаре доступ к значениям происходит по ключам, тогда как в списках - по индексам.
# Марка автомобиля - ключ, цена автомобиля - значение
car_prices = {'opel': 5000, 'toyota': 7000, 'bmw': 10000}
# Все как в книжном словаре - находим слово(ключ) и получаем его значение.
print('Выводим цены на автомобили', car_prices)  # Вывод {'opel': 5000, 'toyota': 7000, 'bmw': 10000}
# Такая структура данных называется dictionaty / словарь
# Все операции в словаре происходят очень быстро. Это эффективно реализованная конструкция.

# ---------------------- Способы инициализации словарей ----------------------
# 1 Способ
# Словари объявляются (инициализируются) фигурными скобками {}
# dict_temp = {}
# Заполняем словарь ключ-значение
dict_temp = {'dict1': 1, 'dict2': 2.1, 'dict3': 'name', 'dict4': [1, 2, 3]}
print(type(dict_temp), dict_temp)  # выводим тип словаря и сам словарь

# 2 Способ
# с помощью метода fromkeys()
dict_temp = dict.fromkeys(['a', 'b'])  # dict - указание класса
# Здесь создан словарь, где указаны ключи a и b с пустыми значениями.
print(type(dict_temp), dict_temp)  # получаем на выходе  <class 'dict'> {'a': None, 'b': None}
# для установки значений нужно подать еще один список
dict_temp = dict.fromkeys(['a', 'b'], [12, '2020'])  # dict - указание класса
print('C помощью метода fromkeys()', type(dict_temp),
      dict_temp)  # получаем на выходе  <class 'dict'> {'a': [12, '2020'], 'b': [12, '2020']}

# 3 Способ
# Инициализация словаря с помощью генератора
dict_temp = {a: a ** 2 for a in range(10)}  # конструкция такая же, как и в списках.
# a - ключ, a**2 - значение, далее конструкция цикла
print('Инициализация с помощью генератора', type(dict_temp), dict_temp)
# получаем на выходе  <class 'dict'> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

# 4 Способ (редко используется, так как все ключи-значения надо вносить вручную)
dict_temp = dict(brend='volvo', price=5000)
print(type(dict_temp), dict_temp)  # получаем на выходе  <class 'dict'> {'brend': 'volvo', 'price': 5000}

# 5 ак же существует функциональность создания Словаря из списков
# Есть такой класс славаря dict. Это встроенный класс, поэтому он пишется с маленькой буквы.
# Свои собственные классы мы должны записывать с Большой буквы.
# У этого класса dict есть свой собственный метод уровня класса fromkeys()
# С помощью этого метода мы можем создать из двух последовательностей какой-то словарь.
# Например, мы можем передать в него два списка
my_dict = dict.fromkeys((1, 2, 3), ('apple', 'orange', 'banana'))
print(my_dict)
# Получаем словарь, где каждому ключу присваивается второй параметр
# {1: ('apple', 'orange', 'banana'), 2: ('apple', 'orange', 'banana'), 3: ('apple', 'orange', 'banana')}
# То есть, здесь автоматизировано создание словаря, чтобы мы не прописывали его в ручную каждый раз.


# ----------------------- Обращение к содержимому словаря --------------------------

# Обращение к содержимому происходит по ключу, который указываем в квадратых скобках.
print("Выводим марку автомобиля: ", dict_temp['brend'])  # выводим значение, указывая ключ
print('Выводим цену Тойоты: ', car_prices['toyota'])

# ------------------ Функции со словарями ------------------------------

# Часто необходимо знать все ключи словаря и все значения
# Получим все ключи словаря
print(dict_temp.keys())  # Возвращается специальный тип dict_keys
# на выходе имеем dict_keys(['brend', 'price'])
# Но, как правило, с этим типом не работают. Его приводят к листу:
print(list(dict_temp.keys()))  # на выходе получаем ['brend', 'price']
# И дальше, все операции, которые необходимо проверсти с ключами, делают с типом list

# Значения получают через ф-ю value
print(list(dict_temp.values()))  # на выходе имеем ['volvo', 5000]
# В таком формате вывода,при работе с коючами и со значениями можно использовать все методы, которые имеются в листах.

# Также можно работать с парами ключ-значение. Для этого нужно использовать метод items()
# items() возвращает лист из картежей - пара ключ-значение (Картеж, это тот же самый лист, только неизменяемый)
print(list(dict_temp.items()))  # на выходе имеем [('brend', 'volvo'), ('price', 5000)]

# ------------------------ Работа с элементами ---------------------------------

# Нам необходимо получать значения, изменять их (потому что словарь, это изменяемый тип) и добавлять новые

# Переинициализируем переменную для рассмотрения следующих задач
dict_temp = {a: a for a in range(10)}
print('Переинициализация', dict_temp)  # На выходе: {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}

# МЕНЯЕМ значение.
# Какому-то ключу присвоим другое значение
dict_temp[0] = 100
print(dict_temp)  # на выходе имеем {0: 100, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}
#  Нулевому ключу теперь соответствует значение 100

# ДОБАВЛЯЕМ пары ключ-значение
dict_temp['name'] = 'Alex'  # Создаем новый ключ и присваиваем ему значение.
print(dict_temp)  # Вывод на экран: {0: 100, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 'name': 'Alex'}
car_prices['mazda'] = 4000
print('Добавление нового Ключа \'mazda\' в список автомобилей: ', car_prices)
# Вывод: {'opel': 5000, 'toyota': 7000, 'bmw': 10000, 'mazda': 4000}
# В словаре можно изменить Значение, но нельзя изменить Ключ
car_prices['opel'] = 2000  # Здесь мы пытаемся добавить элемент с Ключом 'opel', который уже есть в словаре
print('Пытаемся добавить второй колюч \'opel\' в словарь ', car_prices)
# Вывод: {'opel': 2000, 'toyota': 7000, 'bmw': 10000, 'mazda': 4000}
# Но добавления не происходит. Происходит изменение значения старого на новое
# Это способ изменения значения в словаре
# Удаление значений из Словаря происходит при помощи команды del

# ----------------------- МЕТОДЫ СЛОВАРЕЙ ---------------------------------
# У словарей большое количество методов. Какие-то мы уже рассмотрели, это keys(), values(), items()
# C помощью методов словарь можно очищать, копировать, удалять

# -------------------- del -----------------------
# Удаляет значение в словаре по ключу
del car_prices['toyota']
print('Удалиил из списка машин Тойоту ', car_prices)
# Вывод: {'opel': 2000, 'bmw': 10000, 'mazda': 4000}
# Но, с командой del надо быть осторожным. Если вы забудите указать Ключ, значение которого хотите удалить,
# то эта команда УДАЛИТ ВЕСЬ СЛОВАРЬ ВМЕСТЕ С ПЕРЕМЕННОЙ!
# Значение при этом не возвращается. Если нужно получить удаленное значение, тогда надо использовать метод pop()

# --------------------------- pop() ------------------------
# Удаляет значение по Ключу
temp = dict_temp.pop('name')  # удаляем ключ 'name', в месте с ним удаляется и его значение 'Alex'
# При этом он возвращает удаленное ключ-значение через новую пересенную
print(dict_temp)  # Вывод на экран: {0: 100, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}
print(temp)  # Вывод на экран: Alex
# Если такого ключа нет, будет возвращено default без выбрасывания каких-то исключений

# ------------------ clear() ----------------------
# Метод clear() очищает Словарь с сохранением переменной
car_prices.clear()
print('Очищаем словарь car_prices ', car_prices)  # Вывод: {}

# ------------------------- Многоструктурность словарей -----------------------------

# Словари могут содержать не просто парв Ключ - Значение, но и более сложные структуры,
# как, например, другой Словарь.
# Словари часто используются для описания каких-то объектов.
# Для удобства, их можно записывать в несколько строк
person = {
    'first name': 'Jack',
    'second name': "Brown",
    'age': 23,
    'hobbies': ['footbal', 'singing', 'photo'],  # Список
    'children': {'son': 'Alex', 'daugter': 'Marry'}  # Другой Словарь
}
# Как получить доступ к содержимому этого словаря?
print('Получаем информацию из словаря: возраст человека ', person['age'])  # Вывод: 23
# То есть указываем Ключ и по Ключу получаем его значение.

# Как получить список/list значений?
print('Получаем Список значений из Словаря ', person['hobbies'])  # Вывод: ['footbal', 'singing', 'photo']
# Здесь получаем весь список, Но, что делать, если мы хотим получить одно из значений в списке?
# Например к последнему - 'photo'? Это можно сделать в два этапа.
# 1 этап - передача списка в новую переменную
hobbies = person['hobbies']  # Передаем в переменную весь список
# 2 этап - получаем значение из переменной по индексу
print('Получаем значение из переменной по индексу', hobbies[2])  # Вывод: photo
# Это можно сделать и более короткой записью
print('Получаем значение из вложенного Списка коротким спосбом ',
      person['hobbies'][2])

# Как получить доступ к вложенному Словарю?
# Также в два этапа:
# 1 этап - объявляем новый Список и присваиваем ему значения из вложенного Словаря
childrens = person['children']  #
# 2 этап - выводим на экран значение, указывая нужное поля из вложенного Словаря
print('Получаем доступ к вложенному Словарю ', childrens['son'])  # указываем объявленную до этого переменную
# Более короткий способ записи:
print('Получаем значение из вложенного Словаря коротким способом ',
      person['children']['son'])

# Добавление данных в Многоструктурный Словарь

person['car'] = 'Mazda'  # добавляем новые Ключ-Значение
print('Выводим на экран весь Многоструктурный Словарь', person)
# Вывод: {'first name': 'Jack', 'second name': 'Brown', 'age': 23, 'hobbies': ['footbal', 'singing', 'photo'],
# 'children': {'son': 'Alex', 'daugter': 'Marry'}, 'car': 'Mazda'}
# в конце добавлена информация о машине.

# Добавляем данные через цикл

lst_name = ['Marry', 'Alex', 'Kate', 'Jack', 'Anna', 'Kate', 'Ronald', 'Maria', 'Tatyana', 'Evgeniy',
            'Alex', 'Maria', 'Svetlana', 'Artem', 'Igor', 'Ilya']

names_dict = {}
for i in range(len(lst_name)):
    names_dict[lst_name[i]] = lst_name.count(lst_name[i])
# "Marry" 	    1
# "Alex"	    2
# "Kate"	    2
# "Jack"	    1
# "Anna"	    1
# "Ronald"	    1
# "Maria" 	    2
# "Tatyana"	    1
# "Evgeniy"	    1
# "Svetlana"	1
# "Artem" 	    1
# "Igor"	    1
# "Ilya"	    1

# Изменение данных в Многоструктурном Словаре

# Допусти, мы хотим поменять информацию во Вложенном Списке - 'footbal' на 'basketbal'
person['hobbies'][0] = 'basketbal'  # получаем доступ к Вложенному Списку и по индексу меняем его значение
print('Меняем значение во Вложенном Списке', person)
# Вывод: {'first name': 'Jack', 'second name': 'Brown', 'age': 23, 'hobbies': ['basketbal', 'singing', 'photo'],
# 'children': {'son': 'Alex', 'daugter': 'Marry'}, 'car': 'Mazda'}

# Еще один метод доступа к Многоструктурному Словарю
print('Получаем список ключей Многостр. Словаря', person.keys())  # С помощью ф-и keys()
# Вывод: dict_keys(['first name', 'second name', 'age', 'hobbies', 'children', 'car'])
print('Получаем список значений Многостр. Словаря', person.values())  # С помощью ф-и values()
# Вывод:
# dict_values(['Jack', 'Brown', 23, ['basketbal', 'singing', 'photo'], {'son': 'Alex', 'daugter': 'Marry'}, 'Mazda'])
print('Получаем список элементов Многостр. Словаря', person.items())  # С помощью ф-и items()
# Вывод: dict_items([('first name', 'Jack'), ('second name', 'Brown'), ('age', 23),
# ('hobbies', ['basketbal', 'singing', 'photo']), ('children', {'son': 'Alex', 'daugter': 'Marry'}), ('car', 'Mazda')])

# Вот такая струтура в скобках ('first name', 'Jack') называесят Tiple - Картеж.

# --------------------- Итерирование по словарю ------------------------------------

# Итерация по Словарям происходит также, как и по Спискам

for pair in dict_temp.items():
    print(pair)

# На выходе получаем список пар ключ-значение:
# (0, 100)
# (1, 1)
# (2, 2)
# (3, 3)
# (4, 4)
# (5, 5)
# (6, 6)
# (7, 7)
# (8, 8)
# (9, 9)

# Также можно итерироваться, работая с комплектными элементами

for key, value in dict_temp.items():  # key - первое значение в паре, value - второе значение в паре
    print(key, value)

# На выходе:
# 0 100
# 1 1
# 2 2
# 3 3
# 4 4
# 5 5
# 6 6
# 7 7
# 8 8
# 9 9

# Можно тем же способом итерироваться по отдельным элементам конструкции
# По ключам:

for key in dict_temp.keys():
    print(key)

# По значениям:

for value in dict_temp.values():
    print(value)

# Операции со значениями
for value in dict_temp.values():
    print(value + 10, end=' ')  # 110 11 12 13 14 15 16 17 18 19


# По нескольким словарям одновременно

jack = {
    'name': 'jack',
    'car': 'bmw'
}

john = {
    'name': 'john',
    'car': 'audi'
}

# Нам надо собрать, например, информацию о машинах.
# создаем список словарей
drivers = [jack, john]
cars = []
for persons in drivers:
    cars.append(persons['car'])
print(cars)

# Более короткая запись через list comprehension

new_cars = [persons['car'] for persons in drivers]
print(new_cars)

# Такая запись person['car'] по сути - антипатерн. То есть, мы обращаеся к ключу 'car' резюмируя, что он есть.
# Но, а вдруг его там нет? Вдруг в списке есть человек, у которого нет машины? Тогда обращение к несуществующему
# ключу приведет к исключению и скрипт прекратит свою работу. Поэтому считается, что хорошей практикой использование
# специального метода get() у словарей, который первым аргументом достает нам нужные данные по ключу.
new_cars = [person.get('car', '') for persons in drivers]
# То есть, мы знаем или предполагаем, что у словаря есть ключ 'car' и нам надо его получить.
# Тогда мы методу get() передаем название этого ключа, а вторым аргументом '' мы передаем значение по умолчаню
# на тот случаей, если нужного ключа там не осатнется. Чтобы не возникало исключение, он вернет нам пустую строку.


# ------------------------- Сортировка словаря -------------------------------------

# На самом деле содержимое словаря отсортировать нельзя, так как словарь в Python - это неупорядоченная структура данных.
# Даже если вы будете добавлять в словарь элементы упорядоченно, например по алфавиту,
# при выводе они могут отобразится по-другому.
#
# Однако при извлечении элементов из словаря можно сделать так, чтобы это происходило согласно определенному порядку.
# Для этого дополнительно используется упорядоченная структура, которую можно отсортировать. Например, список.
#
# Сортировка по ключам
# Проще всего выполнить сортировку словаря по ключам. Алгоритм вывода содержимого словаря:
#
# Создать список ключей словаря.
# Отсортировать его.
# В цикле for перебрать элементы списка, используя элемент списка как ключ словаря.
d = {'a': 10, 'b': 15, 'c': 4}
list_keys = list(d.keys())
list_keys.sort()
for i in list_keys:
    print(i, ':', d[i])

a : 10
b : 15
c : 4
# Сортировка по значениям
# Отсортировать словарь по значениям сложнее, так как обращаться к элементам словаря можно только по ключам.
# Однако можно создать список кортежей ("ключ", "значение") и отсортировать его по вторым элементам пар.
# Далее в программе используется именно данная упорядоченная структура, а не сам оригинальный словарь.

d = {'a': 10, 'b': 15, 'c': 4}
list_d = list(d.items())
print(list_d)
# [('a', 10), ('b', 15), ('c', 4)]
list_d.sort(key=lambda i: i[1])
print(list_d)
# [('c', 4), ('a', 10), ('b', 15)]
for i in list_d:
     print(i[0], ':', i[1])

c : 4
a : 10
b : 15
# Если бы мы использовали метод sort() без параметра key, то сортировка была бы выполнена по первым элементам кортежей.
# В качестве значения для key указывается функция. В данном случае используется lambda-функция, что уменьшает объем кода.
# В функцию передаются кортежи, а возвращаются их вторые элементы, по которым происходит сортировка.
#
# Класс OrderedDict модуля collections
# В модуле collections имеется класс OrderedDict, который является подклассом класса dict, то есть обычного встроенного
# в Python словаря. OrderedDict позволяет создавать объекты-словари, которые помнят порядок своих элементов. Также класс имеет ряд методов, которые могут изменять порядок элементов в словаре.

from collections import OrderedDict
a = OrderedDict({1: 10, 0: 5})
print(a)
OrderedDict([(1, 10), (0, 5)])
a[2] = 20
print(a)
OrderedDict([(1, 10), (0, 5), (2, 20)])
for i in a:
     print(i, ':', a[i])

# 1 : 10
# 0 : 5
# 2 : 20

# ---------------------------- Решение задачь с помощью Словарей ------------------------------

# Как подсчитать количество повторений одинаковых элементов в списке

text = "Ну и деревня! С роду таких деревень не видел и не знал, что такие такие деревни бывают."

count_dict = {}

# В первом цикле инициализируем словарь
for i in range(len(text)):
    count_dict[text[i]] = 0 # Каждому ключу в виде буквы присваиваем значение 0

#  Во втором цикле заполняем занчениями (Первый вариант)
# for i in range(len(text)):
#     count_dict[text[i]] += 1
#
# print(count_dict)
# {'Н': 1, 'у': 2, ' ': 16, 'и': 7, 'д': 5, 'е': 12, 'р': 4, 'в': 5, 'н': 6, 'я': 1, '!': 1, 'С': 1, 'о': 2, 'т': 5,
# 'а': 5, 'к': 3, 'х': 1, 'ь': 1, 'л': 2, 'з': 1, ',': 1, 'ч': 1, 'б': 1, 'ы': 1, 'ю': 1, '.': 1}

# Второй вариант
for i in text:  # здесь проходимся по самому тексту и подмещяем в i конкретную букву
    count_dict[i] += 1
print(count_dict)

# Выводим конкретный символ на экран
sym = input('Введите символ: ')
if sym in count_dict:
    print('Символ', sym, 'встречается в тексте', count_dict[sym], 'раз.')
else:
    print('Такого символа в тексте нет.')

# Как посмотреть список ключей
keys_dict = count_dict.keys()
print('Список ключей ', keys_dict)
# Список ключей  dict_keys(['Н', 'у', ' ', 'и', 'д', 'е', 'р', 'в', 'н', 'я', '!', 'С', 'о', 'т', 'а', 'к', 'х', 'ь',
# 'л', 'з', ',', 'ч', 'б', 'ы', 'ю', '.'])

# Список значений
val_dict = count_dict.values()
print('Список значений', val_dict)
# Список значений dict_values([1, 2, 16, 7, 5, 12, 4, 5, 6, 1, 1, 1, 2, 5, 5, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1])

# Напишите функцию (F): на вход список имен и целое число N;
# # на выходе список длины N случайных имен из первого списка (могут повторяться,
# # можно взять значения: количество имен 20, N = 100,
# # рекомендуется использовать функцию random);

lst_name = ['Nancy', 'Alice', 'Mary', 'Hanna', 'Dolores', 'Brian', 'Stanley', 'Andrew', 'Michael', 'Nickolas',
            'Johnathan', 'Angeline']
N = 100


def f(lst, n):
    rand_list = []  # пустой список для вывода результата
    for i in range(n):  # запускаем цикл на n итераций
        # rand_name = random.choice(lst)  # выбираем случайное имя из списка и присваиваем ее переменной
        # rand_list.append(rand_name)     # добавляем случайное имя в результирующий список
        rand_list.append(random.choice(lst))  # объединил две предыдущие строки в одну
    return rand_list  # возвращаем список с количеством случайных имен n


fin_list = f(lst_name, N)  # вызываем ф-ю с передачей в нее параметров
print(fin_list)  # выводим результат

# Получили результирующий список fin_list, с которомы будем работать дальше

# Напишите функцию вывода самого частого имени из списка на выходе функции F (список fin_list);


# Решение с помощью цикла
names_dict = {}
for i in range(len(fin_list)):
    names_dict[fin_list[i]] = fin_list.count(fin_list[i])  # в цикле загоняем значения в словарь
top_names_list = list(names_dict.items())  # перекидываем инфу из Словаря в Лист
top_names_list.sort(key=lambda i: i[1], reverse=True)  # сортируем Список по значениям
# и переворачиваем от большего к меньшим
print(f'Имя {top_names_list[0][0]} встречается чаще других, а именно {top_names_list[0][1]} раз.')


# Решение с помощью функции
def top(fin_list):
    # Получаем уникальные значения списка через обертку set
    # Через обертку Словарь листаем в цикле список и считаем количество повторений каждого слова
    pop_name = dict((fin_list.count(i), i) for i in set(fin_list))
    return pop_name[max(pop_name.keys())]


print(f'Имя {top(fin_list)} встречается чаще других, а именно {fin_list.count(top(fin_list))} раз.')


# 3. Напишите функцию вывода самой редкой буквы, с которого начинаются имена в списке на выходе функции F.

#  Решение с помощью цикла
letters_dict = {}
for i in range(len(fin_list)):
    letters_dict[fin_list[i][0]] = fin_list.count(fin_list[i])
letters_list = sorted(letters_dict.items(), key=lambda i: i[1])
# print(letters_list)
print('Первая буква', letters_list[0][0], 'в именах встречается реже других, а именно', letters_list[0][1], 'раз.')


# решение с помощью функции
letters_list = [fin_list[i][0] for i in range(len(fin_list))]
# print(letters_list)
def rare(letters_list):
    letters_dict = dict((letters_list[i], letters_list.count(letters_list[i])) for i in range(len(letters_list)))
    letters_dict_sort = sorted(letters_dict.items(), key = lambda i: i[1])
    return letters_dict_sort[0]
# print(rare(letters_list))
print(f'Первая буква {(rare(letters_list))[0]} в именах встречается реже других, а именно {(rare(letters_list))[1]} раз.')
