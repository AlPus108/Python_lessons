# Numpy массивы
# NumPy - векторные/научные вычисления. Пакет содержит функциональные средства для работы с многомерными массивами
# и высокоуровневыми математическими функциями
# Это дополнительная библиотека в Питоне. Хотя это самостоятельный модуль, но настолько популярная,
# что ее стали ассоциировать с Питоном. В ней есть специальные массивы. Похожи на list,
# но numpy-массивы, это более крутыые массивы. И поэтому они используются в научных целях.
# В основном numpy нужне для математических вещей, обучающих алгоритмов. и тд.
# Нейронный сети, это в основном numpy-массивы. 60% - numpy и 40% - обычные листы. Мы будем использоват и то и другое.
# Важно научиться в них не путаться.

# Импоритруем библиотеку
import numpy as np

# Массив, это почти то же самое, что и Лист, только немного другая структура, но она близкая.
# Numpy-массив более функционален.

# У нас есть список

a = [2, 4, 5]

# Есть такое понятие, как ndarray (numpy_data_array) - это название типа объектов numpy
# Мы можем взять этот обычный лист и превратить в numpy-массив

a_numpy = np.array(a)  # это подобно преобразованию типов. Здесь мы преобразовывыаем list в numpy-list
# При этом значение массива 'a' присваиваем новой переменной.

# Выводим тип нового массива
print(type(a_numpy))
# <class 'numpy.ndarray'>  - но здесь мы тип не получаем, а получаем класс, так как обычные ф-и здесь уже не работают.

# В бибилотеке numpy, чтобы получить тип, используют ф-ю dtype()
print(a_numpy.dtype)  # int32

# Этот тип содержит целочисленные числа. В данном случае int32. 32 - сколько бит он выделяет на каждую ячейку.
# Бывает и 16 и 64. Это не принцимпиально. Для нас главное, что это int - целочисленное число.
# И теперь a_numpy - это уже numpy-массив.

# Выводим его на экран
print(a_numpy)  # [2 4 5]
# Разница с выводм Листа в том, что numpy выводится без запятых через пробелы.
# Хотя на вид содержание одно и то же, но структуры разные.


# Создаем новый лист с типом одного значения float

b = [2, 3.14]
# Превращаем его в numpy и выведем тип
b_numpy = np.array(b)
print(b_numpy.dtype)  # float64  - тип с плавающей точкой с 64-мя битами в ячейке.

print(b_numpy)  # [2.   3.14]
# При преобарзовани типов, первый элемент int был приведен к типу float
# Теперь все элементы массива принадлежат к типу float


# Выводим новый лист с разными типами данных

c = [2, 3.14, 'kotiki']

# Приводим к типу numpy
c_numpy = np.array(c)
print(c_numpy)  # ['2' '3.14' 'kotiki']  # получаем тип str

# numpy всегда одного типа и он приводит все элементы к самому старшему типу.
# Так как float нельзя привести к int без потери данных, а float тем более нельзя привести к int и float.
# Поэтому, самым старшим типом здесь является строка.
print(c_numpy.dtype)  # <U32 - тип строки


# Дальше, мы помещаем в наш массив еще один лист
my_list = [2, 3.14, 'kotiki', [2,3,4]]  # третьим элементом листа будет лист.

# Приводим его к типу numpy-массив
my_list_numpy = np.array(my_list)
print(my_list_numpy)  # [2 3.14 'kotiki' list([2, 3, 4])]  - в массиве уже целый лист и это уже объект.
print(my_list_numpy.dtype)  # object
# Теперь в numpy-массив присутствуют только объекты.
# Для numpy-массивов это самый высокий уровень - тип Object - это уже тип numpy.

# Попробуем привести следующую последовательность к типу int
# np.array([2, 3.14, 'kotiki', [2,3,4]], dtype='int64')
# Будет выдана ошибка: ValueError: invalid literal for int() with base 10: 'kotiki'
# Он не может привести строковое значение 'kotiki' к числу.
# То же касается и list, и не важно, что там цифры.

# ----------------------------- Типы данных ---------------------------

# В NumPy реализованы свои типы данных, которые отличаются от встоенных в Пвйтон.
# Например, нативный int в Пайтоне ничем не ограничен (кроме вашей памяти). Но, целые числа в numpy имеют
# фиксированный размер, np.int8, np.int16...

# Другое различие кроется в строенных методах.

a_python = 123
# Числовое значение Пвйтон мы можем привети к типу numpy
a_numpy = np.int32(123)  # int - целочисленное, 32 - сколько памяти мы закладываем под это число - 4 байта.
# Что это меняет? Это меняет максимальное число. Самое максимальное число в этом случае будет - 4 миллиарда.
# Если сделаем 64 - будет в два раза больше. То есть, для значения 132 хватит с большим запасом, хотя под него хыватит и 8

# Смотрим их типв
print(type(a_python))  # <class 'int'> - здесь питоновский тип int
print(type(a_numpy))  # <class 'numpy.int32'> - здесь тип int класса numpy


# --------------------- Одномерные и многомерные массивы -----------------------

# Массив их целых чисел
# Здесь мы создаем лист, но не выносим его в отдельную переменную, а сразу передаем в numpy
a = np.array([1, 2, 3, 4, 5])


# массив из строк
b = np.array(['cat', 'mouse', 'dog', 'rat'])

# Рассмотрим их типы

print(a.dtype)  # dtype('int64')
print(b.dtype)  # dtype('<U5')  # это тип "строка" с максимальной длиной 5 - mouse

# --------------------------------- shape ---------------------------
# Выдает размерность массива или одномерный вектор (в одну строку)

print(a.shape)  # (5,)  - получена размерность массива 'a' - 5 - количество элементов в массиве
print(b.shape)   # (4,) - одномерный массив из 4-х элементов


# -------------------------------- size ----------------------------
# Выдает количество элементов в массиве

print(a.size)  # 5 - в данном случае совпадает с shape. Это одномерный массив длины - 5 и его размер - 5
# Но size и shape могут различаться. Если бы, например, массив был бы многомерным 10х10, то shape был бы 10х10,
# а size был бы 100

# Сделаем длину 6
a = np.array([1, 2, 3, 4, 5, 6])
print(a)
print(a.shape)  # (6,)
# Мы можем изменить этот размер с помощью ф-и reshape()

# ---------------------------------- reshape() -----------------------
# Меняет форму матрицы. Выдает многомерный вектор

a_new = a.reshape(3, 2)
print(a_new)
# [[1 2]
#  [3 4]
#  [5 6]]
print(a_new.shape)  # (3, 2)
print(a_new.size)  # 6

# Поменяеи shape
a_new = a.reshape(2, 3)
print(a_new)
# [[1 2 3]
#  [4 5 6]]
print(a_new.shape)  # (2, 3)
print(a_new.size)  # 6

a_new = a.reshape(1, 6)
print(a_new)
# [[1 2 3 4 5 6]]  # это двумерная матрица, состоящая из одной строки с шестью элементами
print(a_new.shape)  # (1, 6)
print(a_new.size)  # 6

# Если количество элементов в массиве нечетное, например - 5, то мы можем сделть размерность только 1х5 или 5х1
# Если мы попытаемся сделать из массива 5 матрицу 2х3 - будет выдана ошибка.
# Хотя в листе это можно сделать
list = [[1, 2, 3], [4, 5]]
# Но, если мы переведем этот list в numpy
np_list = np.array(list)
print(np_list)
# [list([1, 2, 3]) list([4, 5])]
# получим numpy-массив из двух списков. Но, полноценный numpy мы не получим.
# Но, если мы подадим ему лист с четным количеством элементов,
list_2 = [[1, 2, 3], [4, 5, 6]]
np_list_2 = np.array(list_2)
print(np_list_2)
# [[1 2 3]
#  [4 5 6]]
# Получаем полноценную numpy-матрицу


# По сути одномерны и многомерный вектор, это одно и тоже, но в numpy это имеет разницу.
# Можно создавать массивы с бесконечным количеством элементов.

# -------------------------- Индексация ------------------------

# Имеем массив
print(a)
# [1 2 3 4 5 6]

# К его элементам мы можем обращаться по индексам
print(a[0])  # 1
print(a[1])  # 2
print(a[-1])  # 6 - последний элемент
# Здесь так же работают слайсы
print(a[:2])  # [1 2] - от 0 до 2-го индекса (исключительно)
print(a[2:])  # [3 4 5 6] - от 2-го индекса и до конца.
# Можно делать отрицательную индексацию
print(a[:-2])  # [1 2 3 4] - от 0 до второго индекса с конца (исключительно)
print(a[1:4])  # [2 3 4] - от 1-го индекса до 4-го (исключительно)

# Но, что будет, если мы зададим условие?
print(a > 5)  # [False False False False False  True]
# Чем удобен numpy - мы можем получить новый массив с информацией имеет ли а длину больше 5.
# Или по другому. Выведем нечетные числа
print(a % 2 == 0)  # [False  True False  True False  True]
# Или можем ему сказать: выдай пожалуйста все значения, которые по модулю == 0
print(a[a % 2 == 0])  # [2 4 6]
# Выдай все позиции, значения которых больше двух и меньше или равно 5
print(a[(a > 2) & (a <= 5)])  # [3 4 5]
# Выдай все значения бьльше 4
print(a[a > 4])  # [5 6]

# Это то, чем удобен numpy и чего нет в list

# Двумерный numpy
lst_num = [i for i in range(30)]
print(lst_num)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
# - получаем список из 10 чисел.

# Создаем из этого numpy-массив
np_lst_num = np.array(lst_num)
print(np_lst_num)  # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29]
# Делаем решейп
np_lst_num = np_lst_num.reshape(6,5)
print(np_lst_num)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]
#  [20 21 22 23 24]
#  [25 26 27 28 29]]

# Отсюда мы можем вывести избранные строки. Например, первые две
print(np_lst_num[:2,:])  # задаем количество по двум осям через запятую: по вертик - 2 строки, по горизонтальной - все.
# [[0 1 2 3 4]
#  [5 6 7 8 9]]

# Или, по первой оси первые 3 строки, а по второй с шагом 2  (начало : конец : шаг - не обязательный)
print(np_lst_num[:3,::2])  #
# [[ 0  2  4]
#  [ 5  7  9]
#  [10 12 14]]

# Или по первой оси выдай первые 4 строки, а по второй 0-ю и 1-ю
print(np_lst_num[:4,[0, 1]])  #
# [[ 0  1]
#  [ 5  6]
#  [10 11]
#  [15 16]]

# Или вообще хитро сделать (сейчас забегаем немного вперед)
np_lst_sum = np_lst_num.sum(axis=1)  # берем сумму по строкам
print(np_lst_sum)  # [ 10  35  60  85 110 135]  - это суммы чисел в каждой строке.
# Здесь мы вызвали ф-ю sum() про

# А теперь выведем те строки, у которых сумма от 50 до 100, а по втрой оси выводим все значения (:)
# print(np_lst_num[50 <= np_lst_sum <= 100, :])
# Здесь мы говорим: выведи np_lst_num, но строки возьми те, у которых np_lst_sum больше 50 и меньше 100,
# а колонки выведи все.
# Но, на это выражение он ругается
# Зададим маску
# mask = (50 <= np_lst_sum <= 100)  # на это он также выдает ошибку. Здесь проблема в двойном выражении
# Тогда берем только первую часть
mask = (np_lst_sum >= 50)
print(mask)  # [False False  True  True  True  True]
print(np_lst_num[mask, :])  # здесь подставляем маску
# [[10 11 12 13 14]
#  [15 16 17 18 19]
#  [20 21 22 23 24]
#  [25 26 27 28 29]]
# получили те строки, в которых сумма элементов больше 50





