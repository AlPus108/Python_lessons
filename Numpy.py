# Numpy массивы
# NumPy - векторные/научные вычисления. Пакет содержит функциональные средства для работы с многомерными массивами
# и высокоуровневыми математическими функциями
# Это дополнительная библиотека в Питоне. Хотя это самостоятельный модуль, но настолько популярная,
# что ее стали ассоциировать с Питоном. В ней есть специальные массивы. Похожи на list,
# но numpy-массивы, это более крутыые массивы. И поэтому они используются в научных целях.
# В основном numpy нужне для математических вещей, обучающих алгоритмов. и тд.
# Нейронный сети, это в основном numpy-массивы. 60% - numpy и 40% - обычные листы. Мы будем использоват и то и другое.
# Важно научиться в них не путаться.

# Импоритруем библиотеку
import numpy as np

# Массив, это почти то же самое, что и Лист, только немного другая структура, но она близкая.
# Numpy-массив более функционален.

# У нас есть список

a = [2, 4, 5]

# Есть такое понятие, как ndarray (numpy_data_array) - это название типа объектов numpy
# Мы можем взять этот обычный лист и превратить в numpy-массив

a_numpy = np.array(a)  # это подобно преобразованию типов. Здемь мы преобразовывыаем list в numpy-list
# При этом значение массива 'a' присваиваем новой переменной.

# Выводим тип нового массива
print(type(a_numpy))
# <class 'numpy.ndarray'>  - но здесь мы тип не получаем, а получаем класс

# В бибилотеке numpy, чтобы получить тип, используют ф-ю dtype()
print(a_numpy.dtype)  # int32

# Этот тип сожержит целочисленные числа. В данном случае int32. 32 - сколько бит он выделяет на каждую ячейку.
# Бывает и 16 и 64. Это не принцимпиально. Для нас главное, что это int - целочисленное число.
# И теперь a_numpy - это уже numpy-массив.

# Выводим его на экран
print(a_numpy)  # [2 4 5]
# Разница с выводм Листа в том, что numpy выводится без запятых через пробелы.
# Хотя на вид содержание одно и то же, но структуры разные.


# Создаем новый лист с типом одного значения float

b = [2, 3.14]
# Превращаем его в numpy и выведем тип
b_numpy = np.array(b)
print(b_numpy.dtype)  # float64  - тип с плавающей точкой с 64-мя битами в ячейке.

print(b_numpy)  # [2.   3.14]
# При преобарзовани типов, первый элемент int был приведен к типу float


# Выводим новый лист с разными типами данных

c = [2, 3.14, 'kotiki']

# Приводим к типу numpy
c_numpy = np.array(c)
print(c_numpy)  # ['2' '3.14' 'kotiki']  # получаем тип str

# numpy всегда одного типа и он приводит все элементы к самому старшему типу.
# Так как float нельзя привести к int без потери данных, а float тем более нельзя привести к int и float.
# Поэтому, самым старшим типом здесь является строка.
print(c_numpy.dtype)  # <U32 - тип строки


# Дальше, мы помещаем в наш массив еще один лист
my_list = [2, 3.14, 'kotiki', [2,3,4]]  # третьим элементом листа будет лист.

# Приводим его к типу numpy-массив
my_list_numpy = np.array(my_list)
print(my_list_numpy)  # [2 3.14 'kotiki' list([2, 3, 4])]  - в массиве уже целый лист и это уже объект.
print(my_list_numpy.dtype)  # object
# Теперь в numpy-массив присутствуют только объекты.
# Для numpy-массивов это самый высокий уровень - тип Object.


# ----------------------------- Типы данных ---------------------------







