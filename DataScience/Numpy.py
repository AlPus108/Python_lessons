# Numpy массивы

# Документация по NumPy: https://numpy.org/doc/stable/
# Список универсальных функций NumPy https://numpy.org/devdocs/reference/ufuncs.html

# NumPy - векторные/научные вычисления. Пакет содержит функциональные средства для работы с многомерными массивами
# и высокоуровневыми математическими функциями
# Это дополнительная библиотека в Питоне. Хотя это самостоятельный модуль, но настолько популярная,
# что ее стали ассоциировать с Питоном. В ней есть специальные массивы. Похожи на list,
# но numpy-массивы, это более крутыые массивы. И поэтому они используются в научных целях.
# В основном numpy нужне для математических вещей, обучающих алгоритмов. и тд.
# Нейронный сети, это в основном numpy-массивы. 60% - numpy и 40% - обычные листы. Мы будем использоват и то и другое.
# Важно научиться в них не путаться.

# Импоритруем библиотеку

import numpy as np

# ------------------- СПОСОБЫ СОЗДАНИЯ МАССИВА ------------------------

# ------------------------------- array() ------------------------------

# Создание массива из списка
# Массив, это почти то же самое, что и Лист, только немного другая структура, но она близкая.
# Numpy-массив более функционален.

# У нас есть список

a = [2, 4, 5]

# Есть такое понятие, как ndarray (numpy_data_array) - это название типа объектов numpy
# Мы можем взять этот обычный лист и превратить в numpy-массив

a_numpy = np.array(a)  # это подобно преобразованию типов. Здесь мы преобразовывыаем list в numpy-list
# При этом значение массива 'a' присваиваем новой переменной.

# Или без создания листа, напрямую
# a = np.array([2, 4, 5])  - это приведение типа лист к массиву

# Выводим тип нового массива
print(type(a_numpy))
# <class 'numpy.ndarray'>  - но здесь мы тип не получаем, а получаем класс, так как обычные ф-и здесь уже не работают.

# В бибилотеке numpy, чтобы получить тип, используют ф-ю dtype()
print(a_numpy.dtype)  # int32

# Этот тип содержит целочисленные числа. В данном случае int32. 32 - сколько бит он выделяет на каждую ячейку.
# Бывает и 16 и 64. Это не принцимпиально. Для нас главное, что это int - целочисленное число.
# И теперь a_numpy - это уже numpy-массив.

# Выводим его на экран
print(a_numpy)  # [2 4 5]
# Разница с выводм Листа в том, что numpy выводится без запятых через пробелы.
# Хотя на вид содержание одно и то же, но структуры разные.


# Создаем новый лист с типом одного значения float

b = [2, 3.14]
# Превращаем его в numpy и выведем тип
b_numpy = np.array(b)
print(b_numpy.dtype)  # float64  - тип с плавающей точкой с 64-мя битами в ячейке.

print(b_numpy)  # [2.   3.14]
# При преобарзовани типов, первый элемент int был приведен к типу float
# Теперь все элементы массива принадлежат к типу float


# Выводим новый лист с разными типами данных

c = [2, 3.14, 'kotiki']

# Приводим к типу numpy
c_numpy = np.array(c)
print(c_numpy)  # ['2' '3.14' 'kotiki']  # получаем тип str

# numpy всегда одного типа и он приводит все элементы к самому старшему типу.
# Так как float нельзя привести к int без потери данных, а str тем более нельзя привести к int и float.
# Поэтому, самым старшим типом здесь является строка.
print(c_numpy.dtype)  # <U32 - тип строки

# Дальше, мы помещаем в наш массив еще один лист
my_list = [2, 3.14, 'kotiki', [2, 3, 4]]  # третьим элементом листа будет лист.

# Приводим его к типу numpy-массив
my_list_numpy = np.array(my_list)
print(my_list_numpy)  # [2 3.14 'kotiki' list([2, 3, 4])]  - в массиве уже целый лист и это уже тип - объект.
print(my_list_numpy.dtype)  # object
# Теперь в numpy-массив присутствуют только объекты.
# Для numpy-массивов это самый высокий уровень - тип Object - это уже тип numpy.

# Попробуем привести следующую последовательность к типу int
# np.array([2, 3.14, 'kotiki', [2,3,4]], dtype='int64')
# Будет выдана ошибка: ValueError: invalid literal for int() with base 10: 'kotiki'
# Он не может привести строковое значение 'kotiki' к числу.
# То же касается и list, и не важно, что там цифры.


# ----------------------------- Типы данных ---------------------------

# В NumPy реализованы свои типы данных, которые отличаются от встоенных в Пвйтон.
# Например, нативный int в Пайтоне ничем не ограничен (кроме вашей памяти). Но, целые числа в numpy имеют
# фиксированный размер, np.int8, np.int16...

# Другое различие кроется в встроенных методах.

a_python = 123
# Числовое значение Пвйтон мы можем привести к типу numpy
a_numpy = np.int32(123)  # int - целочисленное, 32 - сколько памяти мы закладываем под это число - 4 байта.
# Что это меняет? Это меняет максимальное число. Самое максимальное число в этом случае будет - 4 миллиарда.
# Если сделаем 64 - будет в два раза больше. То есть, для значения 132 хватит с большим запасом, хотя под него хыватит и 8

# Смотрим их типы
print(type(a_python))  # <class 'int'> - здесь питоновский тип int
print(type(a_numpy))  # <class 'numpy.int32'> - здесь тип int класса numpy

# ----------------------------- Одномерные массивы -----------------------

# Массив их целых чисел
# Здесь мы создаем лист, но не выносим его в отдельную переменную, а сразу передаем в numpy
a = np.array([1, 2, 3, 4, 5])

# массив из строк
b = np.array(['cat', 'mouse', 'dog', 'rat'])

# Рассмотрим их типы

print(a.dtype)  # dtype('int64')
print(b.dtype)  # dtype('<U5')  # это тип "строка" с максимальной длиной 5 - mouse

# Строго говоря, сейчас создали массив не верно. При создании массива надо всегда указывать тип его данных.
# Потому что массивы NumPy имеют строгую типизацию. Опустить указание типа в NumPy возможно лишь в одном случае -
# если мы создаем копию уже существующего массива. Один только int имеет в NumPy четыре типа:
# int8, int16, int32, int64. Важная справка: пользоваться числами больше размерености вашей машины не имеет смысла.
# Если наша опер.система имеет разрядность 32, то использовать int64 не целесообразно. Но, если надо, то можно.
# Вещественные числа бывают трех видов: float16, float32, float64. С ними то же правило - если надо, то можно.
# В NumPy float16 соответствует С(ишному): float; F(ортрановский): REAL; float32 - C:double, F: double precision;
# P(итоновский): float. То есть, Питоновский float, это float32. Float64 (двойная точность) в NumPy ничему не соответствует.
# В классических языках программирования ему нет аналогов.
# В NumPy комплексные числа состоят из двух половинок: complex64 - две части из float32 и complex128 - две части из  float64.
# Это и есть "коробочные" родные типы библиотеки NumPy.
# С фиксированной точкой NumPy работать не умеет.

# Итак, если мы хотим создать массив из списка, правильно это сделать будет так:
# Создаем массив типа float (а в большинстве случаем так оно и будет)
# Это будет список, состоящий из четырех списков
x = np.array([[1,2], [3,4], [5,6], [7,8]], dtype=np.float32)  # в конце указываем тип
# Выводим на экран
print('Массив со строгой типизацией ', x)
# [[1. 2.]
#  [3. 4.]
#  [5. 6.]
#  [7. 8.]]
# В массиве все числа типа float. То есть, при указании типа, бибилиотека NumPy принудительно приобразовывает
# все элементы массива к этому типу.
# Чтобы узнать тип элементов:
print(x.dtype)  # float32


# --------------------------------- shape ---------------------------
# Выдает размерность массива или одномерный вектор (в одну строку)

print(a.shape)  # (5,)  - получена размерность массива 'a' - 5 - количество элементов в массиве
print(b.shape)  # (4,) - одномерный массив из 4-х элементов

# -------------------------------- size ----------------------------
# Выдает количество элементов в массиве

print(a.size)  # 5 - в данном случае совпадает с shape. Это одномерный массив длины - 5 и его размер - 5
# Но size и shape могут различаться. Если бы, например, массив был бы многомерным 10х10, то shape был бы 10х10,
# а size был бы 100

# Сделаем длину 6
a = np.array([1, 2, 3, 4, 5, 6])
print(a)
print(a.shape)  # (6,)
# Мы можем изменить этот размер с помощью ф-и reshape()

# ---------------------------- Двухмерные массивы -------------------------------

# ---------------------------------- reshape() -----------------------
# Меняет форму матрицы. Выдает многомерный вектор (двухмерный массив)
# Но, при этом сам массив не меняется. reshape() лишь создает копию массива,
# поэтому все изменения, которые она вносит, не влияют на исходный массив

# Создаем одномерный массив с одновременным созданием из него двухмерного
# При этом новая форма должна содержать столько же элементов, сколько и старая форма.
two_dim_arr = np.arange(12).reshape(3, 4)
print('Создание двухмерного массива\n ', two_dim_arr)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

a_new = a.reshape(3, 2)
print(a_new)
# [[1 2]
#  [3 4]
#  [5 6]]
print(a_new.shape)  # (3, 2)
print(a_new.size)  # 6

# Поменяем shape
a_new = a.reshape(2, 3)
print(a_new)
# [[1 2 3]
#  [4 5 6]]
print(a_new.shape)  # (2, 3)
print(a_new.size)  # 6

a_new = a.reshape(1, 6)
print(a_new)
# [[1 2 3 4 5 6]]  # это двумерная матрица (видно по двум парам кв.скобок), состоящая из одной строки с шестью элементами
print(a_new.shape)  # (1, 6)
print(a_new.size)  # 6

# Если количество элементов в массиве нечетное, например - 5, то мы можем сделть размерность только 1х5 или 5х1
# Если мы попытаемся сделать из массива 5 матрицу 2х3 - будет выдана ошибка.
# Хотя в листе это можно сделать
list = [[1, 2, 3], [4, 5]]
# Но, если мы переведем этот list в numpy
np_list = np.array(list)
print(np_list)
# [list([1, 2, 3]) list([4, 5])]
# получим numpy-массив из двух списков. Но, полноценный numpy мы не получим.
# Но, если мы подадим ему лист с четным количеством элементов,
list_2 = [[1, 2, 3], [4, 5, 6]]
np_list_2 = np.array(list_2)
print(np_list_2)
# [[1 2 3]
#  [4 5 6]]
# Получаем полноценную numpy-матрицу


# По сути одномерный и многомерный вектор, это одно и тоже, но в numpy это имеет разницу.
# Можно создавать массивы с бесконечным количеством элементов.

# Многомерный массив можно создавать из листа листов
two_dim_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
two_dim_np = np.array(two_dim_list)
print('Двухмерный массив из Листа: \n', two_dim_np)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]

# ----------------------- ravel() -------------------------------------
# Из 2D в 1D. Метод ravel() преобразует многомерные массивы в одномерные.
# Тот же параметр order определяет, «схлопнется» ли массив построчно или столбец за столбцом:
# print(a1_2d)
# > [[ 1  2  3  4]
#    [ 5  6  7  8]
#    [ 9 10 11 12]]
#
# print(a1_2d.ravel())  # строка за строкой
# > [ 1  2  3  4  5  6  7  8  9 10 11 12]
#
# print(a1_2d.ravel(order='F'))  # столбец за столбцом
# > [ 1  5  9  2  6 10  3  7 11  4  8 12]

# Эта ф-я вытягивает все элементы массива в строку. То есть, отменяет все операции reshape()
print('Вытягиваем массив в строку ', two_dim_np.ravel())
# [1 2 3 4 5 6 7 8 9]
# Здесь элементы массива расположились в одну строку. Но, на самом деле, в памяти они распологаются по столбцам.
# Чтобы ravel() этого не делал, в аргументы можно вставить 'F'
print('Вытягиваем массив в строку с F ', two_dim_np.ravel('F'))
# Тогда увидим, как они на самом деле располагаются в памяти
# [1 4 7 2 5 8 3 6 9]

# То же касается и ф-и reshape()
print('reshape() с F ', two_dim_np.reshape((3,3), order='F'))
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]


# -------------------------- Индексация ------------------------

# Имеем массив
print(a)
# [1 2 3 4 5 6]

# К его элементам мы можем обращаться по индексам

print(a[0])  # 1
print(a[1])  # 2
print(a[-1])  # 6 - последний элемент

# ----------------------- Обращение к элементам многомерного масива ----------------------------

# Можно получать элементы из многомерного массива двумя сособами: запись индексов с двумя парами скобок или с одной
# Если нужно получить конкретынй элемент из массива, который например, находится в строке с индексом 1 (2-я строка),
# в первых скобках указываем индекс строка, во вторых - индекс самого элемента в этой строке (столбец)
print('Элемент из 2-мерного массива ', two_dim_arr[1][1])  # 5
# Второй способ с одной парой скобок, через запятую
print('Элемент из 2-мерного массива ', two_dim_arr[1, 1])  # 5


# Как выглядит массив two_dim_arr
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

# Обрщаться по одному индексу к многомерному массиву неправильно [1].
# Даже если мы указываем один индекс, рядом с ним должно стоять двоеточие [1,:]
# Если это многомерный массив, то двоеточие используется обязательно.
print('Вывели строку с индексом 1 ', two_dim_arr[1,:])  # [4 5 6 7]

# Для разнообразия посмотрим на столбец с индексом 1
print('Вывели столбец с индексом 1 ', two_dim_arr[:,1])  # [1 5 9]
# Получили столбец с индексом 1 в виде одномерного массива
# Очень важный момент - это не равнозначно операции - вырезка из списка.
# В Питоне операция "вырезки из списка" производится через ':', то есть "слайсинг". Но это не то же самое.
# При вырезки из списка возвращается копия фрагмента. В данном случае это не так.
# Присвоим переменной 'a' строку с индексом 2 из массива
a = two_dim_arr[2,:]
print('Вторая строка из массива ', a)  # [ 8  9 10 11]
# Меняем в ней первый элемент
a[0] = 25
# Снова выводим
print(a)  # [25  9 10 11]
# Затем выводим весь изначальный массив
print(two_dim_arr)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [25  9 10 11]]  - изменение в первом индексе!
# То есть, в этом случае мы не копируем данные из массива, а воздействуем непосредственно на сам массив.

# Тогда, логичный вопрос: как сделать копию, чтобы оставить изначальный массив без изменения?
# В большинстве случаем копию массива делать не надо, так как это пустая трата времени.
# Но, если все же надо, то это делается вот так:
two_dim_arr_cop = np.array(two_dim_arr)
print('Копия ', two_dim_arr_cop)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [25  9 10 11]]

# Теперь при любом изменении в копии, изначальный массив будет нетронут.
two_dim_arr_cop[0,0] = 1000
print(two_dim_arr_cop)
# [[1000    1    2    3]
#  [   4    5    6    7]
#  [  25    9   10   11]]

print(two_dim_arr)  # изначальный массив остался без изменений
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [25  9 10 11]]


# ------------------------ Слайсинг -----------------------------

print(a[:2])  # [1 2] - от 0 до 2-го индекса (исключительно)
print(a[2:])  # [3 4 5 6] - от 2-го индекса и до конца.

# Можно делать отрицательную индексацию
print(a[:-2])  # [1 2 3 4] - от 0 до второго индекса с конца (исключительно)
print(a[1:4])  # [2 3 4] - от 1-го индекса до 4-го (исключительно)
print(a[::])  # выводит весь массив. То есть эта запись аналогична a[].

# Слайсинг можно использовать для заполнения массива элементами (broadcasting)
# Создадим массив
mas = np.arange(0, 10)
print(mas)  # [0 1 2 3 4 5 6 7 8 9]
# Заменим элементы в массиве от 5 до последнего индекса числом 10
mas[5:] = 10
print(mas)  # [ 0  1  2  3  4 10 10 10 10 10]

# Присваиваем новому массиву часть предыдущего массива
mas_new = mas[3:8]
print(mas_new)  # [ 3  4 10 10 10]  - присвоили указанный диапазон из старого массива новому

# Сделаем бродкаст для новго массива
mas_new[2:] = 7
print(mas_new)  # [3 4 7 7 7]  - получили замену трех последних значений

# Но, если сейчас выведим изначальный массив
print(mas)
# [ 0  1  2  3  4  7  7  7 10 10]
# Здесь тоже получаем замену значений, которые передали в новый массив! Не смотря, на то что была создана новая переменная.
# На самом деле при присвоении значения из сторой переменной в новую, мы лишь создаем ссылку на старый массив.
# Но, что делать, если хотим сделать копию массива без изменения первоначального массива?
# Это делается с помощью метода copy()

# ------------------------------------ copy() ---------------------------------
# Создаем копию из массива mas
mas_c = mas.copy()
print('Копия массива ', mas_c)  # [ 0  1  2  3  4  7  7  7 10 10]

# Меняем все элементы в новом массиве на нули
mas_c[:] = 0
print(mas_c)  # [0 0 0 0 0 0 0 0 0 0]
# Проверяем содержание старого массива
print(mas)  # [ 0  1  2  3  4  7  7  7 10 10]

# -------------------------- Условия в аргументах --------------------------------------
# Сравнения в массивах

# Но, что будет, если мы зададим условие?
print(a > 5)  # [False False False False False  True]
# Получаем инфомацию, какой из элементов массива удовлетворяет условию, а какой нет.
# Или по другому. Выведем нечетные числа
print(a % 2 == 0)  # [False  True False  True False  True]
# Эти результаты выводов мы можем сохранять
bool_a = a < 5
print(bool_a)  # [ True  True  True  True False False]
# И теперь мы можем использовать этот bool_a, чтобы сделать выборку. Для этого помещаем его в изначальный массив
print(a[bool_a])  # [1 2 3 4]

# Если использовать кв.скобки, можно получать значения
# Или можем ему сказать: выдай пожалуйста все значения, которые по модулю == 0 (то есть четные)
print(a[a % 2 == 0])  # [2 4 6]
# Выдай все позиции, значения которых больше двух и меньше или равно 5
print(a[(a > 2) & (a <= 5)])  # [3 4 5]
# Выдай все значения бьльше 4
print(a[a > 4])  # [5 6]

# Это то, чем удобен numpy и чего нет в list

# Двумерный numpy
# Создаем список с помощью генератора
lst_num = [i for i in range(30)]
print(lst_num)
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
# - получаем список из 30 чисел.

# Создаем из этого списка numpy-массив
np_lst_num = np.array(lst_num)
print(np_lst_num)  # [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29]
# Делаем решейп
np_lst_num = np_lst_num.reshape(6, 5)
print(np_lst_num)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]
#  [20 21 22 23 24]
#  [25 26 27 28 29]]

# Отсюда мы можем вывести избранные строки. Например, первые две
print(np_lst_num[:2, :])  # задаем количество по двум осям через запятую:
# по вертик - 2 строки (тут указываем индекс, по какой выводить; сам он не включается в диапаозон), по горизонтальной - все.
# [[0 1 2 3 4]
#  [5 6 7 8 9]]

# Или, по первой оси первые 3 строки (выводятся строки с индексами 0, 1, 2,
# а по второй все элементы через 1 (с шагом 2)  (начало : конец : шаг - не обязательный)
print(np_lst_num[:3, ::2])  #
# [[ 0  2  4]
#  [ 5  7  9]
#  [10 12 14]]

# Или по первой оси выдай первые 4 строки, а по второй 0-ю и 1-ю
print(np_lst_num[:4, [0, 1]])  #
# [[ 0  1]
#  [ 5  6]
#  [10 11]
#  [15 16]]

# Или же без слайсинга, только скобками
print('Изначал', np_lst_num)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]
#  [20 21 22 23 24]
#  [25 26 27 28 29]]
print(np_lst_num[[0, 1], [4, 2]])  # обращаемся к 1-й и 2-й строкам, из них берем 4-й и 2-й элементы: [4 7]

# Или вообще хитро сделать (сейчас забегаем немного вперед)
np_lst_sum = np_lst_num.sum(axis=1)  # берем сумму по строкам (колонки - 0) - в каждой строке суммируем значения.
print(np_lst_sum)  # [ 10  35  60  85 110 135]  - это суммы чисел в каждой строке.
# Здесь мы вызвали ф-ю sum() просуммировали значения по горизонтальной оси

# А теперь выведем те строки, у которых сумма от 50 до 100, а по второй оси выводим все значения (:)
# print(np_lst_num[50 <= np_lst_sum <= 100, :])
# Здесь мы говорим: выведи np_lst_num, но строки возьми те, у которых np_lst_sum больше 50 и меньше 100,
# а колонки выведи все.
# Но, на это выражение он ругается
# Зададим маску, которая нам выберет значения в указанных позициях.
# mask = (50 <= np_lst_sum <= 100)  # на это он также выдает ошибку. Здесь проблема в двойном выражении
# Тогда попробуем разделить
mask = (np_lst_sum >= 50) & (np_lst_sum <= 100)
print(mask)  # [False False  True  True False False] - из шести строк условию соответствуют две средние.
# Выводим значения по маске со всеми колонками
print(np_lst_num[mask, :])  # здесь подставляем маску для получения строки, и выводим все колонки ':'
# [[10 11 12 13 14]
#  [15 16 17 18 19]]
# получили те строки, в которых сумма элементов больше 50 и меньше 100


# ------------------------ Циклы в numpy -------------------------------

# По numpy-массивам также можно запускать циклы
# Имеем массив
print(a)
# [1 2 3 4 5 6]

for i in a:
    print(i)
# 1
# 2
# 3
# 4
# 5
# 6

# Еще один способ
# Смотрим шейп (форму) массива
print(a.shape)
# (6,) -  одна строка с шестью позициями. При реализации шейпа, получаем последовательность типа Тапл с 6 в индексе 0

for i in range(a.shape[0]):  # a.shape[0] - это 6
    print(a[i])
# 1
# 2
# 3
# 4
# 5
# 6
# Получаем то же самое

# Выведем на экран шейп двухмерного листа

print(np_lst_num.shape)
# (6, 5)  - количество строк - 6, элементов в каждой строке - 5

# Запускаем цикл на основе этого шейпа
for i in range(np_lst_num.shape[0]):  # идем по первой оси [0] - то есть здесь просто делаем выбор строк
    print('Строка ', i, sep='')  # выводим номер строки начиная с 0. Если хотим с 1, то пишем: i+1
    for j in range(np_lst_num.shape[1]):  # идем по второй оси [1] - строки в пределах одной колонки, те по одной позиции
        print(np_lst_num[i, j])  # выводим последовательно каждую строку и колонки по каждой строке.
    print()
# Строка 0
# 0
# 1
# 2
# 3
# 4
#
# Строка 1
# 5
# 6
# 7
# 8
# 9
#
# Строка 2
# 10
# 11
# 12
# 13
# 14
#
# Строка 3
# 15
# 16
# 17
# 18
# 19
#
# Строка 4
# 20
# 21
# 22
# 23
# 24
#
# Строка 5
# 25
# 26
# 27
# 28
# 29

# Можно это же вывести красиво по строчкам

# команад print() всегда переводит на новую строку, но им делать не удобно.
# Мы просто будем накапливать строку
curr_str = ''  # создаем переменную с пустой буферной строкой
for i in range(np_lst_num.shape[0]):  # проходимся по оси [0] - это строки, которые перебираем поочередно.
    curr_str = ''  # каждый раз, когда новая строка, сбрасываем текущую строку в ноль, то есть очищаем
    # print('Строка ', i, sep='')
    for j in range(np_lst_num.shape[1]):  # проходим по всем позициям (колонкам - [1]) выбранной строки в цикле i
        curr_str += str(np_lst_num[i, j]) + ' '  # в очищенную строку добавляем считанные элементы
        # здесь построчно добавляем выводимые элементы приведенные к типу str и разделяем их пробелами
    print(curr_str)  # собранную строку выводим на экран и затем циклы повторяются

# 0 1 2 3 4
# 5 6 7 8 9
# 10 11 12 13 14
# 15 16 17 18 19
# 20 21 22 23 24
# 25 26 27 28 29
# Вот таким образом выводится двумерная numpy
# Сам numpy конечно по-умнее выводится, но это вариант самописного.


# ------------------------ ВСТРОЕННЫЕ МЕТОДЫ NumPy --------------------------

# ----------------------------- ДЛЯ ЦИФР ------------------------------------
# Имеем одномерный массив 'a'
print(a)
# [1 2 3 4 5 6]

# и двухмерный
print(np_lst_num)
# [[ 0  1  2  3  4]
#  [ 5  6  7  8  9]
#  [10 11 12 13 14]
#  [15 16 17 18 19]
#  [20 21 22 23 24]
#  [25 26 27 28 29]]

# На их примерах разберем методы

# -------------------------------- sum() --------------------------------
# Суммирует значения
print(a.sum())  # 21
print(np_lst_num.sum())  # 435

# Здесь можно указать, по какой оси суммировать
print(np_lst_num.sum(axis=0))  # здесь он просуммирует по вертикальной оси - все колонки.
# [75 81 87 93 99]
# Это все в сумме даст предыдущее значене - 435
# А если еще добавим по первой оси, то он просуммирует построчно
print(np_lst_num.sum(axis=1))  # здесь он просуммирует по горизонтальной оси - все строки.
# [ 10  35  60  85 110 135]

# -------------------------------- mean() ---------------------------------
# Выдает среднее значение всех элементов
print(a.mean())  # 3.5

# -------------------------------- max() ----------------------------------
# Выдает максимальное значеине из всех значений
print(a.max())  # 6
# или эдентичная запись
np.max(a)

print('Максимум всего массива ', np_lst_num.max())  # максимальное значение из всего массива
print(np_lst_num.max(axis=0))  # [25 26 27 28 29] - максимальные значения по колонкам
print(np_lst_num.max(axis=1))  # [ 4  9 14 19 24 29] - максимальные значения по строкам

# -------------------------------- min() ---------------------------------
# Выдает максимальное значеине из всех значений
print(a.min())  # 1
# или
np.min(a)

# --------------------------------- argmax() argmin() -----------------------
# Получение индекса максимального/минимального элемента массива
print('Макс.число ', a.argmax())  # Макс.число  5
print('Мин.число ', a.argmin())  # Мин.число  0

# -------------------------------- prod() ---------------------------------
# Выдает произведение всех значений (перемножает)
print(a.prod())  # 720


# --------------------------------------- ДЛЯ СТРОК --------------------------

# Имеем массив строк

print(b)
# ['cat' 'mouse' 'dog' 'rat']

# --------------------------------- sort() ---------------------------
b.sort()
print(b)  # ['cat' 'dog' 'mouse' 'rat'] - сортирует по алфовиту (по первым буквам)

# Для цифр он также работает
d = [24, 65, 1, 23, 235, 4578, 12]
d_numpy = np.array(d)  # приводим лист к numpy
d_numpy.sort()
print(d_numpy)
# [   1   12   23   24   65  235 4578]

# Обратная сортировка
d_numpy = d_numpy[::-1]  # -1 - шаг в обратном порядке
print(d_numpy)
# [4578  235   65   24   23   12    1]
d_numpy = d_numpy[::-2]  # -2 - в обратном порядке с шагом 2
print(d_numpy)
# [   1   23   65 4578]


# ----------------------- ОПЕРАЦИИ С МАССИВАМИ --------------------------

# -------------------------- arange() -------------------------
# Это функция-генератор создания массивов

# В numpy создание массива может быть еще более простым
# Ф-я arange() создает массив из чисел, идущих по порядку.

print(np.arange(5))
# [0 1 2 3 4]
# Это то же самое, что и обычный range()

# с диапазоном
print(np.arange(3, 6))  # правая граница не включается в диапазон
# [3 4 5]

# с шагом
print(np.arange(3, 16, 5))
# [ 3  8 13]

# Создание массива с присвоением переменной
a = np.arange(5)
print(a)
# [0 1 2 3 4]

b = np.arange(3, 8)
print(b)
# [3 4 5 6 7]

# Создание многомерного массива одной командой
a_m = np.arange(12).reshape(3, 4)
print('Массив одной командой ', a_m)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]


# ---------------------------------- ВЕКТОРНЫЕ ОПЕРАЦИИ --------------------------------

print(a * 2)  # [0 2 4 6 8]  - умножение каждого элемента массива на 2
print(a ** 2)  # [ 3  5  7  9 11] - возведение каждого элемента массива в степень

# Операции с двумя массивами
# Важное условие - при выполнении этих операций, длина у массивов должна быть одинаковая.

# Имеем два массива 'a' и 'b'

# Суммирование массивов
print('Сложение двух массивов ', a + b)
# [ 3  5  7  9 11]
# Суммирование происходит поэлементно, если массивы совпадают размерами
# Это также полезная особенность NumPy
# List в такой ситуации не суммирует элементы, а соединяет их (конкотенирует)
# Чтобы суммировать их поэлементно в List, надо использоваь цикл for, что менее удобно и менее быстро.
# NumPy также удобен при математических сложениях, потому что он не объединяет элементы, а именно суммирует.

# Можно массив сложить с самим собой
print('Сложение массива с самим собой ', a + a)
# [0 2 4 6 8]

# То же самое для остальных арифметических операций
print(a - b)  # [-3 -3 -3 -3 -3]
print(a / b)  # [0.         0.25       0.4        0.5        0.57142857]
print(a * b)  # [ 0  4 10 18 28]
print(a ** b)  # [    0     1    32   729 16384]
# print(b // a)  # [0 4 2 2 1]
# - здесь он ругается на деление на 0: RuntimeWarning: divide by zero encountered in floor_divide

# То же можно делать и со скалярами (с числами)

print(a + 1)  # Каждый элемент массива увеличиваем на 1
# [1 2 3 4 5]

# При делении чисел на ноль получаем предупреждение
print('Делим на ноль ', a / 0)  # [nan inf inf inf inf]
# Первый элемент 0. Деление 0 на 0 выдает результат not a number (nan)
# В случае деления числа на 0 получаем бесконечность infinity (inf)
# При делении этого массива самого на себя получаем то же предупреждение
print(a / a)  # [nan  1.  1.  1.  1.]
# Такой вывод позволяет продолжить выполнение кода без его остановки из-за этой ошибки. Будет просто предупреждение.

a ** 2  # все элементы массива возводим во второу степерь

# Квадратный корень всех элементов массива
a_sqrt = np.sqrt(a)  #
print('Квадратный корень всех элементов', a_sqrt)
# [0.         1.         1.41421356 1.73205081 2.        ]

# Экспонента все элеменртов массива
print('Экспонента всех элементов ', np.exp(a))
# [ 1.          2.71828183  7.3890561  20.08553692 54.59815003]


# Можно делать сложные комбинации

print((a * b - a) ** 2)  # [  0   9  64 225 576]

# К операциям можно добавлять ф-и
n = ((a * b - a) ** 2).sum()
print(n)  # 874

n = ((a * b - a) ** 2).mean()
print(n)  # 174.8

# Можно делать операции по индексам

v = a * 5 + b[0] * 17
# a * 5 - каждый элемент массива 'a' умножаем на скаляр(одно число) - это будте вектор
# затем ко всем ячейкам массива 'a' прибавляем  произведение одного элемента по индексу 0 массива b на скаляр 17
print(v)  # [51 56 61 66 71]

# C NumPy это все очень удобно выполнять. Этого нет в List
# Хотя в List также есть плюсы. Например, в List можно присоединять в конец массива.
# Чтобы сделать это в NumPy, numpy-массив, если он двумерный, он обязательно должне быть квадратный.
# Тогда как листы могут быть любыми.
# Поэтому, мы будем использовать и List и NumPy


# -------------------------- МНОГОМЕРНЫЕ МАССИВЫ --------------------------------

# Мы уже рассматривали двумерные.

# ------------------------- Индексация -----------------------------

# Имеем лист

a_list = [[3, 6, 2, 7],
          [9, 2, 4, 8],
          [8, 2, 3, 6]]

# Переводим его в numpy
np_a_list = np.array(a_list)

# Это можно было сделать и сразу
np_list = np.array([[1,2], [3,4], [5,6], [7,8]])  # четыре строки по два столбца в каждой
print(np_list)
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]


# Вывод построчно

print(a_list)  # [[3, 6, 2, 7], [9, 2, 4, 8], [8, 2, 3, 6]]

# Нулевая строка
print(np_a_list[0])  # [3 6 2 7]

# Первая строка
print(np_a_list[1])  # [9 2 4 8]

# Последняя строка
print(np_a_list[-1])  # [8 2 3 6]

# Обращение поэлементно
print(np_a_list[1, 2])  # 4


# Вывод по столбцам

# Нулевой столбец
print(np_a_list[1:, 0])  # [9 8]  - нулевой столбец с первого индекса до последнего

# Все строки - первый столбец
print(np_a_list[:, 1])  # [6 2 2]


# -------------- Ф-и быстрого создания numpy-массивов ---------------------

# ------------------------------------ empty() ------------------------

# Это первый и самый тупой способ создания массива - пустой массив
A = np.empty((3,4), dtype=np.float32)  # в скобках указываем форму массива и его тип. Когда мы, при создании массива,
# не указываем его тип - это исключение из правил.
# Если сейчас его выведем на экран, то увидим, что его элементы имеют случайные значения
print('Пустой массив\n ', A)
#  [[-1.4012985e-45  2.8025969e-44  0.0000000e+00  0.0000000e+00]
#  [ 0.0000000e+00  1.7950633e-42  6.0185311e-36  2.9427268e-44]
#  [-4.9230647e-03 -1.0303581e-03 -1.8485262e-27  1.4026998e-42]]
# Это полезно в том случае, если нам не важно, чем массив заполнен и мы потом его заполним тем, чем нам надо.
# Но, как правило, пустой массив, это потенциально опасная ситуация - случайные значения, это не очень хорошо.
# Поэтому предусмотрены способы создания уже заполненных массивов.


# -------------------- ones_like() --------------------------------------

# Чаще всего numpy-массивы не делаются из листов, как мы делали до этого.
# Обычно они копируются из уже готовых numpy-массивов
# Это делает ф-я ones_like()

b_ = np.ones_like(np_a_list)  # она сделает массив из единиц таким же размером, как и массив np_a_list
print(b_)
# [[1 1 1 1]
#  [1 1 1 1]
#  [1 1 1 1]]

# ------------------------ ones() ------------------------------

# Массив из нулей с помощь ф-и np.ones()
c_ = np.ones((12, 8), dtype=np.complex64)  # задаем размер матирцы 12х8 как Тапл в скобках с указанием его типа
# Для разнообразия возьмем комплексный тип.
print(c_)
# [[1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]
#  [1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j 1.+0.j]]
# Получаем массив, заполненный одними единицами.

# ---------------------------------- zeros() --------------------------------

# Или, можно сделать массив из нулей с помощью ф-и np.zeros()

a1 = np.zeros(10)  # одномерный массив из 10 нулей
print(a1)
# [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]

a_ = np.zeros((5, 3), dtype=np.float64)  # указываем размер 5х3 как Тапл (в скобках) и его тип
print('Массив из нулей\n ', a_)
# [[0. 0. 0.]
#  [0. 0. 0.]
#  [0. 0. 0.]
#  [0. 0. 0.]
#  [0. 0. 0.]]

# ----------------------------------- full() -------------------------------

# Можно задать массив, заполненый произвольными значниями

D = np.full((5,3), 46, dtype=np.int64)  # в скобках задаем форму, значение, которым надо заполнить и тип.
print('Произольные значения\n', D)
# [[46 46 46]
#  [46 46 46]
#  [46 46 46]
#  [46 46 46]
#  [46 46 46]]

# Сеточный массив. Это создание массива с шагом 0,1

X1 = np.arange(0, 100, 0.1, dtype=np.float64)
print(X1)

# [ 0.   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1.   1.1  1.2  1.3
#   1.4  1.5  1.6  1.7  1.8  1.9  2.   2.1  2.2  2.3  2.4  2.5  2.6  2.7
#   2.8  2.9  3.   3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8  3.9  4.   4.1
#   4.2  4.3  4.4  4.5  4.6  4.7  4.8  4.9  5.   5.1  5.2  5.3  5.4  5.5
#   5.6  5.7  5.8  5.9  6.   6.1  6.2  6.3  6.4  6.5  6.6  6.7  6.8  6.9
#   7.   7.1  7.2  7.3  7.4  7.5  7.6  7.7  7.8  7.9  8.   8.1  8.2  8.3
# ...........................................................
#  92.4 92.5 92.6 92.7 92.8 92.9 93.  93.1 93.2 93.3 93.4 93.5 93.6 93.7
#  93.8 93.9 94.  94.1 94.2 94.3 94.4 94.5 94.6 94.7 94.8 94.9 95.  95.1
#  95.2 95.3 95.4 95.5 95.6 95.7 95.8 95.9 96.  96.1 96.2 96.3 96.4 96.5
#  96.6 96.7 96.8 96.9 97.  97.1 97.2 97.3 97.4 97.5 97.6 97.7 97.8 97.9
#  98.  98.1 98.2 98.3 98.4 98.5 98.6 98.7 98.8 98.9 99.  99.1 99.2 99.3
#  99.4 99.5 99.6 99.7 99.8 99.9]
# Тип float, это числа с плавающей точкой. А эти числа являются приближенными.
# Может случиться так, что в массив может быть вставлено значение 99.99999999, но, по сути это то же что и 100.
# Поэтому данной функцией arange() надо пользоваться аккуратно, так как мы не может точно сказать,
# какое число будет последним, где она остановится.
# Поэтому, в этом плане более удобной ф-ей является ф-я linspace()

# -------------------------------- linspace() ---------------------------

# Эта ф-я возвращает равномерно распределенное множество. Это множество, в котором расстояние между элементами одинаковое

d_ = np.linspace(0, 5, 5, dtype=np.float64)  # старт, стоп и количество равномерно распределенных элементов
print(d_)  # [0.   1.25 2.5  3.75 5.  ]
# Получаем пять элементов от 0 до 5, которые равномерно распределены
# Разница между этими элементами составляет одно и то же число - 1.25
d_1 = np.linspace(0, 10, 5)  # меняя настройки, мы получим другую разницу между числами
print(d_1)  # [ 0.   2.5  5.   7.5 10. ]  - разницам - 2,5
# Это всегда одномерный массив (видно по одной паре квадратных скобок).
# Эта ф-я гарантированно включит в наш диапазон цифры, указанные в старте и в стоп.

# Трехмерный массив
d_ = np.linspace(15, 37, 24, dtype=np.float64).reshape(2, 3, 4)
print(d_)
# [[[15.         15.95652174 16.91304348 17.86956522]
#   [18.82608696 19.7826087  20.73913043 21.69565217]
#   [22.65217391 23.60869565 24.56521739 25.52173913]]
#
#  [[26.47826087 27.43478261 28.39130435 29.34782609]
#   [30.30434783 31.26086957 32.2173913  33.17391304]
#   [34.13043478 35.08695652 36.04347826 37.        ]]]

# -------------------------------- logspace() -------------------------
# Это менее распространенный способ создания массива.
# Это ф-я похожа на linspace(), только раскидывает точки равномерно по лагорифмической шкале
X3 = np.logspace(0, 100, 101, dtype=np.float64)
# здесь базовые числа 0 и 100 используются как показатель степени
print('logspace\n', X3)
# [1.e+000 1.e+001 1.e+002 1.e+003 1.e+004 1.e+005 1.e+006 1.e+007 1.e+008
#  1.e+009 1.e+010 1.e+011 1.e+012 1.e+013 1.e+014 1.e+015 1.e+016 1.e+017
#  1.e+018 1.e+019 1.e+020 1.e+021 1.e+022 1.e+023 1.e+024 1.e+025 1.e+026
#  1.e+027 1.e+028 1.e+029 1.e+030 1.e+031 1.e+032 1.e+033 1.e+034 1.e+035
#  1.e+036 1.e+037 1.e+038 1.e+039 1.e+040 1.e+041 1.e+042 1.e+043 1.e+044
#  1.e+045 1.e+046 1.e+047 1.e+048 1.e+049 1.e+050 1.e+051 1.e+052 1.e+053
#  1.e+054 1.e+055 1.e+056 1.e+057 1.e+058 1.e+059 1.e+060 1.e+061 1.e+062
#  1.e+063 1.e+064 1.e+065 1.e+066 1.e+067 1.e+068 1.e+069 1.e+070 1.e+071
#  1.e+072 1.e+073 1.e+074 1.e+075 1.e+076 1.e+077 1.e+078 1.e+079 1.e+080
#  1.e+081 1.e+082 1.e+083 1.e+084 1.e+085 1.e+086 1.e+087 1.e+088 1.e+089
#  1.e+090 1.e+091 1.e+092 1.e+093 1.e+094 1.e+095 1.e+096 1.e+097 1.e+098
#  1.e+099 1.e+100]
# Показатель степени изменяется через 1.

# ------------------------------ geomspace() -------------------------------
# Раскидывает точки в геометрической прогрессии
X4 = np.geomspace(1, 100, 101, dtype=np.float64)  # в качестве начального параметра не принимает 0.
print('geomspace\n', X4)
#  [  1.           1.04712855   1.0964782    1.14815362   1.20226443
#    1.25892541   1.31825674   1.38038426   1.44543977   1.51356125
#    1.58489319   1.65958691   1.73780083   1.81970086   1.90546072
#    1.99526231   2.08929613   2.18776162   2.29086765   2.39883292
#    2.51188643   2.63026799   2.7542287    2.8840315    3.01995172
#    3.16227766   3.31131121   3.4673685    3.63078055   3.80189396
#    3.98107171   4.16869383   4.36515832   4.5708819    4.78630092
#    5.01187234   5.2480746    5.49540874   5.75439937   6.02559586
#    6.30957344   6.60693448   6.91830971   7.2443596    7.58577575
#    7.94328235   8.31763771   8.7096359    9.12010839   9.54992586
#   10.          10.47128548  10.96478196  11.48153621  12.02264435
#   12.58925412  13.18256739  13.80384265  14.45439771  15.13561248
#   15.84893192  16.59586907  17.37800829  18.19700859  19.05460718
#   19.95262315  20.89296131  21.87761624  22.90867653  23.98832919
#   25.11886432  26.30267992  27.54228703  28.84031503  30.1995172
#   31.6227766   33.11311215  34.67368505  36.30780548  38.01893963
#   39.81071706  41.68693835  43.65158322  45.70881896  47.86300923
#   50.11872336  52.48074602  54.95408739  57.54399373  60.25595861
#   63.09573445  66.0693448   69.18309709  72.44359601  75.8577575
#   79.43282347  83.17637711  87.096359    91.20108394  95.4992586
#  100.        ]

# Итак, есть три основных ф-и для формирования массивов:
# 1 - arange() - распределяет точки через равный интервал
# 2 - linspace() - делит диапазон на указанное число частей по линейной шкале
# 3 - logspace() - делает то же, что и linspace, но при делении диапазона использует показатель степени
# по лагорифмической шкале.

# ------------------------------- identity() ------------------------
# Единичная матрица. Она всегда двухмерная и всегда квадратная

E = np.identity(10, dtype=np.float64)  # задаем один параметр, так как матрица квадратная
print('identity\n', E)
# [[1. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
#  [0. 1. 0. 0. 0. 0. 0. 0. 0. 0.]
#  [0. 0. 1. 0. 0. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 1. 0. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 1. 0. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 1. 0. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 1. 0. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 0. 1. 0.]
#  [0. 0. 0. 0. 0. 0. 0. 0. 0. 1.]]


# --------------------------------------- eye() -------------------------------
# Эта ф-я создает Identity matrix / Единичную матрицу
# Это матрица из нулей с единицами по диагонали, которая начинается с первого элемента матрицы и заканчивается последним.

m_ = np.eye(3)  # матрица 3х3
print(m_)
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]


# -------------------------------------
# Умножение всех элементов массива на число
# В матрицах мы также можем умножать на число

b_ = b_ * 2
print(b_)
# [[2 2 2 2]
#  [2 2 2 2]
#  [2 2 2 2]]

# Можно умножать матрицу на матирцу, если они совпадают размерами.
# Здесь умножение происходит поэлементно

print(a_list * b_)
# [[ 6 12  4 14]
#  [18  4  8 16]
#  [16  4  6 12]]


# Что делают матрицы?
# Матрица это один из основых математических аппаратов. С помощью них решают уровнения, делают апроксимации.
# Любые математические методы построены на матрицах.
# Пока для нас матирца, это двухмерный массив
# https://www.numpy.org - документация по numpy


# -------------------------- Создание случайного массива (матриц) -------------------------

# --------------------------------------- rand() ----------------------------
# Ф-я rand() возвращает распределенные числа
r_a = np.random.rand(3)  # в скобках передеаем количество элементов
print(r_a)  # [0.26295925 0.86094219 0.10804199]
# Получаем три случайных числа значением 0 до 1
# Это одномерный массив. Если хотим получсить двумерный - в скобках помещаем два числа
r_a_2 = np.random.rand(3, 4)
print(r_a_2)
# [[0.35670423 0.33045392 0.69668886 0.87599185]
#  [0.45371986 0.52534176 0.20873434 0.0511607 ]
#  [0.60906173 0.17519525 0.85137775 0.17951122]]
# Получаем двумерный массив (две пары кв.скобок) размерностью 3х4

# ---------------------------- randn() ---------------------------------
# Ф-я randn() возвращает нормально распределенные числа
r_n = np.random.randn(5)
print(r_n)
# [0.4619619  1.37952577 0.0024386  0.58737799 0.65258035]

# Двухмерный массив
r_n_2 = np.random.randn(3, 5)
print(r_n_2)
# [[ 0.11240541  0.88797712 -0.76090493  0.39046211  0.32887074]
#  [ 1.64754416 -0.53392785  2.16685259  0.36912093  1.37752072]
#  [-1.71455156  0.02808839 -1.50790139 -1.42062286 -1.62162641]]

# Трехмерный массив
r_n_3 = np.random.randn(2, 3, 5)
print('Трехмернй массив\n', r_n_3)


# ------------------------------- normal() -------------------------------
# Случайный массив нормального распределения

rr = np.random.normal(0, 1, (5, 5))  # параметры нормального распределения:
# 0 - значения будут в среднем в районе нуля
# 1 - разброс в среднем около единицы
# (5, 5) - размер матирцы 5х5
print(rr)
# Получаем случайную матрицу
# [[-0.63872884 -0.33709566  0.32300119 -0.22495419  2.30013934]
#  [ 0.33972845  0.2432945   0.23218102 -1.03986708 -1.37906376]
#  [-0.03062204  0.05740744 -1.05338489 -0.48989401  1.18556802]
#  [-1.41746247 -0.81574536  0.79924037 -0.30905458  1.41501183]
#  [-1.57372734  0.76248778 -0.09685025 -0.44906005 -1.44867099]]

# Почему случайная?
# При каждом запуске расчета, будут выдаваться новые случайные велечины
# [[ 1.24701787 -1.39613534 -0.26663356  0.689353    1.04496652]
#  [ 1.38255089 -0.04465846  0.74089134  0.47437058  0.27041353]
#  [-0.64641649 -0.4218203   0.75355706  0.57893304 -0.26714739]
#  [ 1.11584443  0.75603918  0.3494514   0.45091684  0.1791541 ]
#  [ 0.17316534 -1.37216487  0.26336408  0.83848343 -0.94691011]]


# ------------------------------- randint() -------------------------------
# Возвращает случайные целые числа

# Одномерная матрица
r_i = np.random.randint(0, 5, 10)
# параметры: старт диапазона (включен в диапазон), конец диапазона (исключительно), количество элементов
print(r_i)  # [0 0 3 4 0 1 0 2 2 1]

# Двухмерная матрица
r_i_1 = np.random.randint(0, 10, (5, 5))  # условия: числа в диапазоне от 0 до 10, размер матирцы 5х5
# Случайных распределений не бывает, но random - это псевдогенератор случайных чисел, который генерит что-то похожее
# на случайное распределение.
print(r_i_1)
# [[4 2 8 8 1]
#  [3 8 1 7 0]
#  [4 1 6 2 5]
#  [1 8 0 6 7]
#  [1 7 5 1 6]]
# Получаем матрицу размером 5х5 случайных чисел от 0 до 10.
# Это как создавать случайные велечины. Они используются постоянно в нейронках и data cience

# Трехмерный массив
my_3d_array = np.random.randint(15, 37, 24).reshape(2, 3, 4)
print('Трехмерный массив\n',my_3d_array)

# -------------------------- Задачи ----------------

# Создайте массив, который будет содержать списки с именем студента(str), его возрастом(int) и средней оценкой(float).
# Отсортируйте такой массив
# Замените значение, отвечающее за возраст, у всех студентов на одно и то же, например, 10. Отсортируйте такой массив теперь.

# dt = [('name', 'S10'), ('age', int), ('mark', float)]
# # std_list = [('Alex', 20, 4.3), ('Kate', 19, 4.8), ('Maks', 21, 4.1), ('Marry', 22, 4.6), ('Denis', 18, 3.8), ('Ann', 21, 4.2)]
# print(type(std_list))  # <class 'numpy.ndarray'>

std_list = np.array([('Alex', 20, 4.3),
                     ('Kate', 19, 4.8),
                     ('Maks', 21, 4.1),
                     ('Marry', 22, 4.6),
                     ('Denis', 18, 3.8),
                     ('Ann', 21, 4.2)],
                    dtype=[('name', '<U10'), ('age', 'int32'), ('mark', 'float32')])

# std_list= std_list.reshape(1,6)

print((np.sort(std_list, order='name')))  # сорт по имени (алфавит)
print()
print((np.sort(std_list, order='age')))  # сорт по возрасту
print()
print((np.sort(std_list, order='mark'))[::-1])  # сорт успеваемости
#
# std_list_sort = np.array(std_list, dtype=dt)       # создаем структуру массива
# print(type(std_list_sort))
# std_list_sort = std_list_sort.reshape(6,1)
# print(std_list_sort)
# print()
#
# # Сортируем массив
# std_list_np_s = np.sort(std_list_sort, order='name')
# print(std_list_np_s)
# std_list_np_v = np.sort(std_list_np, axis=0, order=1)

# # ------------------------------------------------------
# dtype = [('name', 'S10'), ('height', float), ('age', int)]
# values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38), ('Galahad', 1.7, 38)]
# a = np.array(values, dtype=dtype)       # create a structured array
# np.sort(a, order='height')
# array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
#        ('Lancelot', 1.8999999999999999, 38)],
#       dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])

# Заменяем возраст на одно число
std_list['age'] = 10
print((np.sort(std_list, order='name'))[::-1])  # сорт по алфавиту в обратном порядке по колонке 'name'

my_3d_array_2 = np.random.uniform(17, 23, (2, 3, 4))