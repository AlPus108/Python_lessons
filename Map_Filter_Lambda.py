# Здесь рассмотрим такие понятия, как ф-я Map, ф-я Filter и Lambda Expressions

# Lambda выражение, это быстрый способ создания анонимных ф-й в языке Python
# Анонимная ф-я, это такая ф-я, которая используется только один раз в момент ее создания.
# У нее нет имени и значит мы больше нигде не можем ее вызвать и использовать.
# Для того, чтобы больше понять контекст испльзования Lambda-выражений и анонимных ф-и,
# для начала нам надо разобрать такие понятия, как ф-я Мар и ф-я Filter. Это встроенные ф-и в языке Python.


# Функция Мар
# При наборе слова map, среда разработки выдает подсказку о том, что у нее есть два параметра:
# 1-й - function, 2-й - iter (то есть itereble - последовательность каких-то элементов)
# То есть эта ф-я Мар требует в качестве первого параметра какую-то ф-ю, которую надо создать.


# Создадим ф-ю с одним аргументом (чтобы упростить для понимания)
def sun_of_one_num(x):  # эта ф-я возвращает сумму одного аргумента, который складывается с самим собой
    return x + x


# У нас есть список чисел
num_list = [1, 2, 3, 4, 5, 6, 7]
# И мы хотим применить эту ф-ю к каждому элементу этого списка. Допустим, мы хотим складывать элемент с самим собой.
# Конечно, мы можем использовать для этого цикл for и в цикле вызывать функцию sun_of_two_num для каждого элемента.
# Но, это можно сделать быстрее, без цикла for при помощи ф-и map()

# Первым параметром передаем нашу ф-ю без скобок, а вторым параметром -  num_list (список значений)
# И сразу результат присвоим переменной
result = map(sun_of_one_num, num_list)
print(result)
# <map object at 0x01821DC0>
# Мы получаем объект типа map
# Запись такого вида говорит нам, что мы получили объект типа map: map object,
# который находится по адресу 0x01821DC0 в памяти компьютера
# Это не очень удобный для нас вариант вывода.
# Но, из этого результата мы можем получить все элементы через цикл.
for item in result:
    print(item)
# Получаем результат выполнения ф-и для каждого элемента этого списка:
# 2
# 4
# 6
# 8
# 10
# 12
# 14

# Это же можно получить и через одноэтапную конструкцию - сразу через цикл
for item in map(sun_of_one_num, num_list):
    print(item)
# Это один из способов использования ф-и map

# Но, мы также можем получать результат в форме списка. То есть, мы можем привести результат к типу List
print(list(map(sun_of_one_num, num_list)))
# Получаем эту последовательность в списке
# [2, 4, 6, 8, 10, 12, 14]


# Рассмотрим применение ф-и Мар в более сложных ф-ях.

# Создадим ф-ю, которая проверяет наличие определенного символа в строке
def is_a_in_string(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
    else:
        print("String has not 'a'")  # Нет символа в строке


# Создаем список слов
string_list = ['hi', 'was', 'name', 'she']

# Теперь при помощи ф-и Мар мы можем для каждого из элементов этого списка применить эту ф-ю.
print(list(map(is_a_in_string, string_list)))
# Получаем вывод на экран:
# String has not 'a'
# String has "a"
# String has "a"
# String has not 'a'
# [None, None, None, None]  - так как наша ф-я ничего не возвращает, мы получаем список из объектов None


# Чтобы она что-то возвращала, добавыим в нее Результат работы
def is_a_in_string_01(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
        return True
    else:
        print("String has not 'a'")  # Нет символа в строке
        return False


print(list(map(is_a_in_string_01, string_list)))
# Вывод:
# String has not 'a'
# String has "a"
# String has "a"
# String has not 'a'
# И в конец получаем список из значений, которые возвращает эта ф-я
# [False, True, True, False]

# Вы можете использовать ф-ю Мар для любой из ф-ий, которая может быть применена для объектов из списка,
# передаваемого в качестве параметра.

# Обратите внимание, что когда мы помещаем ф-ю в Мар map(is_a_in_string_01, ...) - здесь не происходит вызова ф-и,
# так как мы помещаем имя ф-и без скобок. Обычно, чтобы вызвать ф-ю, надо указывать ее имя со скобками.
# Ф-я Мар это позволяет, так как она сама вызывает указанную ей ф-ю.


# Функция Filter
# Эта ф-я также, как и ф-я Мар, работает с последовательностями
# Ф-я Filter также принимает два параметра func и iter
# Но, эта ф-я работате только с ф-ями, которые возвращают True или False, то есть, которые возвращают значения bool
# На основании этого значения, она уже извлекает из последовательностей iterable элемент, который при применении ф-и
# возвращает True и помещает в новую последовательность.

def is_num_odd(number):  # ф-я проверяет, является ли число нечетным
    return number % 2 == 1  # если нечетное число поделить на 2, в остатке получим 1
#     Если число не четное - получим True, если четное - False


# Для последовательности
num_list = [1, 2, 3, 4, 5, 6, 7]

# Используем ф-ю Filter с выводом на экран
print(filter(is_num_odd, num_list))
# В выводе получим также как и в Мар
# <filter object at 0x00F29388> - объект фильтр с адресом в памяти
# Чтобы получить саму последовательность, нам нужно либо сразу поместить ее в список,
print(list(filter(is_num_odd, num_list)))
# [1, 3, 5, 7] - получаем список нечетных чисел
# либо распечатывать в цикле for

for num in filter(is_num_odd, num_list):
    print(num)
# 1
# 3
# 5
# 7


# Ранее созданная ф-я для Мар также может быть применима для Filter. Она тоже возвращает True или False
def is_a_in_string(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
        return True
    else:
        print("String has not 'a'")  # Нет символа в строке
        return False


string_list = ['hi', 'was', 'name', 'she']

print(list(filter(is_a_in_string_01, string_list)))
# ['was', 'name']
# Результирующая последовательность состоит из строк, которые возвращают True
# Как видно из примера, ф-я Filter не выводит на экран строки из print,
# а создает новую последовательность на основании возвращаемой информации True или False
# То есть, она фильтрует переданные ей параметры по условиям переданной ей функции и выдает новый список.


# Lambda Expressions
# Используется для создания анонимных функций
# Эта ф-я без имени, которая вызывается всего лишь один раз.

# Чтобы стало более понятно, создадим обычную ф-ю

def ident(x):
    return x  # Получаем 10


# Вызываем эту ф-ю
print(ident(10))

# Перепишем то же самое, но в терминах Лямбда-функции
# Можно не создавать объект "Функция", а сразу при выводе на экран вычислить некоторое значение


print(lambda x: x)
# Здесь по порядку: Ключевое слово lambda, список аргументов (в данном случае один аргумент) х,
# после аргумента идет двоеточие, которое отделяет блок аргументов от тела ф-и,
# и тело ф-и - х (ничего не делаем с этим аргументом)
# Вывод <function <lambda> at 0x0128E928>
# Пока это ф-я, которая ничего не делает. На вход ей ничего не подается. Чтобы она приняла что-то надо записать:
print((lambda x: x)(10))
# Здесь мы берем саму ф-ю в скобки и она уже становится объектом. И в этот объект мы подаем значение 10
# Получаем то же самое - 10

# С помощью Лямбда-функции мы можем определить функцию
ident_lambda = lambda x: x
# И вызываем ее:
print(ident_lambda(10))

# В Лямбда-функцию можно передавать и более сложные конструкции
car = lambda brend, engine_volume, price: f'Car: Марка: {brend.title()}, Engine volume: {engine_volume}, Price: {price}'
# Здесь сразу после Лямбды идет список аргументов, которые передаются в тело ф-и.
# После двоеточия идет тело ф-и, которая делает форматирование строк
# Далее вызываем эту ф-ю
# Эта ф-я car() принимает на вход три переменные

print(car('volvo', 1.5, 1300000))
# Вывод: Car: Марка: Volvo, Engine volume: 1.5, Price: 1300000

# Лямбда-функция также относится к классу функция <class 'function'>,
# но между Лямбдой и обычной ф-ей есть различия.
# У Лямбда-функции на уровне байт-кода не будет своего внутреннего названия.
# Это хорошо видно в исключениях. Если мы получим исключение в ф-и Лямбда,
# то там будет написано, что исключение получено в ф-и lambda, в отличии от обычной ф-и, когда выводится ее название.

# Ф-я Лямбда может содержать только выражения и не мжет включать операторы в свое тело
# Ф-я Лямбда пишется как одна строка
# Ф-я Лямбда не поддерживает аннотацию типов
# Ф-я Лямбда может быть вызвана немедленно в отличии от ф-й, которые инициализиуются до их применения.
# Ф-я Лямбда не может содежать утверждения. Такие операторы как return, pass, accert, race
# не могут находится в коде Лямбда-функции, иначе получим ошибку.

# Лямбда-функция широко испльзуется как вспомогательная функция в ф-ях Map, Filter, Reduce
# Лямбда-функция очень широко используется при обработке данных в модуле Pandas (машинное обучение)

# Применение Лямбда-функции вместе с Мар и Filter
# Применем уже рассмотренную нам ранее более сложную ф-ю

def cube(number):
    return number ** 3  # Возводит число в третью степень


# Теперь эту ф-ю можно использовать для каких-то списков
num_list = [1, 2, 3, 4, 5, 6, 7]
# и для этой последовательности применим ф-ю Мар
print(list(map(cube, num_list)))
# Получаем список из кубов (третья степень) переданной последовательности.
# [1, 8, 27, 64, 125, 216, 343]

# Но, что если мы хотим использовать эту ф-ю всего один раз и она нам больше не нужна?
# Для этого мы можем создать анонимную ф-ю (без имени) при помощи Lambda Expressions

# def cube(number): return number ** 3  # Если мы запишем так, то это тоже корректная форма записи,
# но, по договоренности, тело ф-и переносят на следующщую строку.
# Так как мы хотим использвать эту ф-ю один раз, ей не нужно имя. Поэтому можно укоротить ее следующим образом:
# number: return number ** 3 - оставляем аргумент и тело ф-и
# Теперь просто перед названием аргумента добавляем  lambda
# lambda number: number ** 3  - также здесь не нужно слово return, так как анонимные Lambda-функции вегда сама
# возвращают какое-то значение.
# Теперь эта ф-я может проделать то же самое, что и предыдущая с именем.
# Мы ее можем испльзовать в выражениях сразу же в качестве параметра
# Вместо этого print(list(map(cube, num_list)))
# пишем это
print(list(map(lambda number: number ** 3, num_list))) # заменяем название ф-и cube на Lambda
# Получаем тот же результат
#  [1, 8, 27, 64, 125, 216, 343]
# Если вам нужна короткая ф-я, которая испльзуется один раз, испльзуйте Лямбду.

# Точно также можно использовать Лямбда-выражения и в ф-и Filter
def is_num_odd(number):  # ф-я проверяет, является ли число нечетным
    return number % 2 == 1
# Переделаем ее в Лямбда-функцию
# def is_num_odd(number): return number % 2 == 1  # записываем в одну строку
# number: number % 2 == 1  # убираем def, название ф-и и ключевое слово return
# Помещаем это выражение в Filter


print(list(filter(lambda number: number % 2 == 1, num_list)))
# [1, 3, 5, 7] - получаем список из нечетных числе

# Точно также, если мы хотим определить четные числа, нам ненужно создавать новую ф-ю.
# Это можно сделать быстро в Лямбда-выражении, слегка изменив предыдущую запись
print(list(filter(lambda number: number % 2 == 0, num_list)))  # просто меняем 1 на 0
# [2, 4, 6]  - получаем список из четных чисел

# То есть, при помощи вот такой короткой записи Лямбда-выражения мы можем создавать анонимные функции.

# Пример исопльзования со строками
string_list = ['hi', 'was', 'name', 'she']

# Используем его немного по другому с ф-ей Мар
print(list(map(lambda string: string[-1], string_list)))
# Ф-я помещает последнюю букву каждой строки в результирующий список
# ['i', 's', 'e', 'e']

# Можно сделать более сложную операцию
# Выстром все элементы в обратном порядке
print(list(map(lambda string: string[::-1], string_list)))
# ['ih', 'saw', 'eman', 'ehs']

# Лямбда-выраженмя в начале могут выглядеть пугающе и не совсем понятно и это нормально.
# Не каждую ф-ю можно привести к Лямбда-выражению. И не стоит этого делать. если это будет выглядеть слишком
# громоздко и сложно для вашего понимания или для программистов, которые будут читать ваш код в последствии
# Лямбда-выражении и анонимные ф-и в основном используются для простых случаев, когда нужно в каких-то местах
# испльзовать функциональность, которая больше нигде не будет использована.
# Если у вас возникают сложности с созданием Лямбда-выражений, вы можете создавать ф-и обычным способом.
