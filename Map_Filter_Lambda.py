from functools import reduce

# Здесь рассмотрим такие понятия, как ф-я Map, Filter, Reduce, Sorted и Lambda Expressions

# Lambda выражение, это быстрый способ создания анонимных ф-й в языке Python
# Анонимная ф-я, это такая ф-я, которая используется только один раз в момент ее создания.
# У нее нет имени и значит мы больше нигде не можем ее вызвать и использовать.
# Для того, чтобы больше понять контекст испльзования Lambda-выражений и анонимных ф-и,
# для начала нам надо разобрать такие понятия, как ф-я Мар и ф-я Filter. Это встроенные ф-и в языке Python.


# ------------------------------------ Функция Мар -------------------------------

# При наборе слова map, среда разработки выдает подсказку о том, что у нее есть два параметра:
# 1-й - function, 2-й - iter (то есть itereble - последовательность каких-то элементов)
# Мар применяет поданую ей ф-ю в качестве аргумента ко всем элементам переданного ей списка

# Пример


name = ['Маша', 'Петя', 'Михаил']  # формируем список
name_lengths = map(len, name)
# Формируем список с помощью ф-и Мар и подаем в качестве аргументов ф-ю len(),
# которая возвращает длину строки (количество символов входящих в строку) и наш список name
# Мар применяем ф-ю len() к каждому элементу данного списка
# и формирует новый список из длин строк, входящих в список name
print(list(name_lengths))
# Вывод: [4, 4, 6]


# То есть эта ф-я Мар требует в качестве первого параметра какую-то ф-ю, встроенную или созданную.


# Создадим ф-ю с одним аргументом (чтобы упростить для понимания)
def sun_of_one_num(x):  # эта ф-я возвращает сумму одного аргумента, который складывается с самим собой
    return x + x


# У нас есть список чисел
num_list = [1, 2, 3, 4, 5, 6, 7]
# И мы хотим применить эту ф-ю к каждому элементу этого списка. Допустим, мы хотим складывать элемент с самим собой.
# Конечно, мы можем использовать для этого цикл for и в цикле вызывать функцию sun_of_two_num для каждого элемента.
# Но, это можно сделать быстрее, без цикла for при помощи ф-и map()

# Первым параметром передаем нашу ф-ю без скобок, а вторым параметром -  num_list (список значений)
# И сразу результат присвоим переменной
result = map(sun_of_one_num, num_list)
print(result)
# <map object at 0x01821DC0>
# Мы получаем объект типа map
# Запись такого вида говорит нам, что мы получили объект типа map: map object,
# который находится по адресу 0x01821DC0 в памяти компьютера
# Это не очень удобный для нас вариант вывода.
# Но, из этого результата мы можем получить все элементы через цикл.
for item in result:
    print(item)
# Получаем результат выполнения ф-и для каждого элемента этого списка:
# 2
# 4
# 6
# 8
# 10
# 12
# 14

# Это же можно получить и через одноэтапную конструкцию - сразу через цикл
for item in map(sun_of_one_num, num_list):
    print(item)
# Это один из способов использования ф-и map

# Но, мы также можем получать результат в форме списка. То есть, мы можем привести результат к типу List
print(list(map(sun_of_one_num, num_list)))
# Получаем эту последовательность в списке
# [2, 4, 6, 8, 10, 12, 14]


# Рассмотрим применение ф-и Мар в более сложных ф-ях.

# Создадим ф-ю, которая проверяет наличие определенного символа в строке
def is_a_in_string(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
    else:
        print("String has not 'a'")  # Нет символа в строке


# Создаем список слов
string_list = ['hi', 'was', 'name', 'she']

# Теперь при помощи ф-и Мар мы можем для каждого из элементов этого списка применить эту ф-ю.
print(list(map(is_a_in_string, string_list)))
# Получаем вывод на экран:
# String has not 'a'
# String has "a"
# String has "a"
# String has not 'a'
# [None, None, None, None]  - так как наша ф-я ничего не возвращает, мы получаем список из объектов None


# Чтобы она что-то возвращала, добавыим в нее Результат работы
def is_a_in_string_01(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
        return True
    else:
        print("String has not 'a'")  # Нет символа в строке
        return False


print(list(map(is_a_in_string_01, string_list)))
# Вывод:
# String has not 'a'
# String has "a"
# String has "a"
# String has not 'a'
# И в конец получаем список из значений, которые возвращает эта ф-я
# [False, True, True, False]

# Вы можете использовать ф-ю Мар для любой из ф-ий, которая может быть применена для объектов из списка,
# передаваемого в качестве параметра.

# Обратите внимание, что когда мы помещаем ф-ю в Мар map(is_a_in_string_01, ...) - здесь не происходит вызова ф-и,
# так как мы помещаем имя ф-и без скобок. Обычно, чтобы вызвать ф-ю, надо указывать ее имя со скобками.
# Ф-я Мар это позволяет, так как она сама вызывает указанную ей ф-ю.

# Примеры
# Создадим ф-ю перевода миль в киллометры


def miles_to_km(miles):  # на вход подаются мили
    return miles*1.6  # переводим мили в километры. Эта операция приведет возвращаемый результат к типу float


# Создаем массив/список, который хранит мили
mile_dist = [1.0, 1.6, 2.3]

# И далее применим ф-ю Мар
km_dist = list(map(miles_to_km, mile_dist))
print(type(km_dist), km_dist)
# [1.6, 2.5600000000000005, 3.6799999999999997]


# ------------------------------------- Функция Filter ------------------------------

# Эта ф-я также, как и ф-я Мар, работает с последовательностями
# Ф-я Filter также принимает два параметра func и iter
# Но, эта ф-я работате только с ф-ями, которые возвращают True или False, то есть, которые возвращают значения bool
# На основании этого значения, она уже извлекает из последовательностей iterable элемент, который при применении ф-и
# возвращает True и помещает в новую последовательность.

def is_num_odd(number):  # ф-я проверяет, является ли число нечетным
    return number % 2 == 1  # если нечетное число поделить на 2, в остатке получим 1
#     Если число не четное - получим True, если четное - False


# Для последовательности
num_list = [1, 2, 3, 4, 5, 6, 7]

# Используем ф-ю Filter с выводом на экран
print(filter(is_num_odd, num_list))
# В выводе получим также как и в Мар
# <filter object at 0x00F29388> - объект фильтр с адресом в памяти
# Чтобы получить саму последовательность, нам нужно либо сразу поместить ее в список,
print(list(filter(is_num_odd, num_list)))
# [1, 3, 5, 7] - получаем список нечетных чисел
# либо распечатывать в цикле for

for num in filter(is_num_odd, num_list):
    print(num)
# 1
# 3
# 5
# 7


# Ранее созданная ф-я для Мар также может быть применима для Filter. Она тоже возвращает True или False
def is_a_in_string(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
        return True
    else:
        print("String has not 'a'")  # Нет символа в строке
        return False


string_list = ['hi', 'was', 'name', 'she']

print(list(filter(is_a_in_string_01, string_list)))
# ['was', 'name']
# Результирующая последовательность состоит из строк, которые возвращают True
# Как видно из примера, ф-я Filter не выводит на экран строки из print,
# а создает новую последовательность на основании возвращаемой информации True или False
# То есть, она фильтрует переданные ей параметры по условиям переданной ей функции и выдает новый список.

# Отсортируем список и найдем элементы, которые бульше 50
list_temp = [32, 16 ,44, 85, 100, 5]

list_50 = list(filter(lambda x: x > 50, list_temp))
print('Сортировка списка больше 50 ', list_50)  #  [85, 100]

# В том же списке найдем только нечетные числа
list_50 = list(filter(lambda x: x % 2 == 1, list_temp))
print('Поиск нечетных чисел ', list_50)  #  [85, 5]


# ----------------------------- Lambda Expressions -------------------------------

# Используется для создания анонимных функций
# Эта ф-я без имени, которая вызывается всего лишь один раз.

# Чтобы стало более понятно, создадим обычную ф-ю

def ident(x):
    return x  # Получаем 10


# Вызываем эту ф-ю
print(ident(10))

# Перепишем то же самое, но в терминах Лямбда-функции
# Можно не создавать объект "Функция", а сразу при выводе на экран вычислить некоторое значение


print(lambda x: x)
# Здесь по порядку: Ключевое слово lambda, список аргументов (в данном случае один аргумент) х,
# после аргумента идет двоеточие, которое отделяет блок аргументов от тела ф-и,
# и тело ф-и - х (ничего не делаем с этим аргументом)
# Вывод <function <lambda> at 0x0128E928>
# Пока это ф-я, которая ничего не делает. На вход ей ничего не подается. Чтобы она приняла что-то надо записать:
print((lambda x: x)(10))
# Здесь мы берем саму ф-ю в скобки и она уже становится объектом. И в этот объект мы подаем значение 10
# Получаем то же самое - 10

# С помощью Лямбда-функции мы можем определить функцию
ident_lambda = lambda x: x
# И вызываем ее:
print(ident_lambda(10))

# В Лямбда-функцию можно передавать и более сложные конструкции
car = lambda brend, engine_volume, price: f'Car: Марка: {brend.title()}, Engine volume: {engine_volume}, Price: {price}'
# Здесь сразу после Лямбды идет список аргументов, которые передаются в тело ф-и.
# После двоеточия идет тело ф-и, которая делает форматирование строк
# Далее вызываем эту ф-ю
# Эта ф-я car() принимает на вход три переменные

print(car('volvo', 1.5, 1300000))
# Вывод: Car: Марка: Volvo, Engine volume: 1.5, Price: 1300000

# Лямбда-функция также относится к классу функция <class 'function'>,
# но между Лямбдой и обычной ф-ей есть различия.
# У Лямбда-функции на уровне байт-кода не будет своего внутреннего названия.
# Это хорошо видно в исключениях. Если мы получим исключение в ф-и Лямбда,
# то там будет написано, что исключение получено в ф-и lambda, в отличии от обычной ф-и, когда выводится ее название.

# Ф-я Лямбда может содержать только выражения и не мжет включать операторы в свое тело
# Ф-я Лямбда пишется как одна строка
# Ф-я Лямбда не поддерживает аннотацию типов
# Ф-я Лямбда может быть вызвана немедленно в отличии от ф-й, которые инициализиуются до их применения.
# Ф-я Лямбда не может содежать утверждения. Такие операторы как return, pass, accert, race
# не могут находится в коде Лямбда-функции, иначе получим ошибку.

# Лямбда-функция широко испльзуется как вспомогательная функция в ф-ях Map, Filter, Reduce
# Лямбда-функция очень широко используется при обработке данных в модуле Pandas (машинное обучение)


# ---------------------------- Применение Лямбда-функции вместе с Мар ---------------------

# Применем уже рассмотренную нам ранее более сложную ф-ю

def cube(number):
    return number ** 3  # Возводит число в третью степень


# Теперь эту ф-ю можно использовать для каких-то списков
num_list = [1, 2, 3, 4, 5, 6, 7]
# и для этой последовательности применим ф-ю Мар
print(list(map(cube, num_list)))
# Получаем список из кубов (третья степень) переданной последовательности.
# [1, 8, 27, 64, 125, 216, 343]

# Но, что если мы хотим использовать эту ф-ю всего один раз и она нам больше не нужна?
# Для этого мы можем создать анонимную ф-ю (без имени) при помощи Lambda Expressions

# def cube(number): return number ** 3  # Если мы запишем так, то это тоже корректная форма записи,
# но, по договоренности, тело ф-и переносят на следующщую строку.
# Так как мы хотим использвать эту ф-ю один раз, ей не нужно имя. Поэтому можно укоротить ее следующим образом:
# number: return number ** 3 - оставляем аргумент и тело ф-и
# Теперь просто перед названием аргумента добавляем  lambda
# lambda number: number ** 3  - также здесь не нужно слово return, так как анонимные Lambda-функции вегда сама
# возвращают какое-то значение.
# Теперь эта ф-я может проделать то же самое, что и предыдущая с именем.
# Мы ее можем испльзовать в выражениях сразу же в качестве параметра
# Вместо этого print(list(map(cube, num_list)))
# пишем это
print(list(map(lambda number: number ** 3, num_list))) # заменяем название ф-и cube на Lambda
# Получаем тот же результат
#  [1, 8, 27, 64, 125, 216, 343]
# Если вам нужна короткая ф-я, которая испльзуется один раз, испльзуйте Лямбду.

# Рассмотрим еще один простой пример с применением ф-и Мар и Лямбда
# Здесь она раскрывается во всей красе
# Не нужно писать заранее какую-то ф-ю. Емли она не большая, можно записать в одну строчку:
squares = map(lambda x: x*x, [0, 1, 2, 3, 4])
# Здесь возмодим каждый элемент списка в квадрат. При этом сразу же формируем новый массив списка squares
print(list(squares))
# [0, 1, 4, 9, 16]

# Пепепишем выражение перевода милей в км (рассмотрели ранее), но тепероь уже с помощью Лямбды

km_dist = list(map(lambda x: 1.6*x, mile_dist))
print(type(km_dist), km_dist)
# Такое выражение более удобно для понимания. Все сразу видно, что происходит с элементами массива.
# Не нужно искать ф-ю miles_to_km, все видно в одном месте.

# Лямбда с тремя списками
# Будет произведена операция поочередно с каждым из списков.
list_1 = [1, 2, 3]
list_2 = [4, 5, 6]
list_3 = list(map(lambda x, y: x*y, list_1, list_2))
print(list_3)
# [4, 10, 18]

# ---------------------------- Применение Лямбда-функции вместе с Filter ---------------------

# Точно также можно использовать Лямбда-выражения и в ф-и Filter
def is_num_odd(number):  # ф-я проверяет, является ли число нечетным
    return number % 2 == 1
# Переделаем ее в Лямбда-функцию
# def is_num_odd(number): return number % 2 == 1  # записываем в одну строку
# number: number % 2 == 1  # убираем def, название ф-и и ключевое слово return
# Помещаем это выражение в Filter


print(list(filter(lambda number: number % 2 == 1, num_list)))
# [1, 3, 5, 7] - получаем список из нечетных числе

# Точно также, если мы хотим определить четные числа, нам ненужно создавать новую ф-ю.
# Это можно сделать быстро в Лямбда-выражении, слегка изменив предыдущую запись
print(list(filter(lambda number: number % 2 == 0, num_list)))  # просто меняем 1 на 0
# [2, 4, 6]  - получаем список из четных чисел

# То есть, при помощи вот такой короткой записи Лямбда-выражения мы можем создавать анонимные функции.


# Пример использования со строками
string_list = ['hi', 'was', 'name', 'she']

# Используем его немного по другому с ф-ей Мар
print(list(map(lambda string: string[-1], string_list)))
# Ф-я помещает последнюю букву каждой строки в результирующий список
# ['i', 's', 'e', 'e']

# Можно сделать более сложную операцию
# Выстром все элементы в обратном порядке
print(list(map(lambda string: string[::-1], string_list)))
# ['ih', 'saw', 'eman', 'ehs']

# Лямбда-выраженмя в начале могут выглядеть пугающе и не совсем понятно и это нормально.
# Не каждую ф-ю можно привести к Лямбда-выражению. И не стоит этого делать. если это будет выглядеть слишком
# громоздко и сложно для вашего понимания или для программистов, которые будут читать ваш код в последствии
# Лямбда-выражении и анонимные ф-и в основном используются для простых случаев, когда нужно в каких-то местах
# испльзовать функциональность, которая больше нигде не будет использована.
# Если у вас возникают сложности с созданием Лямбда-выражений, вы можете создавать ф-и обычным способом.


# -------------------------------------- Функция Reduce ---------------------------

# В Python 2 была встроенной ф-ей, как Мар, Filter и sort, в Python 3 она перекочевала в модуль functools,
# поэтому, чтобы ей воспользоваться надо ее импортировать из этого молуля: from functools import reduce
# Функция Reduce производит какую-то операцию со всеми элементами списка.

sum_all = reduce(lambda x, y: x + y, [1, 2, 3, 4, 5])
# Здесь ф-я reduce суммирует все элементы переданного ей списка.
print(sum_all)  # 15

# Ф-я reduce испльзуется, когда нужно что-то применить ко всему списку. Найти среднее арифметическое, например.

# Найдем с помощью ф-и Reduce максимальный элемент в списке.
# Алгоритм поиска максимально элемента интуитивнго понятен:
# Берем перый элемент и сравниваем о вторым. Если второй элемент больше первого, то мы будем дальше работать со вторым.
# Если первый больше, то работаем с первым
# Берем третий элемент и сравниваем с тем, с которым сейчас работаем.
# Сравниваем его со следующим.
# Если он больше следующего, то работаем с ним, если меньше, то берем в работу следующий
# И так далее до конца списка.
# То есть, проверяем поэлементно и каждый раз выбираем больший из двух.
# Это выражение с Лямбдой будет выглядеть так:
# lambda a, b: a if a>b else b  - принимаем два аргумента а и б: оставляем а, если а больше б, иначе оставляем б.

# Создаем список с произвольными числами
list_temp = [32, 16 ,44, 85, 100, 5]

max = reduce(lambda a, b: a if a > b else b, list_temp)
# на вход примимает два аргумента: ф-я (выражение с Лямбдой) и массив (список)
print('Выводим максимальный элемент: ', max)


# ----------------------------------- Функция sorted() ----------------------------------

# Это ф-я, которая на вход принимает список и возвращает также список, для которого нужно создавать новый список.

list_temp_sort = sorted(list_temp)
print(list_temp_sort)  # [5, 16, 32, 44, 85, 100]

# Пропробуем другие виды сортировок.

# Сортировка в обратном порядке
list_temp_sort_revers = sorted(list_temp, reverse=True)
print(list_temp_sort_revers)  # [100, 85, 44, 32, 16, 5]

# Сортировка по ключам
# Отсоритруем строки.

list_names = ['Marry', 'Alex', 'Kate', 'Dmitry']

# Сначала отсортируем список в обычном виде
list_names_sorted = sorted(list_names)
print(list_names_sorted)  # ['Alex', 'Dmitry', 'Kate', 'Marry']

# Сортировка по определенной букве в слове
# Для этого надо создать специальную ф-ю и указать в ней параметр, по которому будет происходить сортировка
# Тот параметр, по которому происходит сортировка, называется Ключом.
list_names_sorted_key = sorted(list_names, key=lambda x: x[1])
# в квадартных скобках указываем индекс буквы, по которой будет происходить сортировка. В данном случае - 2-я буква.
print(list_names_sorted_key)  # ['Marry', 'Kate', 'Alex', 'Dmitry']


