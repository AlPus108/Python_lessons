# Здесь рассмотрим такие понятия, как ф-я Map, ф-я Filter и Lambda Expressions

# Lambda выражение, это быстрый способ создания анонимных ф-й в языке Python
# Анонимная ф-я, это такая ф-я, которая используется только один раз в момент ее создания.
# У нее нет имени и значит мы больше нигде не можем ее вызвать и использовать.
# Для того, чтобы больше понять контекст испльзования Lambda-выражений и анонимных ф-и,
# для начала нам надо разобрать такие понятия, как ф-я Мар и ф-я Filter. Это встроенные ф-и в языке Python.

# При наборе слова map, среда разработки выдает подсказку о том, что у нее есть два параметра:
# 1-й - function, 2-й - iter (то есть itereble - последовательность каких-то элементов)
# То есть эта ф-я Мар требует в качестве первого параметра какую-то ф-ю, которую надо создать.


# Создадим ф-ю с одним аргументом (чтобы упростить для понимания)
def sun_of_one_num(x):  # эта ф-я возвращает сумму одного аргумента, который складывается с самим собой
    return x + x


# У нас есть список чисел
num_list = [1, 2, 3, 4, 5, 6, 7]
# И мы хотим применить эту ф-ю к каждому элементу этого списка. Допустим, мы хотим складывать элемент с самим собой.
# Конечно, мы можем использовать для этого цикл for и в цикле вызывать функцию sun_of_two_num для каждого элемента.
# Но, это можно сделать быстрее, без цикла for при помощи ф-и map()

# Первым параметром передаем нашу ф-ю без скобок, а вторым параметром -  num_list (список значений)
# И сразу результат присвоим переменной
result = map(sun_of_one_num, num_list)
print(result)
# <map object at 0x01821DC0>
# Мы получаем объект типа map
# Запись такого вида говорит нам, что мы получили объект типа map: map object,
# который находится по адресу 0x01821DC0 в памяти компьютера
# Это не очень удобный для нас вариант вывода.
# Но, из этого результата мы можем получить все элементы через цикл.
for item in result:
    print(item)
# Получаем результат выполнения ф-и для каждого элемента этого списка:
# 2
# 4
# 6
# 8
# 10
# 12
# 14

# Это же можно получить и через однуэтапную конструкцию - сразу через цикл
for item in map(sun_of_one_num, num_list):
    print(item)
# Это один из способов использования ф-и map

# Но, мы также можем получать результат в форме списка. То есть, мы можем привести результат к типу List
print(list(map(sun_of_one_num, num_list)))
# Получаем эту последовательность в списке
# [2, 4, 6, 8, 10, 12, 14]


# Рассмотрим применение ф-и Мар в более сложных ф-ях.

# Создадим ф-ю, которая проверяет наличие определенного символа в строке
def is_a_in_string(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
    else:
        print("String has not 'a'")  # Нет символа в строке


# Создаем список слов
string_list = ['hi', 'was', 'name', 'she']

# Теперь при помощи ф-и Мар мы можем для каждого из элементов этого списка применить эту ф-ю.
print(list(map(is_a_in_string, string_list)))
# Получаем вывод на экран:
# String has not 'a'
# String has "a"
# String has "a"
# String has not 'a'
# [None, None, None, None]  - так как наша ф-я ничего не возвращает, мы получаем список из объектов None


# Чтобы она что-то возвращала, добавыим в нее Результат работы
def is_a_in_string_01(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
        return True
    else:
        print("String has not 'a'")  # Нет символа в строке
        return False


print(list(map(is_a_in_string_01, string_list)))
# Получаем список из значений, которые возвращает эта ф-я
# String has not 'a'
# String has "a"
# String has "a"
# String has not 'a'
# [False, True, True, False]

# Вы можете использовать ф-ю Мар для любой из ф-ий, которая может быть применена для объектов из списка,
# передаваемого в качестве параметра.

# Обратите внимание, что когда мы помещаем ф-ю в Мар map(is_a_in_string_01, ...) - здесь не происходит вызова ф-и,
# так как мы помещаем имя ф-и без скобок. Чтобы вызвать ф-ю, надо указывать ее имя со скобками.
# Ф-я Мар это позволяет, так как она сама вызывает указанную ей ф-ю.


# Функция Filter
# Эта ф-я также работает с последовательностями
# Ф-я Filter также принимает два параметра func и iter
# Но, эта ф-я работате только с ф-ями, которые возвращают True или False, то есть, которые возвращают значения bool
# На основании этого значения, она уже извлекает из последовательностей iterable элемент, который при применении ф-и
# возвращает True и помещает в новую последовательность.

def is_num_odd(number):  # ф-я проверяет, является ли число нечетным
    return number % 2 == 1  # если нечетное число поделить на 2, в остатке получим 1
#     Если число не четное - gjkexbv True, если четное - False


# Для последовательности
num_list = [1, 2, 3, 4, 5, 6, 7]

# Используем ф-ю Filter с выводм на экран
print(filter(is_num_odd, num_list))
# В выводе получим также как и в Мар
# <filter object at 0x00F29388> - объект фильтр с адресом в памяти
# Чтобы получить саму последовательность, нам нужно либо сразу поместить ее в список,
print(list(filter(is_num_odd, num_list)))
# [1, 3, 5, 7] - получаем список нечетных чисел
# либо распечатывать в цикле for

for num in filter(is_num_odd, num_list):
    print(num)
# 1
# 3
# 5
# 7


# Ранее созданная ф-я для Мар также может быть применима для Filter. Она тоже возвращает True или False
def is_a_in_string(string):
    if 'a' in string:
        print('String has "a"')  # Есть символ в строке
        return True
    else:
        print("String has not 'a'")  # Нет символа в строке
        return False


string_list = ['hi', 'was', 'name', 'she']

print(list(filter(is_a_in_string_01, string_list)))
# ['was', 'name']
# Результирующая последовательность состоит из строк, которые возвращают True


# Lambda Expressions
# Используется для создания анонимных функций
# Эта ф-я без имени, которая вызывается всего лишь один раз.

# Чтобы стало более понятно, создадим обычную ф-ю
def cube(number):
    return number ** 3  # Возводит число в третью степень


# Теперь эту ф-ю можно использовать для каки-то списков
num_list = [1, 2, 3, 4, 5, 6, 7]
# и для этой последовательности применим ф-ю Мар
print(list(map(cube, num_list)))
# Получаем список из кубов (третья степень) переданной последовательности.
# [1, 8, 27, 64, 125, 216, 343]

# Но, что если мы хотим использовать эту ф-ю всего один раз и она нам больше не нужна?
# Для этого мы можем создать анонимную ф-ю (без имени) при помощи Lambda Expressions

# def cube(number): return number ** 3  # Если мы запишем так, то это тоже корректная форма записи,
# но, по договоренности, тело ф-и переносят на следующщую строку.
# Так как мы хотим использвать эту ф-ю один раз, ей не нужно имя. Поэтому можно укоротить ее следующим образом:
# number: return number ** 3
# Теперь просто перед названием параметра добавляем  lambda
# lambda number: number ** 3  - также здесь не нужно слово return, так как анонимные Lambda-функции вегда
# возвращают какое-то значение.
# Теперь эта ф-я может проделать то же самое, что и предыдущая с именем.
# Мы ее можем испльзовать в выражении сразу же в качестве параметра
# Вместо этого print(list(map(cube, num_list)))
# пишем это
print(list(map(lambda number: number ** 3, num_list)))
# Получаем тот же результат
#  [1, 8, 27, 64, 125, 216, 343]
# Если вам нужна короткая ф-я, которая испльзуется один раз, испльзуйте Лямбду.

# Точно также можно использовать Лямбда-выражения и в ф-и Filter
def is_num_odd(number):  # ф-я проверяет, является ли число нечетным
    return number % 2 == 1
# Переделаем ее в Лямбда-функцию
# def is_num_odd(number): return number % 2 == 1  # записываем в одну строку
# number: number % 2 == 1  # убираем def, название ф-и и ключевое слово return
# Помещаем это выражение в Filter
print(list(filter(lambda number: number % 2 == 1, num_list)))
# [1, 3, 5, 7] - получаем список из нечетных числе
# Точно также, если мы хотим определить четные числа, нам ненужно создавать новую ф-ю.
# Это можно сделать быстро в Лямбда-выражении, слегка изменив предыдущую запись
print(list(filter(lambda number: number % 2 == 0, num_list)))  # просто меняем 1 на 0
# [2, 4, 6]  - получаем список из четных чисел

# То есть, при помощи вот такой короткой записи Лямбда-выражения мы можем создавать анонимные функции.

# Пример исопльзования со строками
string_list = ['hi', 'was', 'name', 'she']

# Используем его немного по другому с ф-ей Мар
print(list(map(lambda string: string[-1], string_list)))
# Ф-я помещает последнюю букву каждой строки в результирующий список
# ['i', 's', 'e', 'e']

# Можно сделать более сложную операцию
# Выстром все элементы в обратном порядке
print(list(map(lambda string: string[::-1], string_list)))
# ['ih', 'saw', 'eman', 'ehs']

# Лямбда-выраженмя в начале могут выглядеть пугающе и не совсем понятно и это нормально.
# Не каждую ф-ю можно привести к Лямбда-выражению. И не стоит этого делать. если это будет выглядеть слишком
# громоздко и сложно для вашего понимания или для программистов, которые будут читать ваш код в последствии
# Лямбда-выражении и анонимные ф-и в основном используются для простых случаев, когда нужно в каких-то местах
# испльзовать функциональность, которая больше нигде не будет использована.
# Если у вас возникают сложности с созданием Лямбда-выражений, вы можете создавать ф-и обычным способом.
