# SETS / МНОЖЕСТВА
# Это неупорядоченная коллекция уникальных элементов. То есть, в Множестве НЕ МОЖЕТ БЫТЬ ДВУХ ОДИНАКОВЫХ ЭЛЕМЕНТОВ.
# Это контейнер, который хранит НЕПОВТОРЯЮЩИЕСЯ ЭЛЕМЕНТЫ в случайном порядке.
# Сеты не используются для того, чтобы по ним итерироваться (перебирать в нем элементы), хотя это можно делать.
# Если вы пройдетесь циклом по множеству несколько раз, то каждый раз он будет выдавать элементы в разном порядке.
# Так как это неупорядоченная последовательнось элементов.
# Самое главное свойство Сета - из набора множества, где могут быть несколько одинаковых,
# мы получаем только уникальные элементы

# Сеты инициализируются при помощи ФИГУРНЫХ СКОБОК, но, в отличии от словарей, сюда помещаются
# не пары ключ-значение, а просто значение.

rainbow_colors = {'red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'}
print(rainbow_colors)  # Вывод: {'indigo', 'violet', 'green', 'red', 'orange', 'blue', 'yellow'}
print(type(rainbow_colors))  # Вывод: <class 'set'>

# Существуют два вида Сетов: set и frozenset
# Set имеет изменяемый тип даннх, то есть в него можно добавлять элементы и т.д.
# Frozenset имеет неизменяемый тип данных

# Бывают случаи, когда нам надо создать пустое множество.
empty_set = {}
print(empty_set)  # Вывод: {}
# Вроде с пустым Сетом все получилось. Но, если мы выведем его тип
print(type(empty_set))  # Вывод: <class 'dict'>  - получим класс Словарь.
# Что же делать, если нам надо создать пустое множество?
empty_set = set()  # Так создается пустой Сет.
print(type(empty_set))  # Вывод: <class 'set'>  - получили класс Сет

# Также мы можем создавать множества (Сеты) из других структур данных.

number_list = [1, 2, 1, 3, 2]  # Лист (имеет повторяющиеся элементы)
text_tuple = ('Один', 'Два', 'Один', 'Три', 'Два')  # Тапл  (имеет повторяющиеся элементы)
# Далее создадим множество на основе Листа и Тапл
set_from_list = set(number_list)
set_from_tuple = set(text_tuple)
print('Создание множества из Листа ', set_from_list)  # Вывод: {1, 2, 3}  (имеем уникальные элементы)
print('Создание множества из Тапл ', set_from_tuple)  # Вывод: {'Три', 'Два', 'Один'}  (имеем уникальные элементы)
# В выводе объекты расположены не в том же порядке, в каком были переданы в Сет,
# потому что Сет(Множество), это не упорядоченная структура.
# В нем объекты располагаются безпорядочно, но все элементы уникальны.

# ------------------ Обращение к элеменам в Множестве ------------------
# Возникает необходимость проверить наличие конкретного элемента в множестве.
set_1 = {10,11,12}  # Есть ли здесь элемент 12?
# Можно проверить с помощью следующей конструкции
print('Проверка наличия элемента в Множестве ', 12 in set_1)  # Вывод: True
# В случае отсутствия элемента, будет выдано False

# -------------------- Функции Множества ------------------------
# Стандартные. Используются те же, что и для других типов.
# Рассмотрим некоторые

# -------------------- Добавление элементов в Множество ----------------------
# С помощью ф-и add()
set_from_list.add(777)
set_from_tuple.add('Hello')

print(set_from_list)  # Вывод: {56, 1, 32, 777}
print(set_from_tuple)  # Вывод: {'Hello', 'Два', 'Один', 'Три'}

# Сеты часто используют для получения уникальных элементов из списка. Это их основное использование.
# Все элементы в Сете должны быть уникальными. Поэтому, если мы поробуем в те же множества добавить те же элемменты,
set_from_list.add(777)
set_from_tuple.add('Hello')
# Мы не получим дубликат. Потому что, происходит провера, и если Множество уже содержит такой элемент,
# то этот элемент просто не добавляется в это множество. Это можно использовать для того, чтобы отбирать
# уникальные элементы из Листа или из Тапл.
# Например, у нас есть объекты с повторяющимися элементами. Нам надо сделать так, чтобы элементы в них были уникальными
uniq_list = [2, 5, 2, 5, 4, 2, 3, 5]
uniq_tuple = ('one', 'two', 'one', 'three', 'two', 'three')
# Для этого можно использовать Множество - поместить эти объекты в Сет и тогда останутся только уникальные элементы
set_uniq_list = set(uniq_list)
set_uniq_tuple = set(uniq_tuple)
# При этом создаем новые переменные типа Сет
# Получаем уникальные элементы в мнжествах.
print(set_uniq_list)  # Вывод: {2, 3, 4, 5}
print(set_uniq_tuple)  # Вывод: {'three', 'one', 'two'}

# ------------------------- Удаление элементов из Множества -----------------------
# Метод pop()
# Удаляет случайный элемент в Множестве. По аргументу он не удаляет

# set_from_list сожержит {56, 1, 32, 777}
# Запускаем pop()
set_from_list.pop()
print(set_from_list)  # Вывод: {1, 32, 777}  - был удален первый элемент 56
# Метод pop() возвращает удаленный элемент

# Метод remove()
# Если мы хотим удалить какой-то конкретный элемент, мы должны передать его в качестве аргумента в remove()
set_from_list.remove(2)
print(set_from_list)  # Вывод: {32, 777} - удалена 1
# Метод remove() не возвращает удаленный элемент

# discard() - еще одни метод для удаления элементов
set_from_list.discard(32)
print(set_from_list)  # Вывод: {777} - удален элемент 32

# Чем отливаются remove() от discard()?
# Если мы попытаемся удалить при помощи remove() элемент, которого нет в Множестве, то будет возвращена Ошибка.
# В случае с discard() возврата ошибки не будет, просто не будет возвращено никаких действий.

# Метод clear()
# Удаляет все элементы из множества
set_from_list.clear()
print(set_from_list)  # Вывод: set()


# ----------------------------- ОПЕРАЦИИ С МНОЖЕСТВАМИ ------------------------------

# Объединение / union()
# Имеем два списка 1,2,3 и 3,4,5. При их объединении получим общий список 1,2,3,4,5

my_set_1 = {1,2,3}
my_set_2 = {3,4,5}
my_set_1 = my_set_1.union(my_set_2)  # Здесь создаем новый объект, которому присваиваем результат объединения
print('Объединяем два Сета ', my_set_1)  # Вывод: {1, 2, 3, 4, 5}

# Пересечение / intersection()
# Из двух списков 1,2,3 и 3,4,5 мы получим пересечение - 3.

# Разность / difference()
# Из первого множества вычитаем элементы, которые есть во втором множестве. Получаем множество, которое содержит
# уникальные элементы первого множества (которых не было во втором множестве)
# Из разности мнжеств 1,2,3 и 3,4,5 получаем список 1,2

my_set_1 = my_set_1.difference(my_set_2)
print('Выводим разность двух сетов ', my_set_1)  # Вывод: {1, 2}

# Симметрическая разность / symmetric_difference() (редко используется) - противоположна пересечению
# В новом списке остаются элементы, которые не повторяются в обоих множествах
# Из списков 1,2,3 и 3,4,5 создается список 1,2,4,5


# ----------------------- Итерация по множествам -------------------------

set_2 = {20,21,22,23,24,25}
for i in set_2:
    print('Итерация по Множеству ', i)  # При попытке вывести индекс элементов Множества, мы ничего не получим
# Вывод:
# Итерация по Множеству  20
# Итерация по Множеству  21
# Итерация по Множеству  22
# Итерация по Множеству  23
# Итерация по Множеству  24
# Итерация по Множеству  25
# Но, упорядоченность вывода не всегда гарантирована. Поэтому это надо учитывать, если нам важен порядок при выводе.
