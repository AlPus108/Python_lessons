# SETS / МНОЖЕСТВА
# Это неупорядоченная коллекция уникальных элементов. То есть, в Множестве НЕ МОЖЕТ БЫТЬ ДВУХ ОДИНАКОВЫХ ЭЛЕМЕНТОВ.

# Сеты инициализируются при помощи ФИГУРНЫХ СКОБОК, но, в отличии от словарей, сюда помещаются
# не пары ключ-значение, а просто значение.

rainbow_colors = {'red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'}
print(rainbow_colors)  # Вывод: {'indigo', 'violet', 'green', 'red', 'orange', 'blue', 'yellow'}
print(type(rainbow_colors))  # Вывод: <class 'set'>

# Бывают случаи, когда нам надо создать пустое множество.
empty_set = {}
print(empty_set)  # Вывод: {}
# Вроде с пустым Сетом все получилось. Но, если мы выведем его тип
print(type(empty_set))  # Вывод: <class 'dict'>  - получим класс Словарь.
# Что же делать, если нам надо создать пустое множество?
empty_set = set()  # Так создается пустой Сет.
print(type(empty_set))  # Вывод: <class 'set'>  - получили класс Сет

# Также мы можем создавать множества (Сеты) из других структур данных.

number_list = [1, 56, 32]  # Лист
text_tuple = ('sdf', 'srdhh', 'fgjg')  # Тапл
# Далее создадим множество на основе Листа и Тапл
set_from_list = set(number_list)
set_from_tuple = set(text_tuple)

print(set_from_list)  # Вывод: {56, 1, 32}
print(set_from_tuple)  # Вывод: {'fgjg', 'sdf', 'srdhh'}
# В выводе объекты расположены не в том же порядке, в каком были переданы в Сет,
# потому что Сет(Множество), это не упорядоченная структура.
# В нем объекты располагаются безпорядочно, но все элементы уникальны.

# -------------------- Добавление элементов в Множество ----------------------
# С помощью ф-и add()
set_from_list.add(777)
set_from_tuple.add('Hello')

print(set_from_list)  # Вывод: {56, 1, 32, 777}
print(set_from_tuple)  # Вывод: {'fgjg', 'Hello', 'sdf', 'srdhh'}

# Все элементы в Сете должны быть уникальными. Поэтому, если мы поробуем в те же множества добавить те же элемменты,

set_from_list.add(777)
set_from_tuple.add('Hello')
# Мы не получим дубликат. Потому что, происходит провера, и если Множество уже содержит такой элемент,
# то этот элемент просто не добавляется в это множество. Это можно использовать для того, чтобы отбирать
# уникальные элементы из Листа или из Тапл.
# Например, у нас есть объекты с повторяющимися элементами. Нам надо сделать так, чтобы элементы в них были уникальными
uniq_list = [2, 5, 2, 5, 4, 2, 3, 5]
uniq_tuple = ('one', 'two', 'one', 'three', 'two', 'three')
# Для этого можно использовать Множество - поместить эти объекты в Сет и тогда останутся только уникальные элементы
set_uniq_list = set(uniq_list)
set_uniq_tuple = set(uniq_tuple)
# При этом создаем новые переменные типа Сет
# Получаем уникальные элементы в мнжествах.
print(set_uniq_list)  # Вывод: {2, 3, 4, 5}
print(set_uniq_tuple)  # Вывод: {'three', 'one', 'two'}

# ------------------------- Удаление элементов из Множества -----------------------
# Метод pop()
# Метод pop() удаляет случайный элемент в Множестве

# set_from_list сожержит {56, 1, 32, 777}
# Запускаем pop()
set_from_list.pop()
print(set_from_list)  # Вывод: {1, 32, 777}  - был удален первый элемент 56
# Метод pop() возвращает удаленный элемент


# Метод remove()
# Если мы хотим удалить какой-то конкретный элемент, мы должны передать его в качестве аргумента в remove()
set_from_list.remove(1)
print(set_from_list)  # Вывод: {32, 777} - удалена 1
# Метод remove() не возвращает удаленный элемент

# discard() - еще одни метод для удаления элементов
set_from_list.discard(32)
print(set_from_list)  # Вывод: {777} - удален элемент 32

# Чем отливаются remove() от discard()?
# Если мы попытаемся удалить при помощи remove() элемент, которого нет в Множестве, то будет возвращена Ошибка.
# В случае с discard() возврата ошибки не будет, просто не будет возвращено никаких действий.

# Метод clear()
# Удаляет все элементы из множества
set_from_list.clear()
print(set_from_list)  # Вывод: set()