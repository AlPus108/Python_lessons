# Использование генераторов для бесконечного получения данных и использование генераторов с большим объемом данных

# 1
# Использование генераторов в каком-то бесконечном процессе.
# Допустим, у нас есть задача создать программу для работы ткацкого станка.
# Это станок, который изготавливает такань с определенными узорами.
# У нас есть армамент, состоящий из нескольких узоров. Допустим 3 узора.
# Этот арнамент повторяет эти 3 узора один за одним.
# Мы бы могли решить эту задачу при помощи обычной ф-и


def create_patterns():
    max_patterns_number = 10  # максимальное количество узоров
    patterns = ('First pattern', 'Second pattern', 'Third pattern')  # список типа Тьюпл.
    # Здесь указываем число образцов узоров. Здесь мы можем вставить строки: узор 1, узор 2 и т.д.,
    # но, здесь могут быть любые объекты, например, объекты какого-то класса, в котором будет имплементировано
    # графическое изображение узора в реальном приложении.
    # И теперь эти узоры мы должны размножить.
    # Это можно проделть с помощью цикла while
    i = 0  # счетчик
    result_list = []  # результирующий список, пустой для начала
    while len(result_list) < max_patterns_number:  # -> 1/1
        if i >= len(patterns):  # -> 2 вставляем проверку
            i = 0  # обнуляем i и переходим к первому элементу с идексом 0 -> 3
        # 1/1
        result_list.append(patterns[i])
        i += 1
    # здесь мы конечно можем получить ошибку, потому что, если в какой-то момент значение i будет больше количества
    # элементов в Тьюпле, мы получим ошибку.
    return result_list

# Проверим
print(create_patterns())
# При выводе получаем ошибку: IndexError: tuple index out of range
# Так как в какой-то момент индекс i становится равным 3, то мы выходим за пределы индексов.
# То есть, нам нужно, до того, как мы будем добавлять в список патерны, вставить проверку -> 2

# 3
# Получаем списко из 10 узоров
# ['First pattern', 'Second pattern', 'Third pattern', 'First pattern', 'Second pattern', 'Third pattern',
# 'First pattern', 'Second pattern', 'Third pattern', 'First pattern']
# То есть, мы получили весь наш арнамент, который нужен для куска ткани, состоящий из 10 узоров.
# И, вроде бы все не плохо. Но, что же произойдет, если у нас 1млн узоров?
# Дело в том, что списки занимают большое количество памяти. И это не очень хорошо.
# Ведь нам, для того, чтобы в реальной ситуации выткать какой-то узор,
# нужно обращаться только к одному элементу из этих трех.
# В реальности, нам не нужно создавать полный спискок из 10 или из миллиона этих элементов
# нам нужен один элемент в один момент времени.
# Именно этого мы можем достигнуть при помощи ф-и генератора.


def get_current_pattern():  # определяем текущий узор и нам не нужны теперь все элементы арнамента
    patterns = ('First pattern', 'Second pattern', 'Third pattern')  # список типа Тьюпл.
    i = 0
    while True:  # делаем бесконечный цикл
        if i >= len(patterns):
            i = 0
        yield patterns[i]
        i += 1


# Теперь мы можем создать переменную
current_pattern = get_current_pattern()
# Для этой переменной теперь мы можем вызвать или метод next() или ф-ю next
print(current_pattern.__next__())  # First pattern
print(current_pattern.__next__())  # Second pattern
print(current_pattern.__next__())  # Third pattern
print(current_pattern.__next__())  # First pattern
print(current_pattern.__next__())  # Second pattern

# Мы реализовали то, что нам нужно.
# Так как нам не нужно теперь в начале создавать список по количеству всех этих элементов, мы можем вообще
# не определять длину этого списка и не занимать память компьютера. Но, при этом, мы можем делать это бесконечно.

# Конечно, это не часто встречающаяся задача в программировании, но, тем не менее, вы должны знать,
# что если вам нужно получать бесконечный доступ к элементу какого-то списка, из какой-то последовательности,
# к каждому последующему элементу, это можно реализовать при помощи ф-и генератор.
# При этом вы не создаете большую нагрузку на память и процессор компьютера, потому что мы при этом не загружаем
# полностью весь список из всех элементов, которые нам нужны.




