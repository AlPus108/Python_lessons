# НАСЛЕДОВАНИЕ КЛАССОВ / Inheritance
# 1 Это одна из важнейших концепций ООП

# Допустим, у нас есть автомобиль
# Он имеет какие-то свойства и методы
class Car:
    wheels_number = 4

    def __init__(self, name, color, year, is_crushed):
        self.name = name
        self.color = color
        self.year = year
        self.is_crushed = is_crushed
        print('Car is created')

    def drive(self, city):
        print(self.name + ' is driving to ' + city)

    def change_color(self, new_color):
        self.color = new_color
        print('Color is changed to ' + new_color)


# Мы хотим создать класс "Грузовик", в котором нам бы так же пригодились методы drive и change_color
# В этом случае мы можем "унаследоваться" от класса Car, то есть - создать потомка от этого класса - Грузовик

class Truck(Car):  # Для наследования, указываем в круглых скобках класс, от которого наследуемся

    # 2
    # переопределяем свойство класса-предка, указав его в классе-наследкнике
    wheels_number = 6  # --> 3

    # в методе init нам нужно вызвать метод init класса-предка и указать в нем такие же аргументы, что и у предка.
    def __init__(self, name, color, year, is_crushed):
        Car.__init__(self, name, color, year, is_crushed)  # те же аргументы передаем и сюда
        print('Truck is created')

    # То есть, когда мы будем создавать объект класса Truck, мы будем передавать данные для аргументов в скобках,
    # и сразу же будет инициализироваться объект класса-предка, у которого также будут инициализированы эти же
    # аргументы в скобках.

    # 4 Переопределим метод класса-предка drive() для класса-наследника
    def drive(self, city):  # Это будет то же название с теми же параметрами
        print('Truck', self.name + ' is driving to ' + city)  # но адаптируем текст под Грузовик  --> 5

    # 6 Создаем метод класса Truck "Погрузить груз"
    def load_cargo(self, weight):
        print('The cargo is loaded. Weight is ' + str(weight) + ' kg')  # Вызываем метод для грузовика --> 7


# Создаем объект класса Truck
man_Truck = Truck('Man', 'white', 2015, False)

# При запуске кода, получаем оба сообщения:
# Car is created
# Truck is created
# Потому что при создании объекта класса-наследника Truck, создается и объкт класса-предка Car,
# в котором и вызывается этот метод print()
# После создания объекта класса-предка, идет код метода init самого класса-наследника,
# в котором также выполняется метод print()
# То есть, сначала создается объект класса-предка, вызываесят его init и затем выполяется код метода init наследника.
# И теперь мы имеем доступ к методам класса прадка, которые в нем хранятся, хотя мы их не определяли в классе-наследника
# В этом вся прелесть.
# Если мы наберем имя наследкики и поставим после него точку, нам будет выдан список доступных методов,
# в числе которых будут методы класса-предка, а также все его атрибуты.

man_Truck.drive('New York')
# Man is driving to New York
# Видим, что метод класса предка вполне корректно работает для оъекта класса-потомка,
# хотя мы его не определяли в классе потомка. Мы наследуем его от класса предка.

# Также мы имеем доступ к свойствам уровня Класса.
print(man_Truck.wheels_number)  # получаем 4
# Но, обычно у грузовиков больше колес. Как же нам сделать, чтобы у нашего грузовика было 6 колес?
# Для этого мы можем переопределить свойство класса-предка, указав его в классе-наследкнике с таким же названием.--> 2
# 3
# И теперь, если мы перезапустим тот же код print(man_Truck.wheels_number), мы получим при выводе 6
# То есть, наследование предоставляет возможность наследовать какие-то атрибуты и методы от класса-предка потомку,
# а также переопределять атрибуты и методы для потомка.
# Давайте переопределим метод класса-предка drive() для класса-наследника --> 4
# 5
# Теперь запускаем код и получаем на выходе: Truck Man is driving to New York
# То есть, если метод переопределен в классе, то вызывается уже метод потомка, а не метод предка.
# Если же он не переопределен, то вызывается метод предка.
# К примеру, вызовим для грузовика непереопределенный метод change_color()
# Но, перед этим проверим его текущий цвет
print(man_Truck.color)  # white
# Меняем цвет
man_Truck.change_color('red')  # Color is changed to red
# Выводим новый цвет
print(man_Truck.color)  # white  # red
# То есть, мы можем пользоватся методами предка не переопределяя их.

# Также, мы можем создавать в классе-наследнике свои собственные методы, которых не в классе предка.
# Давайте создадим такой метод --> 6

# 7
# Вызываем метод для грузовика
man_Truck.load_cargo(2000)


# The cargo is loaded. Weight is 2000 kg

# Идея в том, что когда вы создаете наследника какого-то класса, вы можете пользоваться всеми атрибутами и методами
# класса-предка в классе-наследнике в старом виде или можете их переопределять.
# То есть, для атрибутов можете присваивать новые значения, а методы могут принимать другую функциональность.
# Также, можете создавать свои методы, которых нет в классе-предке.
# В этом заключается суть концепции наследования в ООП


# 8
# ПОЛИМОРФИЗМ / Polymorphism
# ПОЛИ - много, МОРФО - форма
# Мы уже использовали это свойство, когда переопределяли метод drive() для Truck
# Мы изменили vtnjl drive, который есть в классе-предке. В классе-наследнике этот метод выводит дополнительно
# слово Truck.
# То есть, когда методы с одинаковыми названиями и одинаковыми параметрами ведут себя по разному. Это иесть полиморфизм.

# Для пояснения это концепции создадим три простых класса -- > 9

# 10
# Создаем общий класс для наших классов животных
class Animal:
    # и мы можем поместить в этот класс такие же методы, как у всех классов-неследников
    # имя животное иметь может
    def __init__(self, name):
        self.name = name

    # но как животное может говорить? Животное, это абстракция, а не конкретный объект.
    # Собака лаит, мышь пищит, а Животное, это обобщающий астрактный класс.
    # В таких абстрактных классах нет конкретой реализации методов.
    def speak(self):
        # Чтобы не создавать такую реализаци метода для Animal, здесь мы будем выбрасывать ошибку.
        # Это делается с помощью ключевоо слова raise
        raise NotImplementedError('Class successor must implement this metod')  # ошибка не имплементирована
    # То есть, эта ошибка предупреждает о том, что мы не имплементировали (не прописали) метод в классе-потомке.
    # И далее во все ниже созданные классы мы в скобках вставляем Animal, что означает, что оин
    # наследуются от этого класса
    # Когда мы запустим код, --> 11


# 9
# Создаем простые классы
class Dog(Animal):
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' is saying woof!')


class Cat(Animal):
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' is saying meow!')


class Mouse(Animal):
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' is saying pee-pee-pee!')

class Fish(Animal):
    def __init__(self, name):
        self.name = name
    # Так как рыба не умеет говорить, что и метод speak для него закомментирован
    # def speak(self):
    #     print(self.name + ' is saying pee-pee-pee!')

# 12
# Поэтому мы для рыбы раскомментируем этот метод и изменим надпись
    def speak(self):
        print(self.name + ' is saying nothing')
# Запускаем код и ошибка больше не выбрасывается. --> 13 (в конце)


# Создаем объекты этих классов

spike = Dog('Spike')  # собака с именем Спайк
tom = Cat('Tom')  # кот с именем Том
jerry = Mouse('Jerry')
freddy = Fish('freddy')

# Дальше создаем список домашних животных и включаем туда наших питомцев

pet_list = [spike, tom, jerry, freddy]

# В цикле мы можем обращаться к переменной pet
for pet in pet_list:
    pet.speak()  # и будем вызывать для этой переменной метод speak()
    # Вывод:
    # Spike is saying woof!
    # Tom is saying meow!
    # Jerry is saying pee-pee-pee!
    # Вызываются три разных метода, хотя используется одна переменная pet
    # Когда в цикле туда попадает объект spike - он лает, а когда tom - он мяукает.
    # Мы можем создавать сколько угодно различных классов. И, если они реализуют один и тот же метод,
    # то, если мы помещаем в одну и ту же переменную различные объекты, вызывается метод именно этого класса.


# Также, мы можем создать какую-то ф-ю, в которую мы будем передавать какое-то животное.

def pet_voice(pet):  # Метод принимает на вход какое-то животное
    pet.speak()  # и для этого животного вызывает метод speak


pet_voice(spike)
pet_voice(tom)
pet_voice(jerry)
pet_voice(freddy)  # рыба не умеет говорить, поэтому в ее объект не имплементирован этот метод.
# Spike is saying woof!
# Tom is saying meow!
# Jerry is saying pee-pee-pee! ---> 8/1

# 11
# то эта ошибка выскочет для freddy - fish, так как в нем не прописан этот метод
# NotImplementedError: Class successor must implement this metod
# Рыба не умеет гооврить.
# Получив такое сообщение об ошибке, разработчик понимает, что если он хочет унаследоваться от этого
# абстрактного класса Animal, то он должен обязательно инплементировать метод speak в данный класс-потомок. --> 12

# 8/1
# Но, для того, чтобы использовать полиморфизм, мы должны быть уверены точно, что в этом классе есть этот метод.
# Иначе мы получим ошибку.
# Поэтому обычно классы, которые имеют один и тот же метод и которые можно сформировать в одну группу,
# они наследуются от какого-то класса-предка.
# Например, у всех этих наших классво, может быть общий класс animal --> 9

# 13
# Полсе имплементации метода speak в класс fish, получаем вывод метода: freddy is saying nothing
# Ошибки нет.

# В реальных приложениях часто можно встретить полиморфизм. Например, мы можем встреить такую ситуацию,
# что нам нужно создать класс для открытия файла. Мы можем создать какой-то абстрактный класс с методом open_file()
# и создать затем подклассы этого класса, в которые мы будем имплементировать этот метод open_file()
# для каждого конкретного вида файла: pdf, txt, аудио, видео.
# То есть, для каждого файла нужна будет какая-то своя реализация этого метода, чтобы открыть этот файл.

