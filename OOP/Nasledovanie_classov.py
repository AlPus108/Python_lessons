# НАСЛЕДОВАНИЕ КЛАССОВ / Inheritance
# 1 Это одна из важнейших концепций ООП

# Допустим, у нас есть автомобиль
# Он имеет какие-то свойства и методы
class Car:
    wheels_number = 4

    def __init__(self, name, color, year, is_crushed):
        self.name = name
        self.color = color
        self.year = year
        self.is_crushed = is_crushed
        print('Car is created')

    def drive(self, city):
        print(self.name + ' is driving to ' + city)

    def change_color(self, new_color):
        self.color = new_color
        print('Color is changed to ' + new_color)


# Мы хотим создать класс "Грузовик", в котором нам бы так же пригодились методы drive и change_color
# В этом случае мы можем "унаследоваться" от класса Car, то есть - создать потомка от этого класса - Грузовик

class Truck(Car):  # Для наследования, указываем в круглых скобках класс, от которого наследуемся

    # 2
    # переопределяем свойство класса-предка, указав его в классе-наследкнике
    wheels_number = 6  # --> 3

    # в методе init нам нужно вызвать метод init класса-предка и указать в нем такие же аргументы, что и у предка.
    def __init__(self, name, color, year, is_crushed):
        Car.__init__(self, name, color, year, is_crushed)  # те же аргументы передаем и сюда
        print('Truck is created')

    # То есть, когда мы будем создавать объект класса Truck, мы будем передавать данные для аргументов в скобках,
    # и сразу же будет инициализироваться объект класса-предка, у которого также будут инициализированы эти же
    # аргументы в скобках.

    # 4 Переопределим метод класса-предка drive() для класса-наследника
    def drive(self, city):  # Это будет то же название с теми же параметрами
        print('Truck', self.name + ' is driving to ' + city)  # но адаптируем текст под Грузовик  --> 5

    # 6 Создаем метод класса Truck "Погрузить груз"
    def load_cargo(self, weight):
        print('The cargo is loaded. Weight is ' + str(weight) + ' kg')  # Вызываем метод для грузовика --> 7


# Создаем объект класса Truck
man_Truck = Truck('Man', 'white', 2015, False)

# При запуске кода, получаем оба сообщения:
# Car is created
# Truck is created
# Потому что при создании объекта класса-наследника Truck, создается и объкт класса-предка Car,
# в котором и вызывается этот метод print()
# После создания объекта класса-предка, идет код метода init самого класса-наследника,
# в котором также выполняется метод print()
# То есть, сначала создается объект класса-предка, вызываесят его init и затем выполяется код метода init наследника.
# И теперь мы имеем доступ к методам класса прадка, которые в нем хранятся, хотя мы их не определяли в классе-наследника
# В этом вся прелесть.
# Если мы наберем имя наследкики и поставим после него точку, нам будет выдан список доступных методов,
# в числе которых будут методы класса-предка, а также все его атрибуты.

man_Truck.drive('New York')
# Man is driving to New York
# Видим, что метод класса предка вполне корректно работает для оъекта класса-потомка,
# хотя мы его не определяли в классе потомка. Мы наследуем его от класса предка.

# Также мы имеем доступ к свойствам уровня Класса.
print(man_Truck.wheels_number)  # получаем 4
# Но, обычно у грузовиков больше колес. Как же нам сделать, чтобы у нашего грузовика было 6 колес?
# Для этого мы можем переопределить свойство класса-предка, указав его в классе-наследкнике с таким же названием.--> 2
# 3
# И теперь, если мы перезапустим тот же код print(man_Truck.wheels_number), мы получим при выводе 6
# То есть, наследование предоставляет возможность наследовать какие-то атрибуты и методы от класса-предка потомку,
# а также переопределять атрибуты и методы для потомка.
# Давайте переопределим метод класса-предка drive() для класса-наследника --> 4
# 5
# Теперь запускаем код и получаем на выходе: Truck Man is driving to New York
# То есть, если метод переопределен в классе, то вызывается уже метод потомка, а не метод предка.
# Если же он не переопределен, то вызывается метод предка.
# К примеру, вызовим для грузовика непереопределенный метод change_color()
# Но, перед этим проверим его текущий цвет
print(man_Truck.color)  # white
# Меняем цвет
man_Truck.change_color('red')  # Color is changed to red
# Выводим новый цвет
print(man_Truck.color)  # white  # red
# То есть, мы можем пользоватся методами предка не переопределяя их.

# Также, мы можем создавать в классе-наследнике свои собственные методы, которых не в классе предка.
# Давайте создадим такой метод --> 6

# 7
# Вызываем метод для грузовика
man_Truck.load_cargo(2000)
# The cargo is loaded. Weight is 2000 kg

# Идея в том, что когда вы создаете наследника какого-то класса, вы можете пользоваться всеми атрибутами и методами
# класса-предка в классе-наследнике в старом виде или можете их переопределять.
# То есть, для атрибутов можете присваивать новые значения, а методы могут принимать другую функциональность.
# Также, можете создавать свои методы, которых нет в классе-предке.
# В этом заключается суть концепции наследования в ООП


# ПОЛИМОРФИЗМ / Polymorphism