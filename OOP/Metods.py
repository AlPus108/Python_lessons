class Car:
    wheels_number = 4

    def __init__(self, name, color, year, is_crushed):
        self.name = name
        self.color = color
        self.year = year
        self.is_crushed = is_crushed

    # ------------------------------- МЕТОДЫ ----------------------------------------
    # Методы, это функции, которые описываются или определяются в нутри класса.
    # Методы выполняют какие-то действия.
    # Очень часто они выполняют действия над какими-то атрибутами самго объекта/класса

    # Здесь рассмотрим методы уровня объектов.

    # Метод также, как и ф-я создается при помощи ключевого словая def

    # def drive(self):  # метод описывает способность автомобиля к движению. Ключевое слово self также используется
    #     # в методах, так как оно нужно для соединения метода с объектами класса
    #     print('Car is driving')  # - тело метода "Машина едет"

    # При обращении к атрибуту, мы можем извлечь из него значение и что-то с ним сделать
    # При выводе информации об объекте, надо использовать кл.слово self

    def drive(self, city):
        print(self.name + ' is driving to' + city)  # строку конкотерируем со значениями
        # при помощи атрибута self мы обращаемся к значению атрибута name конкретного объекта
        # Параметр city мы будем получать от пользователя при вызове метода.
        # Мы не будем получать его из объекта класса, из его внутренних атрибутов.

    # То есть, вызывая метод для конкретного объекта, мы работаем со значениями атрибута конкретного объекта.
    # Этим объекты очень удобны. То есть, они похожи наобъекты реального мира.
    # В мире у каждого объекта есть свои свойства, которыми мы можем манипулировать.
    # Точно также и в программировании - у каждого объекта есть свойства и методы, при помощи которых мы можем
    # воздействовать на эти свойства. И не обязателно на свойства объекта, мы можем произвоидть действия любого рода.
    # В данном случае, в методе drive() мы использовали атрибут name этого объекта.
    # Для каждого объекта мы получили разный результат.

    # Итак, сейчас у нас есть метод drive(), который не имеет никаких параметров, мы не передаем ему при вызове параметры.
    # В нем есть лишь парамер self, который указывает лишь на объект данного класса.
    # Но, мы можем при создании метода указывать еще какие-то параметры.
    # Например, давайте создадим пункт назначения, в который едет автомобиль. Добавим атрибут city
    # def drive(self, city):
    # теперь, при обращении к методу drive, необходимо будет давать ему данные по этому позиционному аргументу.
    # Иначе, получим ошибку.

    # Также, при помощи методов мы можем менять значения атрибутов для объектов
    # Создадим метод, который будет менять цвет автомобиля

    def change_color(self, new_color):  # помимо параметра self добавим ему параметр new_color
        # далее мы будем менять атрибут color вновь созданного объекта
        # чтобы обратиться к атрибуту объкта, мы делаем это через self.
        self.color = new_color


# Создаем новый объект класса Car


opel_car = Car('Opel Tigra', 'gray', 1999, True)  # Создали автомобиль
# в скобках объекта вводим четрые обязательных параметра, определенных в методе init() класса.
# Их можно записывать просто как значения, как аргументы без названия атрибута и знака равенства.

# Теперь, opel_car. после точки появится ниспадающий список, где, помимо атрибутов уровня класса и уровня этого объекта,
# которые доступны для этого объекта, появился метод drive(), который можно вызвать для объекта этого класса
# opel_car.drive()  # вызываем метод drive() для объекта opel_car

# Также мы можем обращаться к атрибутам этого автомобиля.
# Выводим на печать
print(opel_car.name)
print(opel_car.color)
print(opel_car.year)
print(opel_car.is_crushed)
print(opel_car.wheels_number)

# Ключевое отличие, как мы обращаемся к методу и к атрибуту объекта состоит в том,
# что после метода, как при вызове ф-и, мы указываем круглые скобки при обращении к атрибуту, этих скобок в конце нет.
# Это потому, что метод, это ф-ия и он выполняет какие-то действия.
# Атрибут не выполняет никаких действий и его можно разценивать как переменную объекта, которая содержит какое-то значение.

# Если мы выведем на печать метод drive (без скобок)
print(opel_car.drive)
# <bound method Car.drive of <__main__.Car object at 0x0186E718>>
# Получаем сообщение, что метод drive класса Car связан с объектом opel_car и находится в памяти по адресу...
# То есть, если мы хотим, чтобы запустился метод, надо обязательно указывать вместе с ним круглые скобки.

opel_car.drive(' London')  # передаем информацию о городе для параметра city. Он обязателен, та как зашит в метод.
# Opel Tigra is driving to London

# Создаем новый объект
mazda_car = Car('Mazda CX7', 'black', 2018, False)
# Выведем связанный с ним метод drive()
mazda_car.drive(' Paris')  # Mazda CX7 is driving to Paris

# Изменим для Мазды цвет используя метод new_color
mazda_car.change_color('Yellow')
# Проверяем, поменялся ли цвет у Мазды
print(mazda_car.color)  # Yellow


# Сейчас при помощи метода мы смогли изменить свойство объекта. Точно также мы можем менять любые другие свойства.


# Создаем новый класс

class Circle:
    # Создадим атрибут уровня класса для вычисления каких-то величин круга. Часто для этого испльзуется цифра Пи
    # Поэтому это свойство будет использовано во всех объектах класса Circle. Поэтому вынесем его на уровень класса
    pi = 3.14

    # Создаем главный метод класса
    def __init__(self, radius=1):  # добавляем параметр radius со значением по умолчанию - основной параметр круга
        # Если мы не указем явно какое-то значение, то подставится дефолтное значение 1
        self.radius = radius  # инициализируем атрибут radius

    # Также, мы можем инициализировать какой-то атрибут путем вычисления некоего выражения.
    # То есть, не создавать следующий объект, а прописать его вычисление при инициализации
    # self.circumference = 2 * Circle.pi * self.radius - здесь к Пи обращаемся через указание имени класса,
    # а не через self, так как это атрибут уровня класса.

    # Далее создадим метод, который будет возвращать значение площади круга
    # Площадь круга = числу Пи * на квадрат радиуса

    def get_area(self):
        return self.pi * (self.radius ** 2)
        # значение, которое возвращает этот метод, мы будем использовать  либо в переменной,
        # либо для для других действий.

    # Методов в классе может быть сколько вам угодно.
    # Создадим метод для вычисления длины окружности. Формула длины окружности: 2*pi*radius

    def circumference(self):
        return 2 * self.pi * self.radius


# Далее создаем объект
circle_1 = Circle()  # здесь можем ничего не передавать, потому что у нас есть там значение по умолчанию
# Вызываем метод и выводим его на печать
print(circle_1.get_area())  # 3.14 - площадь круга при радиусе 1
# print(circle_1.circumference) - в случае инициализации circumference в главном методе init,
# обращаемся к нему уже как к атрибуту, без скобок, потому что атрибут уже создан и вычислен.
print(circle_1.circumference())  # 6.28 - длина окружности при радиусе 1

circle_2 = Circle(3)  # теперь передаем значение радиуса нашего круга
# Вызываем метод и выводим его на печать
print(circle_2.get_area())  # 28.26 - площадь круга при радиусе 3
print(circle_2.circumference())  # 18.84 - длина окружности при радиусе 1

# Мы можем присвоить это значение площади какой-то переменной

circle_3 = Circle(5)  # радиус круга - 5
# Вызываем метод и выводим его на печать
circle_area = circle_3.get_area()
# и выводим эту переменную
print(circle_area)  # 78.5  - площадь круга при радиусе 5
print(circle_3.circumference())  # 31.40 - длина окружности при радиусе 5
