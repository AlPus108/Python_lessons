# Method Resolution Order (MRO)

# Порядок разрешения методов
# Здесь прописано, в каком порядке будут вызываться методы, какая у них иерархия.
# Какой метод главнее и их приоритеты.

#   A
#  / \
#  B C
#  \ /
#   D

# На диаграмме изображено:
# У нас есть класс А, от которого унаследовано два класса В, С
# Класс D унаследован от двух классов одновременно, от В и С
# Такая усложненная иерархическая структура наследования.

# Пропишем это в коде


class A:
    def some_metod(self):
        print('Метод класса А')


class B(A):  # унаследован от класса А
    def some_metod(self):
        print('Метод класса B')


class C(A):  # унаследован от класса А
    def some_metod(self):
        print('Метод класса C')


class D(B, C):  # унаследован от классов В и С
    pass
    # def some_metod(self):
    #     print('Метод класса D')


# Создаем кокой-то объект

some_object = D()
some_object.some_metod()
# В этом слуачае будет вызван метод класса D, так как он присутствует в этом классе.
# Запускаем код и проверяем.
# Вывод:  Метод класса D

# Но, если мы закомментируем этот метод в классе D, какой метод будет вызван?
# Чтобы не гадать, можно узнать это тремя способами.

# 1 - атрибут __mro__ - он есть у каждого класса
# 2 - метод mro()
# 3 - либо вызвать ф-ю help() для этого класса, в которой указан порядок разрешения методов

# 1 способ
# указываем класс и через точку атрибут __mro__
print(D.__mro__)
# (<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>)
# Получаем вот такую последовательность.
# То есть, если есть одноименные методы в этих классах, то сначал будет вызван класс D.
# Если в классе D нет этого метода, то будет вызван класс В и т.д. - С - А.
# Если ни в одном из классов этой иерархии нет такого метода, то будет вызван метод из общего класса object.
# Но, даже если в этом общем классе не будет данного метода, тогда выпадет предупреждение об ошибке.

# 2 способ
# С помощью метода mro()
print(D.mro())
#  [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
# Получаем то же самое, что и при перво методе.

# 3 способ
# при помощи ф-и help()
help(D)  # в скобках указываем название класса


# class D(B, C)
#  |  Method resolution order:
#  |      D
#  |      B
#  |      C
#  |      A
#  |      builtins.object
#  |
#  |  Methods inherited from B:
#  |
#  |  some_metod(self)
#  |
#  |  ----------------------------------------------------------------------
#  |  Data descriptors inherited from A:
#  |
#  |  __dict__
#  |      dictionary for instance variables (if defined)
#  |
#  |  __weakref__
#  |      list of weak references to the object (if defined)

# Тот же самый порядок.
# Вот таким обраом тремя способами можно определить иерархический порядок вызова одинаковых методов
# при множественном наследовании в языке Пайтон

# Методы уровня класса также можно называть Статическими методами, потому что в отличии от методов уровня объекта,
# они могут быть использованы без создания объекта. То есть объект не создается, чтобы использовать этот метод.
# Если при создании метода, в его скобках мы не используем никакой атрибут, кроме кл.слова self, то есть
# не затачиваем его под какой-то индивидуальный объект, то тогда этот метод можно сделать методом класса
# Для этого просто ставим декоратор @classmethod и в скобках метоад указваем cls

class E(D):  # унаследован от класса D
    @classmethod
    def some_metod(cls):
        print('Метод класса E')

# Еще раз. Если в методе не используются какие-то конкретные атрибуты объектов, принадлежащих к этому классу,
# а используется какой-то общий код для всего класса, как в этом случае - распечатывается просто текст,
# в этом случае данный метод можно сделать методом уровня класса.
