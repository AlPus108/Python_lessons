# Ввод и вывод в языке Пайтон

# input() - ввод
# В инпуте в круглых скобках ф-и можно вводить сообщения и подсказки для пользователя.
x = input('Введите что-нибудь ')  # и использовать то, что ввел пользователь, в нашем коде (присвоить переменной).

# output() - вывод
# Также мы можем выводить что-то
print('Распечатай что-нибудь ' + x)  # будет выведено на экран то, что ввел пользователь

# Существует также возможность ввода информации в нашу программу не только с клавиатуры пользователем,
# но, например, из файла.
# Также, аналогично, мы можем выводить информацию не только в терминальное окно, но и в файл
# и сохранять на жестком диске компьютера

# Чтобы получить информацию из файла, нужно сначала его открыть.


# Последний ваш - закрытие файла - очень важен. Особенно, когда мы будем не читать из файла, а записывать что-то в него.
# Если мы не закроем файл после произведения с ним каких-то манипуляций, он может быть поврежден.
# Файл может располагаться в любой папке.

# Открываем файл при помощи команды open() с указанием пути к файлу в круглых скобках и в кавычках.
text = open('C:/Users/Lenovo 330s/Documents/UII/text.txt')
# Для вывода текста на печать, испльзуем цикл
for line in text:   # выводим построчно
    print(line, end='')
text.close()  # обязательно закрываем файл.

# При выводе, между строками образуются пустые строки, хотя в исходном файле пустых строк нет.
# Дело в том, что ф-я print() добавляет пустую строку автоматически. Это делает необязательный параметр этой ф-и end,
# который по умолчанию имеет значение end='\n' - код перехода на новую строку. Мы можем указать его явно и будет
# то же самое.
# Но, если указать пусту строку end='', то все строки по идее будут выведены в одну линию.
# Но, на деле, и чезнет пустая строка между строкам. Но, текс будет выведен построчкно.
# Потому что переносы уже стоят в изначальом тексте.
# То есть, выражением end='\n' мы отменяем значение по умолчанию

# В команде open() есть режимы чтения 'r' (установлен по умолчанию) и режим записи

# При переборе строки в цикле, мы можем делать с ней все, что нам надо.
# Например, мы можем выбирать какие-то слова по каким-то признакам
# Мы можем распечатать все строки, если в них сожержится слово 'let', например

text = open('C:/Users/Lenovo 330s/Documents/UII/text.txt')  # открываем файл
for line in text:   # выводим построчно
    if 'let' in line.lower():  # если в строке есть слово 'let' (приводим все буквы в нижний регистр)
     print(line, end='')  # выводим эту строку на экран
text.close()  # обязательно закрываем файл, особенно после того, как мы открыли его в режиме записи.

# В Пайтоне версии 2.6 появилась возможность открвать файл при помощи оператора with
# Этот оператор применяется ко всем объектам, которые поддерживают этот оператор.

with open('C:/Users/Lenovo 330s/Documents/UII/text.txt') as text:
    # То есть, мы открваем файл по указанному пути, и дальше мы обращаеся к нему, как text (через эту переменную)
    # И дальше мы можем делать все, то же самое,
    for line in text:
        if 'let' in line.lower():
            print(line, end='')
    # но теперь нам не нужно закрывать файл. Оператор with автоматически закрывает файл после работы с ним.


# ---------------------------- Методы readline() readlines()----------------------------
# Методы readline() считывает одну строку
with open('C:/Users/Lenovo 330s/Documents/UII/text.txt') as text:
    line = text.readline()  # считываем одну строку
    # и дальше распечатываем строку
    print('\nПолучаем первую строку ', line)  # получаем первую строку

# Также мы можем построчно читать и распетывать с помощью цикла while
with open('C:/Users/Lenovo 330s/Documents/UII/text.txt') as text:
    line = text.readline()  # используем метод readline
    while line:  # если меременная line не пустая, запускается цикл для вывода текста
        print(line, end='')  # вывод без пустых строк между строками
        line = text.readline()
    # при таком выражении, распечатываются все строки текста.


# Доступ к строкам в формате list
# Для этого используется метод readlines()  - читает много строк
with open('C:/Users/Lenovo 330s/Documents/UII/text.txt') as text:
    lines = text.readlines()  # используем метод readlines
    # Здесь нам цикл уже не нужен. Весь текст, который находится в файле, будет прочитан и сохранен в списке.
    # Каждая строка будет элементом этого списка.
print(lines)
# Whisper words of wisdom, let it be['When I find myself in times of trouble, Mother Mary comes to me\n',
# 'Speaking words of wisdom, let it be\n', ......

# Получаем весь текст в виде одной длинной строки. В конце каждой строки установлен знак перехода нановуж строку \n',
# который не виден явно в файле. Но, он присутствует, так как каждая строчк в тексте начинается с новой строки.
# И далее мы можем работать с этим списком, как и со всеми остальными списками.
# Например, в цикле:
for line in lines:
    print(line)
    # Вы воде получаем то же самое.
# И, так как мы получаем при помощи метсда readlines() список из строчек текстового файла, то мы можем применять здесь
# какие-то манипуляции со списками. Например, мы можем распечатать список в обратном порядке, указав такой код
for line in lines[::-1]:
    print(line)
# Теперь, на выходе мы получили последние строки первыми. То есть, мы переставили строки в обратном порядке.
# Итак, метод readlines() читает содержимое файла и помещает в список строки этого файла как элементы этого списка.

# Метод readline() читает одну строку.
# Метод read() читает весь файл, и, в случае текстового файла, весь этот файл помещается в одну строку.
with open('C:/Users/Lenovo 330s/Documents/UII/text.txt') as text:
    text = text.read()  #
print(text)
# В этом случае мы получаем весь текст и нам не нужно ничего перебирать. Мы можем его распечатать как обычную строку.

# Методы read() и readlines() в случае больших файлов, когда используется большое количество информации,
# лучше не использовать. В случае больших файлов, лучше использовать readfile() - чтение построчно,
# чтобы не перегружать память компьютера.


