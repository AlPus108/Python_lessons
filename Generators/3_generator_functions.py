# ГЕНЕРАТОРЫ
# Генераторы, это итераторы. При помощи генераторов мы можем перебирать какой-то iyerable
# Не каждый итератор является генератором.
# Но, все генераторы являются итераторами.
# Генераторы могут быть созданы при помощи ф-и generator
# Так же, генераторы могут быть созданы при помощи generator expressions (генераторы выражений)

# Ничего общего с генераторами последовательностей здесь нет.
# Генераторы, это отдельная сущность.

# Необходимость использования генераторов возникает всегда, когда вы осуществляете перебор большого число объектов.
# В этой ситуации (при большом числе объектов) возникает необходимость хранить большое количество информации в памяти,
# что конечно же неудобно, будь то приложение на сервере, будь то статическое приложение на локальном компьютере.
# Забивается кэш и это сказывается на быстродействии процессов. Иногда бывают и такие объекты, которые просто
# не помещаются в память. На помощь в данной ситуации приходят генераторы.
# Например, нам необходимо хранить миллион записей и среди этого миллиона найти что-то.
# Это можно сделать по разному. Мы можем загрузить все эти записи в память, затем бегать по кэшу и искать
# нужные нам значения. Но, это в случае, если позволяет память.
# Но, чаще, для такой процедуры испльзуют генераторы. Это метод просмотра большого объема информации без использования
# памяти компьютера. Генератор каждый раз вынимает один элемент из того множества, в котором осуществляется перебор.

# Здесь разберем, как создавать генераторы при помощи ф-й генераторов
# Мы уже разбирали ф-и, которые могут возвращать какое-то значание.


def my_function(x):
    return x


my_function(4)  # 4 - получаем значение, возвращаемое этой ф-ей


# ф-и генераторы тоже возвращают значения, но они могут возвращать значения из последовательности несколько раз.
# И возвращают они это значение не при помощи ключевого слова return, а при помощи слова yield (йилд)
# Слово yield в английском языке имеет много значений: уступать, выработать. То есть - вырабатываются какие-то значения.
# И вырабатываться они могут несколько раз.
# В случае с обычной ф-ий мы получаем возвращаемое значение. В случае с функцией-генераторм, мы возвращаем генератор.
# Генератор, в свою очередь, является итератором.
# Это немного запутано, поэтому, лучше разобрать на практике.
# Создадим нашу первую функцию-генератор


# Пример генератора

def coundown(num):
    print('String')
    while num > 0:
        yield num
        num -= 1


# Здесь ключевое слово yield - это операция вычисления следующего значения генератора.
# В одни момент времени оно вычсисляет одно значение и передает его.


def count_up_to(x):  # 'считать до..'
    count = 1  # создаем переменную с начальным значением
    while count <= x:
        yield count
        count += 1


# Запускаем ф-ю
print(count_up_to(3))
# <generator object count_up_to at 0x02E9EAE0>
# Мы получаем generator object - объект класса generator
# Эта ф-я произвела генератор.
# Когда мы используем в ф-и ключевое слово yield, автоматически мы получаем из этой ф-и генератор.
# С этим генератором мы можем поместить значение, которое вырабатывает эта ф-я, в переменную.
counter = count_up_to(3)
# Nак как это генератор, который в свою очередь является итератором, у него есть метод next()
# И этот метод мы можем назначить переменной.
# print(counter.__next__())  # 1
# # если повторим
# print(counter.__next__())  # 2
# print(counter.__next__())  # 3
# print(counter.__next__())  # StopIteration
# На последенм шаге получаем ошибку StopIteration

# То же самое, по-мимо метода next(), мы можем проделать при помощи ф-и next.
print(next(counter))  # 1
print(next(counter))  # 2
print(next(counter))  # 3

# Что же тут происходит?
# def count_up_to(x):  # 'считать до..'
#     count = 1        # создаем переменную с начальным значением
#     while count <= x:
#         yield count
#         count += 1

# Эта фунция-генератор count_up_to, которая генерирует сам генератор,
# который мы потом помещаем в counter = count_up_to(3), он запускается.
# После слова yield вырабатывается текущее значение, которое помещено в count.
# После этого ф-я как-бы становится на паузу, засыпает.
# После этого значение возвращается из этой ф-и, count прибавляется 1, count += 1. Ф-я остановлена.
# И, при последующем запуске в count уже находится не 1, а 2. То есть, запоминается предыдущее значение.
# Оно не обнуляется, как в случае с обычной ф-ей. И, каждый раз, мы получаем новое значение до тех пор,
# пока не будет получена ошибка StopIteration
# То есть, при помощи ф-и генератора, мы можем легко получать пследовательность iterable и использовать ее в цикле.

for number in count_up_to(10):  # вызываем ее в цикле
    print(number)
    # получаем вывод от 1 до 10

# То есть, нам не нужно имплементировать для этого, как мы делали в кастомном классе MyRange (пакет 2_custom_iterable)
# методы next и iter.
# Здесь при помощи вот такой ф-и генератора мы можем создавать такую же функциональность.
# Фишка в том, что при помощи ф-и генератора, когда мы вырабатываем значение с помощью ключевого слова yield,
# мы не обнуляем все наши действия. И, в следующий раз, при вызове метода next, будет использовано значение не с начала,
# а с того значения, на котором была остановка.

# В цикле for остановка происходит также на выбросе ошибки StopIteration, но там эта ошибка обрабатывается
# при помощи конструкции try - except, поэтому мы ее не замечаем
# и программа не останавливается и выполянет следующий код.

# Резюме по созданной нами ф-и count_up_to()
# Здесь мы также можем работать не только с числами, но и с любыми последовательностями и производить любые манипуляции.
# Эта ф-я, логика которой может быть какой угодно до ключевого слова yield, которое вырабатываем какое-то значение,
# которое будет помещено в переменную. Затем ф-я останавливается/засыпает и сохраняет свое состояние -
# запоминает, где она остановилась. И, при следующем вызове, будет продолжена работа с запомненного значения.
# То есть, будет выработан следующий элемент последовательности. Каждый раз вырабатывается только один элемент из
# последовательности. Мы, конечно, можем сгенерировать все элементы последовательности при помощи list

print(list(count_up_to(7)))  # [1, 2, 3, 4, 5, 6, 7]
# получим последовательность в форме списка


# Важно почувствать разницу между генераторами списков и просто генераторами.

# ---------------------------- Генератор списков -----------------------------------

n = 100

simple_list = [x ** 3 for x in range(n)]  # вычисляем кубическое значение для каждого элемента последовательности
print(simple_list)  # [0, 1, 8, 27, 64]
print(type(simple_list))  # <class 'list'>

# Выведем элементы данного списка построчно
for i in simple_list:
    print(i)
    # 0
    # 1
    # 8
    # 27
    # 64

# -------------------------------- Неявный генератор ----------------------------

# Неявные генераторы создаются с помощью круглых скобок


simple_generator = (x ** 3 for x in range(n))
print(simple_generator)  # <generator object <genexpr> at 0x00DCCA38>
print(type(simple_generator))  # <class 'generator'>

for i in simple_generator:
    print(i)
    # 0
    # 1
    # 8
    # 27
    # 64

# Казалось бы, результат одинаковый.
# Но, давайте проверим, какую память занимают оба типа.
# Для этого выведем модуль sys

import sys

print(f'Занятая память при генераторе списков: {sys.getsizeof(simple_list)}')

print(f'Занятая память при неявном генераторе {sys.getsizeof(simple_generator)}')


# При малых значениях передаваемой переменной 'n', разница не ощутима, но если увеличить вычисляемые значения,
# то разница будет значительной.
# При значении n = 100:
# Занятая память при генераторе списков: 452
# Занятая память при неявном генераторе 56

# У списка используемая память растет согласно количеству используемых элементов в листе.
# У генератора ничего не меняеттся, как было 56 при малых значениях, так и остатется 56 при увеличении значения.

# Потому что генератор каждый раз работает только с одним элементом.
# Ему нет необходимости хранить все эти данные в памяти.
# Лист же хранит в памяти все элементы последовательности.

# Вопрос: почему в случае неявного генератора всегда 56 байт, а не меньше?
# Ведь для хранения одного числа требуется гараздо меньше.
# Ответ: в неявном генераторе записан еще алгоритм выработки следующего элемента последовательности.

# Почему генератор называется неявным?
# Это генератор, но очень простой. В нем не используются никакие особые свойства генераторов.


# --------------------------------- Явные генераторы -------------------------------------------

# Для начала напишем явный генератор, который в предыдущем коде создан неявно
# Генераторы определяются через функции.


def generator_example_1(num):  # на вход подаем то количество элементов, которое хотим создать.
    for i in range(num):
        yield i ** 3  # вычисляем куб каждого элемента последовательности


# Дальше, чтобы этот генератор инизиализивать, нам нужно его вызвать и использвать ключевое слово next

gen = generator_example_1(10)
print(next(gen))  # 0
print(next(gen))  # 1
print(next(gen))  # 8
print(next(gen))  # 27

# Кажыдый раз, когда мы вызываем next, происходит вычисленипе следующего элемента в генераторе,
# также, как в неявном генераторе и следующий элемент поступает на выход.
# Это удобне еще и тем, что мы можем генератор вызывать их любого места программы,
# и он каждый раз выдаст следующий элемент.
# Часто это в коде нужно - такое наравномерное использование массивов.
# Когда нужно вот такое неравномерное использование, тогда генераторы сильно помогают.


# Более сложный пример явного генератора (то есть генератор реализованный через код без ф-и yield)
# Создадим список из машин и цветов их раскраски, и померяем объем памяти и время выполнения,
# которое необходимо для обхода полученного списка.

# импортируем необходимые модули
print('Используем Явный генератор')
import time
import os
import random  # для создания списков
import psutil  # модуль, измеряющий количество памяти в кэше, занимаемой каждым объектом.

# Модуль с цветами раскраски
colors = ['White', 'Black', 'Green']

# Модуль с машинами
brands = ['Volvo', 'BMW', 'Audi']


# Создаем ф-ю, которая формирует список: машина-цвет-id

def cars(num):
    cars_list = []
    for i in range(num):
        car = {'color': random.choice(colors),
               # делаем случайный выбор из списка цветов и вносим его в словарь с ключом 'color'
               'brand': random.choice(brands),
               # делаем случайный выбор из списка машин и вносим его в словарь с ключом 'brand'
               'id': i}
        cars_list.append(car)  # вносим созданный словарь в список
    return cars_list


# Перед выполнение ф-и, померяем используемую память.
# Для этого запустим модуль из библиотеке psutil
proc = psutil.Process(os.getpid())  # здесь читаем текущее место в памяти и записываем значение в переменную proc
print('Используемая память до выполнения функции: ' + str(proc.memory_info().rss/1000000))
# Здесь указываем текущую память до выполнения ф-и. Используем метод memory_info()
# В атрибуте rss хранится текущее значение используемой памяти в кэше.
# Приводим в читаемый вид rss/1000000
# Засекаем время старта процесса
start = time.process_time()

# Далее вызываем нашу ф-ю с кодом
# Чтбы этот cars_list записался в память, нам необходимо вызвать его ф-ю.

cars_list = cars(1000000)  # передаем в ф-ю для создания списка количество объектов и присваиваем результат переменной

# Засекаем время окончания процесса
stop = time.process_time()

# Далее меряем память после выполнения ф-и
proc = psutil.Process(os.getpid())  # здесь читаем текущее место в памяти

# Выводим:
print('Используемая память после выполнения функции: ' + str(proc.memory_info().rss/1000000))
print('Заняло времени {} секунд'.format(stop - start))
# Используемая память до выполнения функции: 12.816384
# Используемая память после выполнения функции: 164.179968
# Заняло времени 2.6875 секунд


# Теперь сделаем то же самое, но с использованием неявного генератора
# Перед запуском надо закомментировать ф-ю Явного генератора (предыдущий код)

print('\nИспользуем Неявный генератор')

def cars_gen(num):
    # здесь нам лист не нужен
    for i in range(num):
        car = {'color': random.choice(colors),
               # делаем случайный выбор из списка цветов и вносим его в словарь с ключом 'color'
               'brand': random.choice(brands),
               # делаем случайный выбор из списка машин и вносим его в словарь с ключом 'brand'
               'id': i}
        # вместо return используем ключевое слово yield и поместим его в цикл
        yield car  # здесь каждый раз будем возвращать один объект

# Генератор создали, теперь необходимо создать объект

proc = psutil.Process(os.getpid())

print('Используемая память до выполнения функции: ' + str(proc.memory_info().rss/1000000))
start = time.process_time()
cars_generator = cars_gen(1000000)
stop = time.process_time()
proc = psutil.Process(os.getpid())
print('Используемая память после выполнения функции: ' + str(proc.memory_info().rss/1000000))
print('Заняло времени {} секунд'.format(stop - start))
# Используемая память до выполнения функции: 12.77952
# Используемая память после выполнения функции: 12.808192
# Заняло времени 0.0 секунд

# В результате видим, что память практически не изменилась с использованием ф-и.
# По времени это ничего не заняло.
# То есть, вызывая миллион машин поэлементно, мы значительно разгружаем ресурсы компьютера.
# Именно ради этого и используеются неявные Генераторы в отличии от Генераторов списков.



