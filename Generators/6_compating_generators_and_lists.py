# Сравнение генераторов и списков

# Проведем исследование
# Мы можем при помощи ф-и sum() сложить элементы какого-то списка
# и при помощи List Comprehension записать это в ф-ю sum()
print(sum([number for number in range(10)]))  # 45
# то же самое можно сделать и без List Comprehension - убираем квадратные скобки и это будет Generator Expressions
print(sum(number for number in range(10)))  # 45
# На выводе получаем одно и то же.

# В чем разница?
# Разница в том, что в первом случае (List Comprehension) при сложении элементов этого списка,
# сначала создается полностью весь список
# Во втором случае в один момент времени получаем один элемент из этого списка.
# То есть, в первом случае, в случае большого диапазона, мы можем получить большую нагрузку на ресурсы копьютера,
# и это отразиться на быстродействии нашей программы.
# Во втором случае, когда мы получаем доступ вего к одному элементу в один момент времени,
# мы улучшаем быстродействие нашей программы.

# Проведем эксперемент при помощи модуля time
import time

# При помощи этого модуля мы можем получать текущий момент времени.

list_start_time = time.time()  # эта ф-я возвращает текущий момент времени
# запускаем первый варинат нашего кода - List Comprehension, range увеличивем
print(sum([number for number in range(10000000)]))  #
list_processing_time = time.time() - list_start_time  # получаем время обработки события

# То же самое повторим для Generator Expressions
gen_start_time = time.time()
print(sum(number for number in range(10000000)))  # без квадратных скобок - Generator Expressions
gen_processing_time = time.time() - gen_start_time  # получаем время обработки события

# Выводим результаты
print(f'Время процесса с list {list_processing_time}')
print(f'Время процесса с gen {gen_processing_time}')

# Все как-то пошло не по плану. У листа время даже ниже, чем у генератора.
# 0.13201045989990234
# 0.1720137596130371
