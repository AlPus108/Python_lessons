# СПЕЦИАЛЬНЫЕ МЕТОДЫ ЯЗЫКА ПАЙТОН

# 1
# Эти методы начинаются и заканчиваются двумя знаками подчеркивания __mrthods_name__
# Метод init, который мы определяли для создания объекта класса - один из таких методов.
# С помощью таких (магических) методов можно использовть встроенные ф-и языка Пайтон для объектов,
# которые мы создали самостоятельно.
# В документации Пайтон (можно найти в Гугл по поисковому запросу python documentation) по адресу:
# http://docs.python.org, в разделе Language Reference есть пункт 3 Data model с подразделом 3.3 Special method names
# Это раздел с названиями специальных методов.
# Там описывается, что созданный кастомный вами класс может имплементировать некторые операции.
# Это такие операции, как арифметические или слайсинг, которые определяются методами со специальными именами.
# И этот подход называется "перегрузка операторов", возволяющих классам определить свое собственное поведение
# относительно каких-то встроенных операторрв языка. И эти методы описываются в этом разделе.
# Например, метод __init__(self,[...]) создает объект. В нем можно передавать какие-то аргументы и присваивать
# эти аргументы атрибутам класса.
# Рассмотрим примеры, чтобы стало более понятно.
# Создадим какой-то класс

class Person:
    def __init__(self, first_name, last_name, age):
        self.first_name = first_name
        self.last_name = last_name
        self.age = age
        # --> 1/1

# 2
# Переопределим метод str() в нашем классе
    def __str__(self):
        return self.first_name + ' ' + self.last_name
    # и теперь попробуем распечатать Джека --> 2/1

# 3
# Переопределим метод len() для нашего класса. В нашем случае он будет возвращать возраст человека.
    def __len__(self):
        return self.age
    # и далее теперь мы можем пользоваться этим методом для jack --> 3/1

# 4
# Переопределим метод del() для нашего класса
    def __del__(self):
        print(f"Объект Person с именем {self.last_name} удален из памяти.") # --> 4/1

# 5
# Пусть метод add() у нас складвает возраст
    def __add__(self, other):  # по умолчанию добавляется параметр other. Это тот объект, который будет добавляться.
        return self.age + other.age
    # --> 5/1


# 1/1
# Создаем объекты этого класса

jack = Person('Jack', "White", 45) # --> 1/2
# 5/1 создаем еще один объект класса Person
jane = Person('Jane', 'Eyer', 23)

# Теперь сложим эти два объекта
print(jack + jane)  # 68 - получили с помощью переопределенного метода add
# Мы конечно же получаем здесь имплементацию метода add(),
# но дальше мы получаем, что Person Jack и Jane были удалены из памяти.
# Объект Person с именем White удален из памяти.
# Объект Person с именем Eyer удален из памяти.
# Они удаляются автоматически. Почему это происходит?
# После того, как мы сложили Джека и Джейн, у нас есть какой-то код, который дальше выполнился,
# выводится результат этого кода. А дальше все равно эти объекты удаляются из памяти.
# Дело в том, что встроенный метод del(), он еще называется диструктором, вызывается каждый раз,
# когда объект собирается удалять из памяти Сборщик мусора. Этот инструмент используется в Пайтоне для того,
# чтобы не засорять память.
# Если на ваш объект нет никаких ссылок, то есть он уже неиспльзуется, то Сборщик мусора это видит, что ваш объект
# не имеет никаких связей с другими объектами, и удаляет его.
# В конце каждой программы он также вызывается для всех объектов. Но обычно его работа не видна.
# Но, так как в нашей программе мы переопределили его на выведение сообщения об удалении объекта из памяти,
# поэтому мы получаем такое сообщение.
# Если бы мы перепрописали бы ф-ю del() для всех объектов, то получали бы такие сообщения об удалении каждого объекта
# после выполнения всей программы. Так как в конце выполнения программы все ненужные объекты удаляются из памяти.

# 1/2
# Для некоторых объектов, для строк, например, и для списков есть такая встроенная ф-я len()
print(len([1, 2, 3, 4, 5]))
# Будет выведена длина - количество элементов этого списка
# Что же будет, если мы попытаемся вывести длину созданного нами объекта jack?
# print(len(jack))
# Мы получим сообщение об ошибке: TypeError: object of type 'Person' has no len()
# То есть, мы не имеем этого метода в нашем классе.
# Точно также, если мы попробуем просто распечатать наш объект, также, как мы распечатываем список
print(jack)
# <__main__.Person object at 0x03161DC0>
# Мы получим лишь адрес этого объекта в памяти компьютера. Но, это не то, что мы хотим видеть.
# Возможно, мы хотели бы видеть, чтобы выводилось его имя и вамилия.
# В этом случае мы можем переопределять эти специальные методы.
# Например, мы можем переопределить метод __str__(self)
# В инструкции к нему написано, что этот метод вызывается для встроенных ф-й format() и print(), чтобы вывести
# неформальную строку. И возвращаемое значение этого объекта должно быть строкой. То есть, это то, что нам нужно.

# Давайте определим этот метод в нашем классе Person --> 2

# 2/1
# И теперь, если мы пустим на печать объект Jake, то получим
# Jack White

# Точно также мы можем использовать переопределение метода len()
# В документации написано, что этот методо __len__(self) вызывается для встроенной ф-и len()
# и он должен возвращать длину объекта - целое число >= 0.
# Переопределим для нашего класса Person метод len() --> 3

# 3/1
# Выведем на экран возраст Джека
print(len(jack))  # 45

# Тажке, существует метод del(). Он вызывается, когда экзепляр класса должне быть уничтожен.
# Если сейчас мы попытаемся удалить наш объект jack
del(jack)
# и попытаемся его снова распечатать
# print(jack)
# получим ошибку: NameError: name 'jack' is not defined
# Дело в том, что при вызове ф-и del() удаляется ссылка на эту переменную из памяти компьютера.
# Компьютер, не видя такого объекта, выдает ошибку о том, что такого объекта не существует.
# Но мы можем переопределить метод, чтобы он выдавал сообщение, что этот объект удален  --> 4

# 4/1
# Теперь при использовании этого метода, получаем сообщение: Объект Person с именем White удален из памяти.

# Также можно использовать и арифметические операторы
# Например, для чисел и для строк операция сложения производится по разному.
x = 5 + 5
y = '5' + '5'
print(x, y)
# Получим два разных результата: 10 55 - в первом случае число, во втором - строка.
# В разеле 3.3.8 Emulating numeric types (Эмуляция числовых типов) документации найдем встроенные метды для чисел
# Там в частности написано, что для выполнения варажения х+у вызывается метод add(), который реализован по разному
# для числовых и строковых типов.
x = 5
y = 3

a = '5'
b = '3'

print(x + y)  # 8
print(a + b)  # 53

# В случае с цифрами метод add() их складывает, а строки конкотенирует.
# То есть, мы можем совершать эти операции через прямой вызов метода add()

print(x.__add__(y))  # 8
print(a.__add__(b))  # 53
# Получаем тот же результат.
# То есть, метод add имплементирован по разному в строках и числах.
# Точно также мы можем имплементировать его и в свой объект. --> 5

# Здесь мы рассмотрели небольшое число специальных методов. Вы коненчо можете самостоятельно просмотреть
# документацию по Пайтон, в интернете на стэк оверфлоу, искать примеры имплементации нужных вам методов,
# нужного вам поведения для ваших собственных объектов.