# Цикл for
# Иногда называют синтаксическим сахаром. Потому что можно обойтись и циклом while
# Но, для удобства и красоты применяют и for

# Простейший for

# Конструкция range(start, stop, step)
# start - число с которого начинаем,
# stop - число, которым заканчиваем,
# step - шаг, через какой интервал будут браться числа

# for i in range(0, 10, 1):  # здесь будем брать все числа
#     print(i)

# for i in range(0, 100, 15):  # от 0 до 100 с шагом 15
#     print(i)

# обратный порядок
# for i in range(10, 0, -1):  # от 10 до 0 с шагом -1(отнимаем)
#     print(i)

# Краткая запись
# for i in range(10):  # от нуля до числа в скобках
#     print(i)

# Добавляем в цикл проверку условия
# for i in range(10):  # от нуля до числа в скобках
#     print(i)
#     if i == 5: break # если i равен 5, цикл прерывается

# Количество повторений
# for i in range(10):
#     answer =input('Какая лучшая марка автомобиля?')
#     if answer == 'Volvo':
#         print('Вы абсолютно правы!')
#         break

# Continue
# for i in range(10):
#     if i == 9:
#         break
#     if i < 3:
#         continue
#     else:
#         print(i)


# ----------------------------- Вывод list / Списка ----------------------

# # Имеем список
# num_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# for i in num_list:
#     print("Hi")  # Здесь можно даже не указывать i. Слово "Hi" выведется столько раз, сколько цифр в списке.
# # Но, обычно, если используется список, обычно происходит работа над этим списком.
#     print(str(i) + 'Text')   # Если хотим вывести цифру и текст в одной строке, надо цифру привести к типу str()
#     и затем их можно конкотенировать

# Вывод каждой буквы строки
# string = 'Привет!'
# for letter in string:
#     print(letter)  # Получаем вывод слова - каждая буква на отдельной строке

# Вывод отдельной буквы
# string = 'Го-о-о-о-л!'
# for letter in string:
#     if letter == 'о':
#         print(letter) # Выводим только букву "о"

# Вывод без отдельной буквы
# string = 'Го-о-о-о-л!'
# for letter in string:
#     if letter != 'о':
#         print(letter)  # Выводим все буквы кроме буквы 'о'

#  Строка в условии
# for letter in 'Привет!':  # Вставляем строку в само условие без переменной
#     print(letter)

# Можно выводить совершенно другую строку
# for letter in 'Привет!':  # Вставляем строку в само условие без переменной
#     print('Еще одна буква')  # Вывод предложениия будет столько раз, сколько букв в строке 'Привет!'


# ------------------------ Вывод Tuple ----------------------------

# tuple_list = [('a', 'b'), ('c', 'd'), ('e', 'f')]
# for item in tuple_list:
#     print(item)
#  Вывод:
# ('a', 'b')
# ('c', 'd')
# ('e', 'f')

# В цикле можно сделать распаковку объекта Тапл

# for letter_1, letter_2 in tuple_list:  # Так как Тапл имеет два объекта, пишем две переменные цикла
#     print(letter_1, letter_2)
# Вывод:
# a b
# c d
# e f
# Выводим на экран значения переменных

# Выводим каждую с новой строки
# for letter_1, letter_2 in tuple_list:  # Так как Тапл имеет два объекта, пишем две переменные цикла
#     print(letter_1)
#     print(letter_2)
# Вывод:
# a
# b
# c
# d
# e
# f

# Выводим первый элемент из каждого объекта Тапл
# for letter_1, letter_2 in tuple_list:  # Так как Тапл имеет два объекта, пишем две переменные цикла
#     print(letter_1)
# Вывод:
# a
# c
# e

# В В Тапл могут быть не только буквы
# tuple_list_1 = [('a', 'b', 1), ('c', 'd', 5), ('e', 'f', 9)]
# for letter_1, letter_2, number in tuple_list_1:  # Добавляем в условие третью переменную
#     print(letter_1, letter_2, number)
# Вывод:
# a b 1
# c d 5
# e f 9
# Переменые уже не в скобках. То есть, это уже не Тапл. Это распакованный Тапл. Он распакован в переменные
# и затем переменные выведены здесь

# ---------------------- Вывод Словарей -----------------------------

# dict = {'key_1': 'value_1', 'key_2': 'value_2','key_3': 'value_3'}
# for item in dict:
#     print(item)
# Вывод:
# key_1
# key_2
# key_3
# Сдеть получился неожиданный вывод. Мы получили только Ключи, но не пару Ключ-Значение.
# То есть, по умолчанию, когда мы обращаемся к переменной, в ней храняться только Ключи.

# Чтобы получить всю пару Ключ-Значени, надо при итерации использовать метод Словарей items()
# for item in dict.items():
#     print(item)
# # Вывод:
# # ('key_1', 'value_1')
# # ('key_2', 'value_2')
# # ('key_3', 'value_3')

# Получаем только список Ключей
# for item in dict.keys():  # Явно указываем Ключи
#     print(item)
# key_1
# key_2
# key_3

# Список Значений
# for item in dict.values():  # Явно указываем Значения
#     print(item)
# value_1
# value_2
# value_3

# В зависимости от того, что вы хотите получить, вы можете использовать такие формы записи.

# Так же, если вы хотите получить или Ключи или Значения, вы можете использовать другой код
# for key, value in dict.items():  # Распаковка в две переменные key и value
#     print(key)  # Здесь выводим только ключи

#  Также, при помощи распаковки мы можем получить и значения
# for key, value in dict.items():  #
#     print(value)  # Здесь выводим только значения

# ----------------------------------------------------------------

# Хотим произвести какое-то действие несколько раз, но мы не хотим привязываться ни к какой последовательности,
# ни к строке, ни к списку, ни к тапл. Мы можем это сделать при помощи ф-и range()
# Ф-я range() возвращает последовательность из чисел от 0 до параметра, который мы можем указать в этой ф-и

# for x in range(5):  # В параметрах ставим 5, если мы хотим пять раз произвести какое-то действие.
#                     # Будет создана последовательность от 0 до 5
#     print(x)        # На экран выводится сама последовательность
# 1
# 2
# 3
# 4

# Выводим какое-то действие

# for x in range(5):
#     print('Hello!')
# Hello!
# Hello!
# Hello!
# Hello!
# Hello!
# Получаем пять раз вывод строки. Но, переменная х в этом коде не используется.

# В случае неиспользования переменной, если надо просто произвести итерацию какого-то действия,
# можно ставить знак нижнего подчеркивания
# for _ in range():
#     print('Привет!')
# Это также имя переменной, но оно используется, когда это имя не важно, а важна сама итерация.



