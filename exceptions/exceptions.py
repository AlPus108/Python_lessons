# ИСКЛЮЧЕНИЯ / ОШИБКИ

# Ошибки в программировании неизбежны
# Виды ошибок:
# - синтаксические SyntaxError
# - ошибки наименования NameError - обращение к несуществующим объектам
# - ошибки типов TypeError
# Если, допустим, мы попробуем определить длину объекта int - len(1), то получим ошибку,
# так как объекты типа int не имеют длины. Мы не можем применить эту ф-ю к целым числам
# Или при конкотенации объектов разных типов print(my_list + 'hello') - тоже плучим ошибку.
# Современные среды разработок достаточно умны, чтобы отслеживать такие ошибки
# - индексные ошибки IndexError - при обращении к несуществующему индексу.
# my_list = [1, 2, 3] - здесь последний индекс - 2
# print(my_list[3] - пытаемся обратиться к третьему (несуществующему индексу) - list index out of range
# аналогично print['hello'[5]) - здесь нет пятого индекса
# - ошибки значения ValueError. Такая ошибка возникает тогда, когда мы пытаемся применить какую-то ф-ю
# и применить какое-то значение подходящего типа, но само значение не возможно обработать этой ф-ей.
# print(int('43') - получим число 43. Здесь ошибки нет
# print(int('he') - получим ошибку ValueError, т.к. Пайтон не может привести к типу int строковое значение.
# print(int([43]) - получим ошибку TypeError, т.к. ф-я int() не может принимать список.
# - ошибки ключа KeyError - возникает при обращении к ключу словаря, которого нет
# my_dict = {'first': 'apple', 'second': 'orange'}
# my_dict['third'] - KeyError: 'third' - ключа с таким названием в словаре нет
# - ошибки атрибута AttributeError - возникает, если мы хотим испльзовать для какого-то объекта метод или атрибут,
# которого у него нет.
# 'red'.attr() - такого метода у строк нет.
# Кроме этих рассмотренных ошибок, сущесвтует еще огромное их количество.
# При возникновении в коде ошибки, вы всегда можете нагуглить по ней информации. Копируете название ошибки,
# переходите в Гугл, набираете python AttributeError (к примеру) и можно найти много объяснений и примеров этой ошибки.


# ------------------- Как вызывать собственные ошибки и для чего это делать -----------------------

# В Пайтоне существует возможность вывать ошибку при помощи ключевого слова raise.
# Мы вызываем какую-то ошибку по нашему желанию. Когда это может понадобиться?
# Например, вы написали ф-ю, которая принимает параметр определенного типа, но при вызове этой ф-и вы передаете ей
# параметр другого типа. И тогда вы можете выбросить ошибку. Например, TypeError и написать к ней пояснение о том,
# какие параметры нужно передавать в эту ф-ю.

# raise ValueError('Неверное значение')  # в скобках передаем какое-то объяснение/подсказку по этой ошибке.
# При запуске получаем сообщение: ValueError: Неверное значение
# Также мы можем вызывать эту ф-ю без передачи текста внутри. Тогда просто получим ValueError

# Как это можо использовать?
# Для примера создадим ф-ю, которая на вход примимает число и возвращает определенный цвет радуги.
# def get_rainbow_color(color_number):
#     if color_number == 1:
#         return 'red'
#     elif color_number == 2:
#         return 'orange'
#     elif color_number == 3:
#         return 'yellow'
#     elif color_number == 4:
#         return 'green'
#     elif color_number == 5:
#         return 'blue'
#     elif color_number == 6:
#         return 'indigo'
#     elif color_number == 7:
#         return 'violet'
#
#
# print(get_rainbow_color(2))

# Если введем 8 - получим None
# В дальнейшем, при обработке этого значения None в программе могут возникнуть ошибки, так как мы ожидаем строку.
# Поэтому будет уместнее определить все подходящие значения заранее, которые можно передавать в эту ф-ю.

# def get_rainbow_color(color_number):
#
#     color_number_list = [1, 2, 3, 4, 5, 6, 7]  # определили все подходящие значения
#     if color_number not in color_number_list:  # если введенное число не из нашего списка, выдаем сообщение об ошибке
#         raise ValueError('Число должно быть в пределах чисел от 1 до 7')
#
#     if color_number == 1:
#         return 'red'
#     elif color_number == 2:
#         return 'orange'
#     elif color_number == 3:
#         return 'yellow'
#     elif color_number == 4:
#         return 'green'
#     elif color_number == 5:
#         return 'blue'
#     elif color_number == 6:
#         return 'indigo'
#     elif color_number == 7:
#         return 'violet'
#
#
# print(get_rainbow_color(8))

# Следующий тип ошибки, который может здесь возникнуть, это TypeError
# когда вместо числа кто-то передаст строку, например.
# Мы можем вызвать сообщение об этом виде ошибки.

# def get_rainbow_color(color_number):
#
#     if type(color_number) is not int:
#         raise TypeError("Введенное значение должно быть типа 'int'")
#
#     color_number_list = [1, 2, 3, 4, 5, 6, 7]  # определили все подходящие значения
#     if color_number not in color_number_list:  # если введенное число не из нашего списка, выдаем сообщение об ошибке
#         raise ValueError('Число должнр быть в пределах чисел от 1 до 7')
#
#     if color_number == 1:
#         return 'red'
#     elif color_number == 2:
#         return 'orange'
#     elif color_number == 3:
#         return 'yellow'
#     elif color_number == 4:
#         return 'green'
#     elif color_number == 5:
#         return 'blue'
#     elif color_number == 6:
#         return 'indigo'
#     elif color_number == 7:
#         return 'violet'
#
#
# print(get_rainbow_color('hi'))
# TypeError: Введенное значение должно быть типа 'int'

# Когда мы создаем свои ф-и, желательно создавать к ним документации, где давать инструкции, предупреждающие
# возможные ошибки

# def get_rainbow_color(color_number):
#
#     '''
#
#     :param color_number: Введенное значение должно быть типа 'int и Число должно быть в пределах чисел от 1 до 7
#     :return:
#     '''
#
#     if type(color_number) is not int:
#         raise TypeError("Введенное значение должно быть типа 'int'")
#
#     color_number_list = [1, 2, 3, 4, 5, 6, 7]  # определили все подходящие значения
#     if color_number not in color_number_list:  # если введенное число не из нашего списка, выдаем сообщение об ошибке
#         raise ValueError('Число должно быть в пределах чисел от 1 до 7')
#
#     if color_number == 1:
#         return 'red'
#     elif color_number == 2:
#         return 'orange'
#     elif color_number == 3:
#         return 'yellow'
#     elif color_number == 4:
#         return 'green'
#     elif color_number == 5:
#         return 'blue'
#     elif color_number == 6:
#         return 'indigo'
#     elif color_number == 7:
#         return 'violet'
#
#
# print(get_rainbow_color('hi'))

# Так же, мы можем выбрасывать ошибки, если у нас несколько параметров

def colorize_text(color_number, text):
    '''

    :param color_number: Введенное значение должно быть типа 'int и Число должно быть в пределах чисел от 1 до 7
    :param text: Параметр text должен быть типа str
    :return:
    '''


#     if type(text) is not str:
#         raise TypeError('Параметр text должен быть типа str')
#
#     if type(color_number) is not int:
#         raise TypeError("Введенное значение должно быть типа 'int'")
#
#     color_number_list = [1, 2, 3, 4, 5, 6, 7]  # определили все подходящие значения
#     if color_number not in color_number_list:  # если введенное число не из нашего списка, выдаем сообщение об ошибке
#         raise ValueError('Число должно быть в пределах чисел от 1 до 7')
#
#     if color_number == 1:
#         print('red ' + text)
#     elif color_number == 2:
#         print('orange ' + text)
#     elif color_number == 3:
#         print('yellow ' + text)
#     elif color_number == 4:
#         print('green ' + text)
#     elif color_number == 5:
#         print('blue ' + text)
#     elif color_number == 6:
#         print('indigo ' + text)
#     elif color_number == 7:
#         print('violet ' + text)


# print(colorize_text(4, True))  # ввели значение типа bool
# Получаем ошибку: TypeError: Параметр text должен быть типа str


# Итак, мы разобрали, какие бывают ошибки, как их вызывать в своем коде.
# Теперь разберем, как ими управлять.
# На данный момент, если происходит ошибка, программа останавливается.

# Какой-то код
# Код с ошибкой - здесь программа совершает аварийную остановку.
# Код после ошибки - эта часть кода уже не выполняется.
# И это не очень хорошо.
# Но, в языке Пайтон имеется возможность обработки ошибок. Эти ошибки еще называют исключениями.
# Это исключительные ситуации.

# Исключение - это реакция программы на ее некорректную работу.
# Исключение, это некоторый тип данных, который выкидывается в трэйс-бэк с информацией об ошибке.
# В Пайтоне введена иерархия исключений. Есть исключения крупные, т.е. менее информативные,
# и есть более детальные, которые содержат конкретную информацию об ошибке.


# Исключения необходимо обрабатывать. И это делается с помощью следующих методов:

# --------------------- 1 Метод try() - ручная обработка исключений -------------------------

# Это конструкция try - except (исключение)
# Мы помещаем код, который может потенциально вызвать ошибку, в такой блок

# try:
#     print('код с ошибкой')
# except:
#     print('Произошда какая-то ошибка!')
# После такой конструкции программа не останавливается, а выдав сообщение об ошибке, продолжает выполняться.
# То есть, этот блок обрабатывает ошибку и продолжает работу

# Но, что если у нас в коде не одна ошибка?
# try:
# print(my_var)  # необъявленная переменная
# print(len(23))  # несоответствие типа данных
# except:
#     print('Произошда какая-то ошибка!')
# у нас две ошибки, но сообщение одно. Что делать?
# если наведем курсор на слово except - всплывет подсказка 'Too broad exception clause' -
# блок except слишком широкий. Он принимает все ошибки, которые будут происходить в блоке try
# Можно делать несколько блоков except

try:
    print(my_var)  # необъявленная переменная
    print(len(23))  # несоответствие типа данных
except NameError:
    print('NameError has happend!')
except TypeError:
    print('Код после ошибки')
# Вывод: Код после ошибки - была обработана первая ошибка. Следующая строка в блоке Try print(my_var) не выполняется.
# Если мы поменяем местами принты, будет выведен NameError has happend! потому что вторая строка в коде не срабатывает.
# После того, как произошла ошибка, будет выведен соответствующий типу ошибки блок except
# и затем идет продолжение выполнения кода.

# Рассмотрим это на примере реальной ф-и.
# У нас есть словарь, в котором содержатся какие-то данные о пользователе

user_dictionary = {'first_name': 'Jack', 'last_name': 'White', 'age': 24}


# Выводим данные из словаря
# print(user_dictionary['first_name'])
# но, если мы попробуем сделать то же самое, но по отсутствующему ключу
# print(user_dictionary['name'])
# получим сообщение об ошибке: KeyError: 'name' - ошибка по ключу. Такого ключа нет.
# Но, если мы получаем это значение при помощи ф-и get(), которая существует для словаря
# print(user_dictionary.get('first_name'))  # Jack
# print(user_dictionary.get('ame'))  # None
# При использовании ф-и get() в случае ошибки получаем None, То есть, мы не получаем ошибку
# В этом методе ошибки обрабатываются.

# Напишем похожую ф-ю с обработкой ошибки.
# C помощью этой ф-и будем получать значения из словаря по ключу
# def get_dict_value(dict, key):  # будем передавать ф-и два параметра: dict и key
#     return dict[key]

# вызываем эту ф-ю для словаря user_dictionary
# print(get_dict_value(user_dictionary, 'age'))  # 24
# Если мы передадим что-то не валидное, то получим ошибку
# print(get_dict_value(user_dictionary, 'a'))  # KeyError: 'a'
# И мы можем обработать это при помощи блока try

def get_dict_value(dict, key):
    '''
    # Если ф-я не получает нужный ключ, то будет передано None
    :param dict:
    :param key:
    :return:
    '''
    try:
        return dict[key]
    except KeyError:  # в этом случае возвращаем значение None
        return None


print(get_dict_value(user_dictionary, 'age'))  # 24
print(get_dict_value(user_dictionary, 'a'))  # KeyError: 'a'
# сделаем еще один вызов, чтобы проверить, что код работает после вывода ошибки
print(get_dict_value(user_dictionary, 'first_name'))  # получаем Jack
# Мы обработали ситуацию. И теперь при ошибке никакого сообщения не выводится, а ф-я возвращает значение None
# И мы указали это в спецификации к этой ф-и

# Блок try - except самая короткая запись.
# Есть расширени для этого блока с помощью дополнений else и finally

# Рассмотрим пример.
number = input('Введите число')
# print(number / 2)  # здесь происходит математическая операция, что требует два объекта типа int,
# но операнд number имеет тип 'str',так как ф-я input() всегда возвращает строку. Делить строку не чаисло не допустимо,
# поэтому возвращается ошибка. Эту ошибку можно исправить, если привести number к типу int: int(number)
# Но, может возникнуть ситуация, когда введенная строка не может быть приведена к типу int. Допустим, ввели строку
# В этом случае получим ошибку ValueError, так как строка не может быть приведена к типу int
# Здесь приходит на помощью блок try - except

try:
    print(int(number) / 2)
except:
    print('Вы должны ввести число!')
# дальше мы можем указать (не обязательно) блок else
else:
    print('Блок else срабатывает, когда в коде нет ошибки и блок except не срабатывает')
finally:
    print('Финальный блок выполняется в любой случае, даже если была возвращена ошибка.')

# Как это использовать?

while True:  # создаем бесконечный цикл, который будет продолжаться, пока пользователь не введет число
    try:
        number = int(input('Введите число!'))
        print(number / 2)
    except:
        print('Вы должны ввести число!')
    else:
        print('Все верно!')
        break  # здесь выходим из бесконечного цикла при условии, что пользователь ввел число
    finally:
        # в этом блоке можем делать операции, которые необходимы в любом случае, есть ошибка или нет.
        # например, закрывать файл, который был открыт на этапе try
        print('Финальный блок выполняется в любой случае, даже если была возвращена ошибка.')
print('Следующий код после блока try - finally')

try:  # выполняет код внутри своего тела и натыкается на исключение
    k = 1 / 0  # если возникает какое-то исключение, мы должны знать название исключения, которое возникло
except ArithmeticError:  # названия можно указывать в самом общем виде.
    # Чем выше название, тем менее точно мы можем сказать, что произошло
    # В данном случае указываем, что это ArithmeticError - арефметическая ошибка.
    k = 0  # при получении ошибки
    # дальше менее используемые ветви програрммы else и finally
else:  # выполняется в том случае, если не было исключений
    print('All right')
finally:  # выполняется всегда, не зависимо от сценария работы программы.
    print('Division complete!')


# Сценарий
# try:
#   исполняем какой-то код
# except Exception as e:  - в переменной 'e' будет находится информация об этом исключении, текст самой ошибки,
#   обработка исключения. Здесь мы можем испльзвоать описание ошибки из переменной 'e'
#   Выводим какую-то информацию, сохраняем какие-то логи или что-то другое
# else:
#   Код, который будет выплнен в том случае, если не возникает исключения
# finally:
#   Код, который выполняется всегда.

# Пример кода

# a = int(input('Введите первое число: '))
# b = int(input('Введите второе число: '))
#
# print(a / b)

# Сознательно поделим на 0
# Получим исключение: ZeroDivisionError: division by zero

# Обработаем это исключение с помощью метода try - except
# try:
#     a = int(input('Введите первое число: '))
#     b = int(input('Введите второе число: '))
#
#     print(a / b)
# except ZeroDivisionError as e:
#     print('Так больше не делай: ', e)
# # Получаем вывод исключения: division by zero
# else:
#     print('Все хорошо!')
# finally:
#     print('Это было что-то!')


# Пример с перехватом двух вариантов ошибок

def divide(x, y):
    try:
        print(x / y)  # если тут вместо print будет return, блок else никогда не выполнится; выполнится только finally
    except ZeroDivisionError as e:
        print(e)
        print('Вы не можете делить на ноль!')
    except TypeError as e:
        print(e)
        print('Вводимые значения долджны быть числами!')
    else:
        print('х был поделен на у')
    finally:
        print('Блок finally выполняется в любом случае')


# Рассмотрим еще один скрип со считыванием данных из файла.
# У нас есть файл data. В нем находятся числа.
# Открываем файл

# f = open('data')  # это реальный файл, находитмя в том же каталоге
# # Там находятся числа. Поэтому мы создадим лист и туда считаем эти числа
# int_arr_list = []
# for line in f:
#     int_arr_list.append(int(line))  # приводим к int, так как в файле числа
# print(int_arr_list)  # [123, 1234, 12345]

# Но, если в файл добавим не цифру, то получим исключение:
# ValueError: invalid literal for int() with base 10: 'выаыв\т'

# ОБработаем эту ошибку с помощью try - except

f = open('data')
int_arr_list = []
try:
    for line in f:
        int_arr_list.append(int(line))
    print(int_arr_list)  # [123, 1234, 12345]
except ValueError:
    print('У вас там кроме чисел еще что-то непонятное!')
else:
    print('Все прошло хорошо!')
finally:
    f.close()  # если файл открыли, то обязательно в конце работы с ним его надо закрыть!

print(int_arr_list)


# Таким образом можно писать свои искючения. Это бывает полезно, когда при работе программы надо получить
# какую-то информацию. Вы прописываете искоючение, пишите в нем какое-то сообщение, которое выходит при
# получении какого-то события.

# ---------------- 2 ПОЛУАВТОМАТИЧЕСКИЕ МЕОДЫ ТЕСТИРОВАНИЯ -------------------------

# Это подход, когда пишутся ручные самостоятельные ф-и, которые проводят некое тестирование по выбранным вами
# кретериям.

# def test_function():
#     if something:
#         print('Тест пройден!')
#     else:
#         print('Тест не пройден')

# Код написан в ручную, вами, и здесь проверка проводится в автоматическом режиме,
# поэтому, можно сказать, что это полуавтоматический режим тестировния

# Проверим, как это работает на практике.
# Напишем ф-ю для тестирования.
# Передаем список list, функция очищает лист от значений, которые не являются числами и передает данные в виде list

def test_function(list_enter):
    '''
    вход: list
    выход: list, содержащий только числа
    :return:
    '''

    list_temp = []
    i = 0
    while (type(list_enter[i]) == int):
        list_temp.append(list_enter[i])
        i += 1
    return list_temp


list_temp = [1, 2, 3, 'abc']

print(test_function(list_temp))


# Пишем полуавтоматическую ф-ю
def function_test_1():  # на вход ничего не принемает
    list_temp = [1, 2, 3, 'abc']  # ф-я должна вернуть [1, 2, 3]
    list_out = test_function(list_temp)
    if list_out == [1, 2, 3]:
        print('Тест 1 пройден!')
    else:
        print('Тест 1 не пройден!')


function_test_1()  # Запускаем, проверяем - Тест 1 пройден!


# Теперь в той же ф-и допустим ошибку
def function_test_2():
    list_temp = [1, 2, 3, 'abc', 4]  # Добавляем 4 и ф-я должна вернуть [1, 2, 3, 4]
    list_out = test_function(list_temp)
    if list_out == [1, 2, 3, 4]:
        print('Тест 2 пройден!')
    else:
        print('Тест 2 не пройден!')


function_test_2()  # Запускаем, проверяем - Тест 2 не пройден!


# Почему не правильно? Потому что мы в ней использовали цикл while, который, выполняя условие, будет работать до
# первого непопадания и затем прекращает работу.


# Поэтому, переделываем на цикл for
def test_function_2(list_in):
    '''
    вход: list
    выход: list, содержащий только числа
    :return:
    '''

    list_temp = []
    i = 0
    for i in range(len(list_in)):
        if type(list_in[i]) == int:
            list_temp.append(list_in[i])
    return list_temp


# и снова запустим тест
def function_test_3():
    list_temp = [1, 2, 3, 'abc', 4]  # Добавляем 4 и ф-я должна вернуть [1, 2, 3, 4]
    list_out = test_function_2(list_temp)
    if list_out == [1, 2, 3, 4]:
        print('Тест 3 пройден!')
    else:
        print('Тест 3 не пройден!')


function_test_3()  # Запускаем, проверяем - Тест 3 пройден!


# Немного усложним ситуаци.
# Числа в последовательности могут быть не только в числовом виде, но и в виде строки
def function_test_4():
    list_temp = [1, 2, 3, '5', 'abc', 4]  # Добавляем '5' и ф-я должна вернуть [1, 2, 3, 5, 4]
    list_out = test_function_2(list_temp)
    if list_out == [1, 2, 3, 5, 4]:
        print('Тест 4 пройден!')
    else:
        print('Тест 4 не пройден!')


function_test_4()  # Запускаем, проверяем - Тест 4 не пройден!


# Почему не пройден? Потому что ф-я не распознает цифры в текстовом формате

# Исправим ф-ю
def test_function_3(list_in):
    '''
    вход: list
    выход: list, содержащий только числа
    :return:
    '''

    list_temp = []
    i = 0
    for i in range(len(list_in)):
        if type(list_in[i]) == int:
            list_temp.append(list_in[i])
        # на этом этапе надо дать ф-и возможность понять, что передана цифра в виде строки
        elif type(list_in[i]) == str:  # если это строка,
            # дальше делаем проверку с помощью метода isdigit()
            if list_in[i].isdigit():  # если это число в виде строки - isdigit вернет 1(true), если не число - 0(false)
                list_temp.append(int(list_in[i]))  # в случае true - включаем цифру в список c приведением к типу int
    return list_temp


# Делаем проверку
def function_test_5():
    list_temp = [1, 2, 3, '5', 'abc', 4]  # Добавляем '5' и ф-я должна вернуть [1, 2, 3, 5, 4]
    list_out = test_function_3(list_temp)
    if list_out == [1, 2, 3, 5, 4]:
        print('Тест 5 пройден!')
    else:
        print('Тест 5 не пройден!')


function_test_5()  # Запускаем, проверяем - Тест 5 пройден!

# Это пример полуавтоматического тестирования.
# Понятно, что он достаточно наивен.
# Обычно такие задачи решаются с помощью библиотек, таких как pytest и unitest

# --> test_pytest.py
