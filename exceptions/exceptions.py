# ИСКЛЮЧЕНИЯ

# Исключение - это реалкция программы на ее некорректную работу.
# Исключение, это некоторый тип данных, который выкидываетсы в трэйс-бэк с информацией об ошибке.
# В Пайтоне введена иерархия исключений. Есть исключения крупные, т.е. менее информативные,
# и есть более детальные, которые содержат конкретную информаци. об ошибке.
# Исключения необходимо обрабатывать. И это делается с помощью следующих методов:

# --------------------- 1 Метод try() - ручная обработка исключений -------------------------
try:  # выполняет код внутри своего тела и натыкаемся на исключение
    k = 1 / 0  # если возникает какое-то исключение, мы должны знать название исключения, которое возникло
except ArithmeticError:  # названия можно указывать в самом общем виде.
    # Чем выше название, тем менее точно мы можем сказать, что произошло
    # В данном случае указываем, что это ArithmeticError - арефметическая ошибка.
    k = 0  # при получении
    # дальше менее используемые ветви прогарммы else и finally
else:  # выполняется в том случае, если не было исключений
    print('All right')
finally:  # выполняется всегда, не зависимо от сценария работы программы.
    print('Division complete!')

# Сценарий
# try:
#   исполняем какой-то код
# except Exception as e:  - в переменной 'e' будет находится информация об этом исключении
#   обработка исключения. Здесь мы можем испльзвоать описание ошибки из пересенной 'e'
#   Выводим какую-то информацию, сохраняем какой-то логи или что-то другое
# else:
#   Код, который будет выплнен в том случае, если не возникает исключения
# finally:
#   Код, который выполняется всегда.

# Пример кода

# a = int(input('Введите первое число: '))
# b = int(input('Введите второе число: '))
#
# print(a / b)

# Сознательно поделим на 0
# Получим исключение: ZeroDivisionError: division by zero

# Обработаем это исключение с помощью метода try - except
try:
    a = int(input('Введите первое число: '))
    b = int(input('Введите второе число: '))

    print(a / b)
except ZeroDivisionError as e:
    print('Так больше не делай: ', e)
# Получаем вывод исключения: division by zero
else:
    print('Все хорошо!')
finally:
    print('Это было что-то!')

# Рассмотрим еще один скрип со считыванием данных из файла.
# У нас есть файл data. В нем находятся числа.
# Открываем файл

# f = open('data')
# # Там находятся числа. Поэтому мы создадим лист и туда считаем эти числа
# int_arr_list = []
# for line in f:
#     int_arr_list.append(int(line))  # приводим к int, так как в файле числа
# print(int_arr_list)  # [123, 1234, 12345]

# Но, если в файл добавим не цифру, то получим исключение:
# ValueError: invalid literal for int() with base 10: 'dsfsd\n'

# ОБработаем эту ошибку с помощью try - except

f = open('data')
int_arr_list = []
try:
    for line in f:
        int_arr_list.append(int(line))
    print(int_arr_list)  # [123, 1234, 12345]
except ValueError:
    print('У вас там кроме чисел еще что-то непонятное!')
else:
    print('Все прошло хорошо!')
finally:
    f.close()  # если файл открыли, то обязательно в конце работы с ним его надо закрыть!

print(int_arr_list)


# Таким образом можно писать свои искючения. Это бывает полезно, когда при работе программы надо получить
# какую-то информацию. Вы прописываете искоючение, пишите в нем какое-то сообщение, которое выходит при
# получении какого-то события.

# ---------------- 2 ПОЛУАВТОМАТИЧЕСКИЕ МЕОДЫ ТЕСТИРОВАНИЯ -------------------------

# Это подход, когда пишутся ручные самостоятельные ф-и, которые проводят некое тестирование по выбранным вами
# кретериям.

# def test_function():
#     if something:
#         print('Тест пройден!')
#     else:
#         print('Тест не пройден')

# Код написан в ручную, вами, и здесь проверка проводится в автоматическом режиме,
# поэтому, можно сказать, что это полуавтоматический режим тестировния

# Проверим, как это работает на практике.
# Напишем ф-ю для тестирования.
# Передаем список list, функция очищает лист от значений, которые не являются числами и передает данные в виде list

def test_function(list_enter):
    '''
    вход: list
    выход: list, содержащий только числи
    :return:
    '''

    list_temp = []
    i = 0
    while (type(list_enter[i]) == int):
        list_temp.append(list_enter[i])
        i += 1
    return list_temp


list_temp = [1, 2, 3, 'abc']

print(test_function(list_temp))


# Пишем полуавтоматическую ф-ю
def function_test_1():  # на вход ничего не принемает
    list_temp = [1, 2, 3, 'abc']  # ф-я должна вернуть [1, 2, 3]
    list_out = test_function(list_temp)
    if list_out == [1, 2, 3]:
        print('Тест 1 пройден!')
    else:
        print('Тест 1 не пройден!')


function_test_1()  # Запускаем, проверяем - Тест 1 пройден!


# Теперь в той же ф-и допустим ошибку
def function_test_2():
    list_temp = [1, 2, 3, 'abc', 4]  # Добавляем 4 и ф-я должна вернуть [1, 2, 3, 4]
    list_out = test_function(list_temp)
    if list_out == [1, 2, 3, 4]:
        print('Тест 2 пройден!')
    else:
        print('Тест 2 не пройден!')


function_test_2()  # Запускаем, проверяем - Тест 2 не пройден!


# Почему не правильно? Потому что мы в ней использовали цикл while, который, выполняя условие, будет работать до
# первого непопадания и затем прекращает работу.


# Поэтому, используем цикл for
def test_function_2(list_in):
    '''
    вход: list
    выход: list, содержащий только числи
    :return:
    '''

    list_temp = []
    i = 0
    for i in range(len(list_in)):
        if type(list_in[i]) == int:
            list_temp.append(list_in[i])
    return list_temp


# и снова запустим тест
def function_test_3():
    list_temp = [1, 2, 3, 'abc', 4]  # Добавляем 4 и ф-я должна вернуть [1, 2, 3, 4]
    list_out = test_function_2(list_temp)
    if list_out == [1, 2, 3, 4]:
        print('Тест 3 пройден!')
    else:
        print('Тест 3 не пройден!')


function_test_3()  # Запускаем, проверяем - Тест 3 пройден!


# Немного усложним ситуаци.
# Числа в последовательности могут быть не только в числовом виде, но и в виде строки
def function_test_4():
    list_temp = [1, 2, 3, '5', 'abc', 4]  # Добавляем '5' и ф-я должна вернуть [1, 2, 3, 5, 4]
    list_out = test_function_2(list_temp)
    if list_out == [1, 2, 3, 5, 4]:
        print('Тест 4 пройден!')
    else:
        print('Тест 4 не пройден!')


function_test_4()  # Запускаем, проверяем - Тест 4 не пройден!


# Почему не пройден? Потому что ф-я не распознает цифры в текстовом формате

# Исправим ф-ю
def test_function_3(list_in):
    '''
    вход: list
    выход: list, содержащий только числи
    :return:
    '''

    list_temp = []
    i = 0
    for i in range(len(list_in)):
        if type(list_in[i]) == int:
            list_temp.append(list_in[i])
        # на этом этапе надо дать ф-и возможность понять, что передана цифра в виде строки
        elif type(list_in[i]) == str:  # если это строка,
            # дальше делаем проверку с помощью метода isdigit()
            if list_in[i].isdigit():  # если это число в виде строки - isdigit вернет 1(true), если не число - 0(false)
                list_temp.append(int(list_in[i]))  # в случае true - включаем цифру в список c приведением к типу int
    return list_temp


# Делаем проверку
def function_test_5():
    list_temp = [1, 2, 3, '5', 'abc', 4]  # Добавляем '5' и ф-я должна вернуть [1, 2, 3, 5, 4]
    list_out = test_function_3(list_temp)
    if list_out == [1, 2, 3, 5, 4]:
        print('Тест 5 пройден!')
    else:
        print('Тест 5 не пройден!')


function_test_5()  # Запускаем, проверяем - Тест 5 пройден!

# Это пример полуавтоматического тестирования.
# Понятно, что он достаточно наивен.
# Обычно такие задачи решаются с помощью библиотек, таких как pytest и unitest

# --> test_pytest.py
