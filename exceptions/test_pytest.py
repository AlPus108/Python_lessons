# Библиотека pytest
# Эта библиотека сейчас монополист в области тестирования. Весь современный функционал, который есть
# при автоматическом тестировании, в ней реализован.
# Кроме того, данная библиотека имеет возможность выполнять тесты более ранних библиотек, такие как unitest и doctest.
# Библиотека pytest содержит весь возможный функционал, который может быть использован при автоматическом тестировании.
# Эта библиотека сравнительно молодая, в то время, как unitest, например, уже более 20 лет.
# Преимущества pytest:
# - простой
# - функциональный. В коробке идет большое количество киллер фич. Это значит, что его можно гибко настроить под свои
# запросы и требования
# - логичный
# - расширяемый, то есть можно доустанавливать и дозаписывать и это не сложно.
# - умный, может запускать тесты на unitest, doctest
# - код тестов меньше и проще.

# Как установить.
# pytest устанавливается как обычный модуль.
# PyCharm - Settings - Project: название проекта - Python interpretor (это голобальная интерпретаторная система)
# в окне справа ищем pytest. Если его нет, то жмем '+' и ищем pytest в поиске. И затем внизу кнопка 'Install package'.

# Напишем ф-ю с использованием pytest для тестирования простой ф-и.
# Но, нужно понимать, что эта библиотека не ограничивается тестированием каких-то банальных обычных ф-й.
# Она содержит в себе и интегральное тестирование и финальное тестирование, то есть можно проверять API-приложения,
# различные фреймворки, и другие вещи.

# Имеем ф-ю для вычисления числен Фибоначчи
fib_num = lambda n: fib_num(n - 1) + fib_num(n - 2) if n > 2 else 1

# проверяем ее работоспособность, корректно ли она вычисляет последовательность Фибаначчи
print(fib_num(7))  # 5 возвращает 5, 6 - 8, 7 - 13 и тд. То есть, работает.


# Напишем несколько тестов. Здесь мы обойдемся простыми наборами ф-й.
# Наш модуль для тестирования имеет название test_pytest. Это не случайно. Библиотека pytest ищет названия модулей,
# которые начинаются с test. Он понимает, что эти модули содержат какие-то тесты и
# пытается их выполнить при своем запуске.
# Поэтому, все тестировочные модули долны начинаться с префикса test_
# Также, названия всех ф-й для тестирования в модуле должны начинаться со слова test_

# Итак, наша ф-я должна проверять, корректно ли ф-я fib_num вычисляет последовательность Фибаначчи
def test_1_fib_num():
    assert fib_num(6) == 8  # проверяем, возвращает ли эта ф-я при аргументе 6 число 8
    # assert это ключевое слово, оно выполняет выражение, которое идет после него.
    # Если это выражение принимает true, то assert ничего не делает. Если же false - assert укажет где в ф-и ошибка
    # и что она возвращает. В этом преимущество pytest перед полуавтоматическими методами тестирования.
    # Он берет все на себя и выведет все, что нам нужно для анализа ошибки.


# Когда ф-я готова для тестирования, запускаем pytest
# Как запустить pytest.
# Запускается через командную строку PyCharm - в нижней панели вкладка Terminal - набираем pytest
# В коне терминала выводится: сколько процентов теста пройдена и за какое время

# Сделаем еще одни текст. Здесь уже намеренно совершим ошибку
def test_2_fib_num():
    assert fib_num(5) == 8  # при значении аргумента 5 результатом не будет 8


# Получаем вывод:
# exceptions\test_pytest.py F  - F указывает на ошибку
#  def test_2_fib_num():
#
# >       assert fib_num(5) == 8
# E       assert 5 == 8
# E        +  where 5 = fib_num(5)
#
# exceptions\test_pytest.py:54: AssertionError  - строка, где находится ошибка
# ================================== short test summary info =====================
# FAILED exceptions/test_pytest.py::test_2_fib_num - assert 5 == 8
# ================================== 1 failed, 1 passed in 0.38s =================

# Когда он находит разные ф-и с префиксом test_, он понимает, что это два разных теста и проверяет их раздельно,
# что видно в результатах вывода:  1 failed, 1 passed in 0.38s - 1 тест прошел, 1 тест не прошел

# Напишем немного более сложный тест.
# Будем использовать равенство между числами Фибаначчи
# Условие:
# f_{2n} = (f_{n+1}^2 - (f_{n-1})^2  - число фиб-чи с индексом 2n должно ровняться числу фиб-чи с индексом n+1 в кв-те
# минус число фим-чи с индексом n-1 в квадрате.

# Тест
n = 10  # на вход тесту подаем число


def test_3_fib_num(n):
    assert fib_num(2 * n) == fib_num(n + 1) ** 2 - fib_num(n - 1) ** 2  # проверяем, что это выражение выполняется


# Еще одни способ запуска:
# python -m pytest

# Вывод:
#  def test_3_fib_num(n):
# E       fixture 'n' not found
# >       available fixtures: cache, capfd, capfdbinary, caplog, capsys, capsysbinary, doctest_namespace, monkeypatch,
#         pytestconfig, record_property, record_testsuit
# e_property, record_xml_attribute, recwarn, tmp_path, tmp_path_factory, tmpdir, tmpdir_factory
# >       use 'pytest --fixtures [testpath]' for help on them.
#
# C:\Users\Lenovo 330s\PycharmProjects\Python_lessons\exceptions\test_pytest.py:85

# Тест не пройден, так как переменная n была вне ф-и.

# Исправляем

def test_4_fib_num():
    n = 10  # на вход тесту подаем число
    assert fib_num(2 * n) == fib_num(n + 1) ** 2 - fib_num(n - 1) ** 2  # проверяем, что это выражение выполняется

# и запускаем снова
# Тест пройден