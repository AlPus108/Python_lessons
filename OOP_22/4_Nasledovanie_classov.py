# В ООП есть три главных принципа:
# - полиморфизм
# - наследование
# - инкапсуляция

# ИНКАПСУЛЯЦИЯ
# Каждый класс состоит из методов и переменных.
# Но, бывает частая необходимость реализовывать некоторые ф-и и методы таким образом, что для них пишутся вспомогательные
# методы и переменные. Очевидно, что все эти вспомогательные методы не тербуют доступа пользователя.
# Поэтому для них испльзуют механизмы инкапсуляции - скрытие их от пользователя. Инкапсуляция - скрытие.
# То же самое касается и переменных. Если переменная используется как вспомогательная и не тербует общения с пользователем,
# то переменная также инкапсулируется. Инкапсуляция в Пайтон происходит с помощью нижнего подчеркивания
# перед именем переменной или метода. _var, _method.
# Чтобы скрыть/инкапсулировать до уровня скрытия доступа, необходимо указать не одну, а две "земли": __var, __method
# В Питоне инкапсуляция происходит не на уровне блокировки доступа, а на уровне сокрытия имени. То есть происходит
# переименование переменной или метода и ее просто не видно на уровне кода. Но, фактически, до нее можно добраться.
# Можно посмореть, какое имя присвоил Пайтон этой переменной, например через служебное слово 'dir'


# НАСЛЕДОВАНИЕ КЛАССОВ / Inheritance
# 1 Это одна из важнейших концепций ООП
# Наследование, это принцип, когда при создании классов, один из них испльзуется в качесвте базы.
# Есть также множественное наследование, когда один класс наследуется от нескольких классов.


# Допустим, у нас есть автомобиль
# Он имеет какие-то свойства и методы
class Car:
    wheels_number = 4

    def __init__(self, name, color, year, is_crushed):
        self.name = name
        self.color = color
        self.year = year
        self.is_crushed = is_crushed
        print('Car is created')

    def drive(self, city):
        print(self.name + ' is driving to ' + city)

    def change_color(self, new_color):
        self.color = new_color
        print('Color is changed to ' + new_color)


# Мы хотим создать класс "Грузовик", в котором нам бы так же пригодились методы drive и change_color
# В этом случае мы можем "унаследоваться" от класса Car, то есть - создать потомка от этого класса - Грузовик

# Создаем новый класс
class Truck(Car):  # Для наследования, указываем в круглых скобках класс, от которого наследуемся --> 1/2 ↓

    # -> 2
    # переопределяем свойство класса-предка, указав его в классе-наследкнике
    wheels_number = 6  # --> 3↓

    # -> 1/2
    # в методе init нового класса нам нужно вызвать метод init класса-предка
    # и указать в нем такие же аргументы, что и у предка.
    def __init__(self, name, color, year, is_crushed):
        Car.__init__(self, name, color, year, is_crushed)  # те же аргументы передаем и сюда
        print('Truck is created')

    # То есть, когда мы будем создавать объект класса Truck, мы будем передавать данные для аргументов в скобках,
    # и сразу же будет инициализироваться объект класса-предка, у которого также будут инициализированы эти же
    # аргументы в скобках. --> 1/3 ↓

    # -> 4 Переопределим метод класса-предка drive() для класса-наследника
    def drive(self, city):  # Это будет то же название с теми же параметрами
        print('Truck', self.name + ' is driving to ' + city)  # но адаптируем текст под Грузовик  --> 5↓

    # -> 6 Создаем метод класса Truck "Погрузить груз". Его нет в классе-предке Car
    def load_cargo(self, weight):
        print('The cargo is loaded. Weight is ' + str(weight) + ' kg')  # Вызываем метод для грузовика --> 7↓


# -> 1/3
# Создаем объект класса Truck
man_Truck = Truck('Man', 'white', 2015, False)

# При запуске кода, получаем оба сообщения:
# Car is created
# Truck is created
# Потому что при создании объекта класса-наследника Truck, создается и объкт класса-предка Car,
# в котором и вызывается этот метод print()
# После создания объекта класса-предка, идет код метода init самого класса-наследника,
# в котором также выполняется метод print()
# То есть, сначала создается объект класса-предка, вызываесят его init и затем выполяется код метода init наследника.
# И теперь мы имеем доступ к методам класса предка, которые в нем хранятся, хотя мы их не определяли в классе-наследника
# В этом вся прелесть.
# Если мы наберем имя наследкики и поставим после него точку, нам будет выдан список доступных методов,
# в числе которых будут методы класса-предка, а также все его атрибуты.

man_Truck.drive('New York')
# Man is driving to New York
# Видим, что метод класса предка вполне корректно работает для оъекта класса-потомка,
# хотя мы его не определяли в классе потомка. Мы наследуем его от класса предка.

# Также мы имеем доступ к свойствам уровня Класса-предка в классе-потоке.
print(man_Truck.wheels_number)  # получаем 4
# Но, обычно у грузовиков больше колес. Как же нам сделать, чтобы у нашего грузовика было 6 колес?
# Для этого мы можем переопределить свойство класса-предка, указав его в классе-наследкнике с таким же названием.-> 2↑

# -> 3
# И теперь, если мы перезапустим тот же код
print(man_Truck.wheels_number)  # мы получим при выводе 6
# То есть, наследование предоставляет возможность наследовать какие-то атрибуты и методы от класса-предка потомку,
# а также переопределять атрибуты и методы для потомка.
# Давайте переопределим метод класса-предка drive() для класса-наследника --> 4↑

# -> 5
# Теперь запускаем код
print(man_Truck.drive('New York'))
# получаем на выходе: Truck Man is driving to New York
# То есть, если метод переопределен в классе, то вызывается уже метод потомка, а не метод предка.
# Если же он не переопределен, то вызывается метод предка.
# К примеру, вызовим для грузовика непереопределенный метод change_color()
# Но, перед этим проверим его текущий цвет
print(man_Truck.color)  # white
# Меняем цвет
man_Truck.change_color('red')  # Color is changed to red
# Выводим новый цвет
print(man_Truck.color)  # red
# То есть, мы можем пользоватся методами предка не переопределяя их.

# Также, мы можем создавать в классе-наследнике свои собственные методы, которых нет в классе предка.
# Давайте создадим такой метод --> 6↑

# 7
# Вызываем метод для грузовика
man_Truck.load_cargo(2000)
# The cargo is loaded. Weight is 2000 kg

# Идея в том, что когда вы создаете наследника какого-то класса, вы можете пользоваться всеми атрибутами и методами
# класса-предка в классе-наследнике в старом виде или можете их переопределять.
# То есть, для атрибутов можете присваивать новые значения, а методы могут принимать другую функциональность.
# Также, можете создавать свои методы, которых нет в классе-предке.
# В этом заключается суть концепции наследования в ООП


# 8
# ПОЛИМОРФИЗМ / Polymorphism
# ПОЛИ - много, МОРФО - форма
# Это множественное использование класса. Это когда один класс наследуется многими классами.
# Например, класс Animal наследуется классами Cat, Dog, Mouse. Это и есть техника полиморфизма,
# Когда один класс используется для создания множества классов.
# Мы уже использовали это свойство, когда переопределяли метод drive() для Truck
# Мы изменили метод drive, который есть в классе-предке. В классе-наследнике этот метод выводит дополнительно
# слово Truck.
# То есть, когда методы с одинаковыми названиями и одинаковыми параметрами ведут себя по разному. Это полиморфизм.

# Для пояснения этой концепции создадим три простых класса -- > 9↓

# -> 10
# Создаем общий класс для наших классов животных
class Animal:
    # и мы можем поместить в этот класс такие же методы, как у всех классов-неследников
    # Имя животное иметь может
    def __init__(self, name):
        self.name = name

    # но как животное может говорить? Животное, это абстракция, а не конкретный объект.
    # Собака лаит, мышь пищит, а Животное, это обобщающий астрактный класс.
    # В таких абстрактных классах нет конкретой реализации методов.
    def speak(self):
        # Чтобы не создавать такую реализацю метода для Animal, здесь мы будем выбрасывать ошибку.
        # Это делается с помощью ключевоо слова raise
        raise NotImplementedError('Class successor must implement this metod')
    # При вызове этото метода на уровне наследкника, будет выдаваться ошибка:
    # "Класс-наследник должен имплементировать этот метод"
    # То есть, эта ошибка предупреждает о том, что мы не имплементировали (не прописали) метод в классе-потомке.
    # И далее во все ниже созданные классы мы в скобках вставляем Animal, что означает, что они
    # наследуются от этого класса
    # Когда мы запустим код, --> 11↓


# 9
# Создаем простые классы
class Dog(Animal):
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' is saying woof!')


class Cat(Animal):
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' is saying meow!')


class Mouse(Animal):
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(self.name + ' is saying pee-pee-pee!')


class Fish(Animal):
    def __init__(self, name):
        self.name = name

    # Так как рыба не умеет говорить, то и метод speak для него закомментирован
    # def speak(self):
    #     print(self.name + ' is saying pee-pee-pee!')  --> 8/1

    # -> 12
    # Поэтому мы для рыбы раскомментируем этот метод и изменим надпись
    def speak(self):
        print(self.name + ' is saying nothing')


# Запускаем код и ошибка больше не выбрасывается. --> 13 (в конце)

# 8/1
# Создаем объекты этих классов

spike = Dog('Spike')  # собака с именем Спайк
tom = Cat('Tom')  # кот с именем Том
jerry = Mouse('Jerry')  # мышь
freddy = Fish('freddy')  # рыба

# Дальше создаем список домашних животных и включаем туда наших питомцев

pet_list = [spike, tom, jerry, freddy]

# В цикле мы можем обращаться к переменной pet
for pet in pet_list:
    pet.speak()  # и будем вызывать для этой переменной метод speak()
    # Вывод:
    # Spike is saying woof!
    # Tom is saying meow!
    # Jerry is saying pee-pee-pee!
    # Вызываются три разных метода, хотя используется одна переменная pet
    # Когда в цикле туда попадает объект spike - он лает, а когда tom - он мяукает.
    # Мы можем создавать сколько угодно различных классов. И, если они реализуют один и тот же метод,
    # то, если мы помещаем в одну и ту же переменную различные объекты, вызывается метод именно этого класса.


# Также, мы можем создать какую-то ф-ю, в которую мы будем передавать какое-то животное.

def pet_voice(pet):  # Метод принимает на вход какое-то животное
    pet.speak()  # и для этого животного вызывает метод speak


pet_voice(spike)
pet_voice(tom)
pet_voice(jerry)
pet_voice(freddy)  # рыба не умеет говорить, поэтому в ее объект не имплементирован этот метод.


# Spike is saying woof!
# Tom is saying meow!
# Jerry is saying pee-pee-pee! ---> 8/2

# -> 11
# то эта ошибка выскочет для freddy - fish, так как в этом классе не прописан этот метод
# NotImplementedError: Class successor must implement this metod
# Рыба не умеет говорить.
# Получив такое сообщение об ошибке, разработчик понимает, что если он хочет унаследоваться от этого
# абстрактного класса Animal, то он должен обязательно инплементировать метод speak в данный класс-потомок. --> 12↑

# 8/2
# Но, для того, чтобы использовать полиморфизм, мы должны быть уверены точно, что в этом классе есть этот метод.
# Иначе мы получим ошибку.
# Поэтому обычно классы, которые имеют один и тот же метод и которые можно сформировать в одну группу,
# они наследуются от какого-то класса-предка.
# Например, у всех этих наших классво, может быть общий класс animal --> 10

# 13
# Полсе имплементации метода speak в класс fish, получаем вывод метода: freddy is saying nothing
# Ошибки нет.

# В реальных приложениях часто можно встретить полиморфизм. Например, мы можем встреить такую ситуацию,
# что нам нужно создать класс для открытия файла. Мы можем создать какой-то абстрактный класс с методом open_file()
# и создать затем подклассы этого класса, в которые мы будем имплементировать этот метод open_file()
# для каждого конкретного вида файла: pdf, txt, аудио, видео.
# То есть, для каждого файла нужна будет какая-то своя реализация этого метода, чтобы открыть этот файл. --> 14


# -> 14
# МНОЖЕСТВЕННОЕ НАСЛЕДОВАНИЕ
# В других языках программирования (Джава, Си-шарп) нет множественного наследования. В них класс может унаследоваться
# только от одного класса-предка. Но, в тех языках существует такая концепция, как Интерфейс.
# Интерфейсы чем-то схожи с классами. В этих языках существует возможность унаследоваться от нескольких интерфейсов.
# То есть, существует возможность множественного наследоваия от интерфейсов.
# В Пайтеоне нет интерфейсов, но в нем существует множественное наследовани от разных классов.
# Как это можно использовать?
# Допустим, мы разрабатываем игру и персонажи игры обладают различными способностями. Некторые одинаковыми,
# некоторые разными - комбинациями разных способностей. Например, способность плавать.
# Класс так и назовем

class Swimmable:
    def __init__(self, name):
        # 19/3
        # делаем распечатку для ф-и init
        print('Метод init() для Swimmable')  # --> 20 ↓ в конец

        self.name = name

    def greeting(self):
        print(f'Привет! Меня зовут {self.name} и я могу плавать')  # --> 14/1 ↓

    # 17
    # Добавляем метод, который присущ только классу Swimmable
    def sweem(self):
        print('Я плыву!')
    # Добавляем такие методы другим классам также  --> 17/1

#  -> 15
#  Создаем еще один класс
class Walkable:
    def __init__(self, name): # -> 15/1
        # -> 19/2
        # делаем распечатку для ф-и init
        print('Метод init() для Walkable')  # --> 19/3 ↑

        # -> 15/1
        self.name = name
    # -> 17/1
    def greeting(self):
        print(f'Привет! Меня зовут {self.name} и я могу ходить')  # Здесь он говорит, что может ходить. -> 17/2 ↓

# 17/1
# Метод, присущий только классу Walkable
    def walk(self):
        print('Я гуляю!')
#  --> 17/2

# -> 15/2
# И еще один класс
class Flyable:
    def __init__(self, name): # -> 15/3
        # 19/1
        # делаем распечатку для ф-и init
        print('Метод init() для Flyable')  # --> 19/2 ↑

        # -> 15/3
        self.name = name
    # -> 17/2
    def greeting(self):
        print(f'Привет! Меня зовут {self.name} и я могу летать')  # Здесь он говорит, что может летать. # -> 17/3

    # 17/3
    def fly(self):
        print('Я лечу!')
    # И теперь Джейм имеет доступ ко всем этим способностям --> 18


# -> 15/4
# Далее создаем сам персонаж игры и унаследуем его сопосбности от выше созданных классов
class GameCharacter(Swimmable, Walkable, Flyable):  # унаследованные классы перечисляются через запятую.
    # И теперь наш персонаж будет иметь все эти способности. Это и сесть множественное наследование.
    def __init__(self, name): # -> 15/5
        # 19
        # делаем распечатку для ф-и init
        print('Метод init() для GameCharacter')  # --> 19/1 ↑

        # -> 15/5
        self.name = name
        # и теперь нам нужно вызвать ф-ю __init__ унаследованных классов
        Swimmable.__init__(self, name)
        Walkable.__init__(self, name)
        Flyable.__init__(self, name)

    # def greeting(self):
    #     print(f'Привет! Меня зовут {self.name}')  # Здесь он просто представляется.  --> 16


# -> 14/1
# Далее создаем объект этого класса
james = Swimmable('James')  # Здесь Джеймс принадлежит классу Swimmable

# Затем вызываем метод класса
james.greeting()
# Привет! Меня зовут James и я могу плавать

# Но, Джаймс может не только плавать, но он может и ходить. Поэтому создадим еще один класс --> 15 ↑

# -> 16
# Теперь Джеймса сделаем принадлежащим классу GameCharacter
james = GameCharacter('James')  # Здесь Джеймс принадлежит классу Swimmable
# И что же теперь выведется, когда мы вызовем метод greeting()?
james.greeting()  # Привет! Меня зовут James.
# Сработал метод, который находится в классе GameCharacter, не смотря на то, что есть одноименные методы во всех
# классах-предках. Но, если такой же одноименный метод указан с такими же параметрами в классе-наследнике,
# то этот метод переопределяется и вызывается уже версия класса-наследника.

# Но, что будет, если мы уберем этот метод из класса-наследника?
# Мы унаследовались от трех классов и в каждом из них есть этот метод greeting(). Так какой же из них сработает?
# Привет! Меня зовут James и я могу плавать
# Срабатывает метод класса Swimmable, так как при наследовании, он стоит на первом месте в списке.
# class GameCharacter(Swimmable, Walkable, Flyable):

# В каждом классе мы можем добавить методы, которые присуще только этом классу.
# В класс Swimmable добавим метод, который присущ только ему --> 17 ↑

# 18
# Добавляем Деймсу новые сопобности
james.sweem()  # Я плыву!
james.walk()  # Я гуляю!
james.fly()  # Я лечу!

# Но, если сейчас мы выведем метод greeting()
james.greeting()
# то получим при выводе: Привет! Меня зовут James и я могу плавать
# Почему плавать?
# Давайте сейчас проверим при помощи встроенный в Пайтон ф-и isinstance(), какому классу принадлежит объект james.
print(isinstance(james, Walkable))  # первым параметром указываем объект проверки, вторым - класс
# Является ли объект james объектом класса Walkable?
# получаем True
# Также проверим и на принадлежность к остальным классам
print(isinstance(james, Swimmable))
print(isinstance(james, Flyable))
print(isinstance(james, GameCharacter))
# Во всех случаях получаем True
# Но, ради эксперемента проверим, является ли james объект класса Словарь
print(isinstance(james, dict))  # False
# Это, определенно, не объект класса Словарь.

# Также в Пайтоне существует общий класс, называемый Object
# Все типы данных в Пайтоне являются объектами этого общего класса.
print(isinstance(james, object))  # True

# Возьмите любой объект любого типа и проверьте его на принадлежность к классу Object
print(isinstance(5, object))  # True
print(isinstance(0.2, object))  # True
print(isinstance('sdfdsf', object))  # True
print(isinstance((2, 3), object))  # True
print(isinstance([1, 2, 3], object))  # True
# Для любых объектов Пайтон класс Object является общим классом языка Пайтон

# Но, почему же тогда, вызывая метод greeting(), мы получаем на выходе: Привет! Меня зовут James и я могу плавать
# из класса Swimmable ?
# Давайте в ф-и init в каждом классе распечатаем то, что срабатает в init именно этого класса. --> 19 ↑

# 20
# Создаем просто объект james и смотрим, какие именно методы init сработают
james = GameCharacter('James')
# Метод init() для GameCharacter
# Метод init() для Swimmable
# Метод init() для Walkable
# Метод init() для Flyable

# Первым срабатываем init класса GameCharacter и затем остальные
# То есть, они выводятся в том же порядке, в котором вызываются для инициализации их init в классе GameCharacter
# Снова запустим метод greeting
james.greeting()  # Привет! Меня зовут James и я могу плавать
# Видим, что метод запускается из класса Swimmable
# Потому что этот метод прописан первым при множественном наследовании класса GameCharacter
# class GameCharacter(Swimmable, Walkable, Flyable):

# Вот такое запутанное поведение класса-наследника при множественном наследовании.
# Но этот прием множественного наследования очерь рекдо испльзуется в Пайтон.
# Сейчас мы его рассмотрели, чтобы понять, что это возможно делать и как это работает.
# Но, на самом деле, вы даже не обязаны вообще использовать ООП.
# Если вам удобно использовать классы, например, для объединения каких-то данных в одну сущность,
# вы можете это делать. Но, вы можете объходиться и без объектов. Можно обходится простыми функциями языка Пайтон
# То же касается и множественного наследования. Его не нужно испльзовать, если оно усложняет ваш код.
# Код должен быть как можно намного проще для того, чтобы другие программисты и вы сами могли понять вашу логику.
# Но, вы должна знать, что такая возможность есть и вы, в каких-то ситуациях можете использовать принцип
# множественного наследованмя и вообще ООП в своем коде.


# Дальше рассматривается прядок в котором Пайтон определяет,
# какой метод все же надо испльзовать при Множественном неследовании.
# Итак, бывают ситуации, когда класс-наследник имеет метод, который присутствует в нескольких класса-предках.
# Но, те классы-предки могут быть унаследованы от других 2-3-х классов своих предков, а те еще от каких-то других.
# И может возникнуть ситуация, что у всех этих классов может быть одноименный метод.
# То есть, ситуация становится достаточно запутанной.
# И сейчас мы разберемся, как не запутаться в этой ситуации и как определить,
# какой метод в какой очередности будет срабатывать.

# Создаем вкладку Method Resolution Order (MRO) и переходим в нее.


