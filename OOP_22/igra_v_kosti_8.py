# Игра в кости-2. Усложняем предыдущий код

# Импортируем из предыдущего кода модуль Dice
from random import random

from Python_lessons.OOP_22.igra_v_kosti_7 import Dice


# Создаем новый класс и наследуем его от импортируемого класса Dice

class Dice_dif(Dice):
    '''
    Усложняем игру
    Допишем режимы игры в кости. Создадим разные условия на успех:
    1 - сопадеине двух цифр как неупорядоченая пара
    2 - совпадение хотя бы одного значения
    3 - совпадение суммы
    '''

    # Усложняем ф-ю init, так как появляются режимы игры
    def __init__(self, N, type):  # кроме параметра N добавляем параметр type - тип игры
        super().__init__(N)  # чтобы вызвать init предыдущего класса, воспользуемся методом super()
        # через метод super() происходит обращение к родительскому классу
        # Далее записываем то, что хотим поменять
        self.type_game = type

        # Далее меняем ф-ю бросания кости. Копируем ее из Родителя и вставляем сюда.
        # Если вы меняете ф-ю, которая была в классе родителя, она будет действовать уже в переписанном сценарии.

    def throw_daces(self):  # здесь метод родителя уже не работает, переписываем его на новый ↓
        dice_1 = random.randint(1, 6)  # первая кость
        dice_2 = random.randint(1, 6)  # вторая кость
        self.current_throw += 1  # считаем количество попыток

        if self.current_throw > self.throw_num:  # если кол-во попыток превышают установленное значение попыток
            raise Exception('Вы привысили количество попыток')  # выбрасываем исключение

        # В завасимости от типа совпадения, у нас могут быть разные сценарии, поэтому прописываем дополнительные if
        if self.type_game == 1:  # Тип игры: 1 - если совпало одно значение
            if {dice_1, dice_2} == {self._hidden_num_1, self._hidden_num_2}:
                return True
            else:
                return False
        elif self.type_game == 2:  # Тип игры: 2 - если совпадение в какой-то из двух пар чисел
            if (dice_1 in {self._hidden_num_1, self._hidden_num_2}) or (
                    dice_2 in {self._hidden_num_1, self._hidden_num_2}):
                print('Попытка: ', dice_1, dice_2)  # выводим пару выигрышных комбираций
                return True
            else:
                return False
        elif self.type_game == 3:  # Тип игры: 3 - если совпадают суммы
            if dice_1 + dice_2 == self._hidden_num_1 + self._hidden_num_2:
                print('Попытка: ', dice_1, dice_2)  # выводим пару выигрышных комбираций
                return True
            else:
                return False

        # Возможно, здесь было бы эффективней реализовывать этот код с помощью полиморфизма.
        # То есть создать не один класс с проверкой трех условий, а три разных класса
        # Но, в качестве учебного примера мы сделали таким образом


# Далее создаем объект класса

if __name__ == '__main__':
    dice_game = Dice_dif(3, 2)  # новому объекту указываем два параметра: количество бросков, тип игры
    dice_game.set_hidden_numbers()  # получаем скрытые случайные значения
    print(dice_game._hidden_num_1, dice_game._hidden_num_2)

    for i in range(4):
        try:
            print(dice_game.throw_daces())
        except:
            print('Игра закончена')
