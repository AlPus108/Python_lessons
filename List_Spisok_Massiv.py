from functools import reduce

# СПИСОК / LIST - упорядоченная последовательность объектов, которые указываются в квадратных скобках
# Еще их называют коллекциями или типом данных, который содержит набор элементов.
# Это наиболее часто используемый тип данных.
List = [0, 1, 2, 3, 4, 5]

# В отличии от строк, списки имеют изменяемый тип данных. Это универсальный инструмент для хранения любого вмда объектов
# В листе могут храниться абсолютно любые объекты и даже разных типов. Даже сами Листы в Листе могут храниться.


# Доступ к объектам Листа осуществляется также по индексу

List[0] = 0
List[1] = 1
List[2] = 2
List[3] = 3
List[4] = 4
List[5] = 5
# В отличии от Строк, в Списки можно вносить любые изменения без создания нового Списка.
List[1] = 'hi'
print(List)  # Вывод: [0, 'hi', 2, 3, 4, 5]

# У Листов также предусмотрены срезы (также, как и у строк)

List[0:] = [0, 1, 2, 3, 4, 5]
List[:] = [0, 1, 2, 3, 4, 5]
List[2:4] = [2, 3]
List[1:3] = [1, 2]
List[:4] = [0, 1, 2, 3]
# Рещультаты слайсинга можно сохранить в другую переменную с типом List или вывести на экран.

# Очень классная вещь в Питоне, это генераторы списков
# Они имеют следующую конструкцию:
# [x**2 for x in num if x > 0]
# где:
# x**2 - выражение, результат которогор будет выведен на экран,
# х - значение, для которого осуществяется перебор в массиве num
# if x > 0 - условие
# здесь делается сразу и отсев (условие) и фильтрация и применение функции

# ----------------------- Генерация списка -------------------------
# Генерируется с помощью квадратных скобок
list_temp = []  # - пустой список
# проверим тип этого объекта
print(type(list_temp))  # на выводе получаем тип класса, к которому принадлежит объект

# Список можно заполнять любыми объектами. Это делается через запятую
list_temp = [1.2, 123, 'Volvo', [1, 2, 3]]  # Здесь типы: float, int, string и даже список в списке
print(list_temp)
# Получаем вывод:
# [1.2, 123, 'Volvo', [1, 2, 3]]

# Пройдемся по элементам в списке
for el in list_temp:
    print(el, type(el))
# Здесь выводим каждый элемент на отдельной строке с указанием его типа
# 1.2 <class 'float'>
# 123 <class 'int'>
# Volvo <class 'str'>
# [1, 2, 3] <class 'list'>
# Таким образом мы инициализировали Список

# Также, список можно инициализировать с пмощью команды list
list_str = list('Volvo')  # Делаем список из строки. Это похоже на приведение типов
print(list_str)  # Получаем отдельные элементы списка ['V', 'o', 'l', 'v', 'o']

# --------------- Обращение к элементам списка. Подсписки ----------------------

for i in range(len(list_temp)):
    print(i, ':', list_temp[i])  # обращаемся к каждому элементу списка
# получаем следующий вывод
# 0 : 1.2
# 1 : 123
# 2 : Volvo
# 3 : [1, 2, 3]

# Также можно делать срезы
# Сделаем это в цикле, чтобы охватить все срезы
print('Срез с i-го элемента до конца')
for i in range(len(list_temp)):
    print(i, ':', list_temp[i:])  # срез с i-го элемента до конца
# Получаем вывод:
# 0 : [1.2, 123, 'Volvo', [1, 2, 3]]  # получили весь список
# 1 : [123, 'Volvo', [1, 2, 3]]  # отрезали первый элемент
# 2 : ['Volvo', [1, 2, 3]]  # отрезали второй элемент
# 3 : [[1, 2, 3]]

print('Срез с начала до i-го элемента')
for i in range(len(list_temp)):
    print(i, ':', list_temp[:i])  # срез с начала до i-го элемента
# Получаем вывод:
# 0 : [] # получили пустой список
# 1 : [1.2]  # получили первый элемент
# 2 : [1.2, 123]  # и т.д.
# 3 : [1.2, 123, 'Volvo']

# -------------------------- Функции со списками -------------------

# print(len(list_temp)) # ф-я len() является универсальной.
# Она передает длину любого объекта, который имеет такой атрибут


# ------------------------ Операции со списками -------------------

# #  Это конкатинация двух списков (+)
print("Конкатинация двух списков ", list_temp + list_str)
# Результат конкатинации можно передать в новый список
list_new = list_temp + list_str
print("Новый список с результатами конкотинации  ", list_new)
# Вывод: [1.2, 123, 'Volvo', [1, 2, 3], 'V', 'o', 'l', 'v', 'o']

# # Внешнее умножение на целые числа
print("Умножение списка на 2 ", list_temp * 2)

# ------------------------- Методы списков --------------------------

# У Python есть набор встроенных методов, которые вы можете использовать при работе со списками
# Их все можно увидеть в среде разработки, если после названия переменной поствить '.'
# Выпадет ниспадающий список со всеми доступными методами для переменной этого типа.

# --------------------append()	---------------------------
# Добавляет элемент(ы) в конец списка
# Имеем список list_new с результатами конкотинации
# В нем 11 элементов.
# Если попробовать вставить в него новый элемент в конец по индеусу 11 (так как это не занятый индекс),
# последний 10 (нумерация индексов начинается с 0),
# list_new[12] = 'Новый элемент'  # и вывести его на экран
# print(list_new)  # Здесь мы плучим ошибку индекса: IndexError: list assignment index out of range
# Индекс находится за пределами диапазона доступных индексов.
# Для вставки элементов вконец списка используется метод append()
list_new.append('Новый элемент')
print('Добавили новый элемент в конец списка ', list_new)
# Вывд: [1.2, 123, 'Volvo', [1, 2, 3], 'V', 'o', 'l', 'v', 'o', 'Новый элемент']
# Но, если мы хотим добавить элемент не в конец списка, а в средину, для этого существует ф-я insert()

# Если элементов, которые надо вставить, очень много, это можно сделать с помощью цикла
int_list = []  # пустой список
for i in range(10):  # в цикле с каждой итирацией, в пустой список будет добавляться новое число i
    int_list.append(i)
print("Добавили значения в список ", int_list)

# Также можно дальше в Лист добавлять новые значения с помощью этого метода в конец списка
int_list.append(100)
print("Добавили в конец списка значение 100 ", int_list)
int_list.append(200)
print("Добавили в конец списка значение 200 ", int_list)

# В один список мы можем добавлять разные структуры данных с разными типами значений.
# Это может быть лист в листе.
num_List = [45, 12, 4, 6, 8]
let_List = ['s', 'w', 'e', 'e', 't']
num_List.append(let_List)
print('Добавляем Лист в Лист', num_List)
# Вывод: [45, 12, 4, 6, 8, ['s', 'w', 'e', 'e', 't']]

# ------------------------- insert() ----------------------------------
# Добавляет элемент по индексу. Принимает на вход два параметра: индекс, куда будем вставлять
# и значение,  которое будем вставлять
list_new.insert(0, 'start')
print('Добавили элемент в начало списка', list_new)
# Вывод ['start', 1.2, 123, 'Volvo', [1, 2, 3], 'V', 'o', 'l', 'v', 'o', 'Новый элемент']
# Таким образом можно вставлять в любое место списка, указав при этом нужный индекс.
# При этом все значения справа смещаются вправо

# ---------------------------- pop() --------------------------------
# Удаляет элемент ПО ИНДЕКСУ или последний
list_new.pop()  # Если без аргументов, то удаляет последний элемент
print('Удалили из списка последний элемент "Новый элемент" ', list_new)
# Вывод: ['start', 1.2, 123, 'Volvo', [1, 2, 3], 'V', 'o', 'l', 'v', 'o']
# Если же мы хотим удалить какой-то конкретный элемент, мы должны в аргументы этому методу передать
# индекс элемента на удаление. По умолчанию там стоит -1 (индекс последнего элемента)
# Удалим первый элемент
list_new.pop(0)
print('Удалили первый элемент start списка методом pop() ', list_new)
# Вывод:  [1.2, 123, 'Volvo', [1, 2, 3], 'V', 'o', 'l', 'v', 'o']
# Таким образом, через указание индекса можно удалить элемент на любой позиции.

# Метод pop() после своей работы также возвращает удаленный элемент на печать
deleted_item = list_new.pop()  # присваиваем новой переменной результат удаления
print('Выводим на экран удаленный элемент ', deleted_item)  # Последним элементом в списке list_new был 'o'
# Если же мы не хотим получать возвращаемое значение, то можно использовать метод remove()

# -------------------------------- remove() --------------------------
# Удаляет элементы из списка ПО ЗНАЧЕНИЮ. То есть, мы должны указать значение, которое хотим удалить.
# Если есть несколько элементов с одинаковым значением, удаление происходит первого элемента по вхождению.
int_list.remove(100)
print("Удалили из списка значение 100 ", int_list)
# Этот метод ничего не возвращает. Будет выдан результат None

# -------------------------  del() --------------------
# Удаялет элементы ПО ИНДЕКСУ (эквивалентен pop())
del int_list[10]  # удалили элемент со значением 200
print("Удалили из списка значение 200 ", int_list)

# --------------------- reverse() -----------------------
# Разворачивает / выстраивает список в обратном порядке
int_list.reverse()
print("Развернули список в обратном порядке ", int_list)
# Вывод: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

# -----------------------------sort() --------------------
# Сортирует список
# Для демонстрации примера, переинициализируем список с элементами в хаотичном порядке
int_list = [3, 8, 5, 2, 4, 1, 6, 9, 7, 0]
int_list.sort()
print("Сортируем список цифр в продяке возрастания элементов ", int_list)
# Вывод: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Для букв
list_letter = ['d', 'c', 'f', 'a', 'b']
list_letter.sort()
print("Сортируем список букв по алфавиту ", list_letter)
# Вывод: ['a', 'b', 'c', 'd', 'f']

# Метод sort() также не возвращает никакого значения
# Поэтому выражение new_list = list_letter.sort() работать не будет!
# Что же делать, если мы хотим сохранить отсортированный список?
# Да это и не надо делать, так как метод sort() изменяет сам сортируемый лист.

# clear()	Удаляет все элементы в списке
# copy()	Возвращает копию списка
# count()	Возвращает число элементов с определенным значением
# extend()	Добавляет элементы в конец текущего списка
# index()	Возвращает индекс первого элемента с определенным значением


# -------------------------------- Обработка списков ----------------------------

# ------------------------------- map ----------------------------------
# Ф-я, которая применяется к каждому элементу списка
# Конструкция map:
# map(function, list) ---> возвращает тип map ---> который надо привести к типу list(map)

# У нас есть список, который состоит из некоторой последовательности чисел
# int_list = [3,8,5,2,4,1,6,9,7,0]
# Мы можем одной операцией, например, умножить каждое число на какое-то значение или возвети в квадрат
# new_int_list = list(map(str, int_list))  # здесь надо сделать приведение к типу list,
# потому что map возвращает другой тип
# и также в параметрах map делаем приведение к типу str каждый элемент list
# После такой манипуляции, каждый элемент становится строкой
# print("Изначальный список ", int_list)
# new_int_list = list(map(lambda x: x**2, int_list)) # читается с конца
# Лямда позволяет работать с каждым элементом одновременно

# print("Возводим каждый элемент списка в квадрат ", new_int_list)
# получаем на выходе
# ['3', '8', '5', '2', '4', '1', '6', '9', '7', '0']


# int_list = [3,8,5,2,4,1,6,9,7,0] # переинициализируем список для следующего примера, так как в последнем действии
# значения приняли тип str, а к строке не применяется сравнение

# ---------------------------- filter ---------------------------------
# Фильтрация списка согласно некоторому условию
# для демонстрации работы этой функции, здесь придется применить ф-ю Лямбда, которую мы рассмотрим позже
# new_int_list = list(filter(lambda x: x<5, int_list)) # читается с конца
# принимаем на вход список int_list
# дальше проверяем условия для каждого икса x < 5
# Если x < 5, он остается в новом списке
# print(new_int_list)
# получили на выходе [3, 2, 4, 1, 0] - они все меньше 5

# ------------------------------ reduce --------------------------
# Обращается ко всем элементм списка и возвращает одни элемент
integer_list = [1, 2, 3, 4]
# С помощью ф-и reduce найдем сумму элементов данного списка
sum = reduce(lambda x, y: x + y, integer_list)  # x - текущий элемент, у - последующий элемент
print(sum)  # получаем сумму всех цифр массива

# Найдем произведение всех элементов
product = reduce(lambda x, y: x * y, integer_list)  # x - текущий элемент, у - последующий элемент
print(product)

# НОВЫЙ БЛОК ------------------------------------
print()
print()
print()

# Массив или СПИСОК (в Питоне)
# Используются для хранения наборов значений, элементами которых могут быть произвольные значения:
# строки, числа, произвольные объекты, другие списки.
# В рамках одного списка можно комбинировать объекты разных типов.

students = ['Ivan', 'Masha', 'Sasha']
for student in students:
    print('Hello ' + student + '!')

# Доступ к элементам списка происходит с помощью индексов. Список начинается с 0

# Длина списка
print("Длина списка students: ", len(students))

# Отрицательная индексация
print(students[::-1])  # выводим список наоборот
# используем технлогию Slice
print(students[:2])  # выводим два первых лемента списка от начала. Элемент с индексом 2 не включен в вывод
# ----------------------------------------------------


# ----------------------------- ОПЕРАЦИИ СО СПИСКАМИ -----------------------------
# Их две
# Сложение

teachers = ['Oleg', 'Alex']  # складываем с первывм списком
print(students + teachers)  # получаем новый список с объединением двух первых

# Умножение на целое число

print([0, 1] * 4)  # повторяем список 4 раза
# -----------------------------------------------------------
# В отличии от типов данных int, float, str, в которых, чтобы изменить их значение, надо создать новый объект,
# в списках это не так. В них можно явно изменять их значения.
# В списках можно изменить конкретный элемент

students[1] = 'Oleg'  # меняем в списке students элемент с индексом 1
print(students)

# --------------------------------- Добавление новых элементов в список ---------------------------
students.append('Olga')
print(students)
students += ['Olga']  # Список может иметь повторяющиеся элементы
print(students)

students.insert(1, 'Tatyana')  # вставляем элемент в список в позицию под индексом 1 (второй по списку)
# элементы правее сдвигаются вправо

# ------------------------------- Удаление элементов из списка ----------------------------
# Элементы из списка удаляют как по значению, так и по индексу
# ф-я remove удаляет только первое вхождение, если таких элементов несколько.
students.remove('Olga')  # у нас две Ольги, удаляется только первая с начала списка.
print(students)

# для удаления по индексу используется конструкция del
del students[0]  # удаляется первый элемент в списке
print(students)

# ----------------------- Проверка наличия элемента в списке ------------------------------
# Если в списке нет элемента, который обозначен на удаление, программа выдаст ошибку.
# Поэтому перед обращение к элементу для операций с ним, нужно сделать проверку на его присутствие в списке
# Проверка по значению
# с помощью конструкции if...in... if...not in...
if 'Oleg' in students:
    print('Oleg is here!')
if 'Ann' not in students:
    print('Ann is out')

# ------------------------------Проверка по индексу ---------------------------------
ind = students.index('Sasha')  # узнаем значение индекса элемента 'Sasha'. Возвращается первое вхождение
print(ind)

# ------------------------------------- Сортировка списка -----------------------------
# В порядке возрастания
# ф-я sorted() принимает один аргумент. Возвращает значения в возрастающем порядке
ordered_students = sorted(students)  # создаем новый сисок с отсортированными значениями
print(ordered_students)  # список отсортирован по алфавиту

# метод sort()
students.sort()  # меняет непосредственно сам список
print(students)

# ---------------------- Получение максимального значения в списке max() ------------------
print(max(students))

# ------------------------ Получение минимального значения в списке min() ---------------
print(min(students))

# -------------------------------- Вывод списка в противоположном порядке -----------------
# Метод reverse() меняет сам список
students.reverse()
print(students)  # Список изменен
# Ф-я reversed() не изменяет первоначальный список, но выводит элементы в противоположном порядке
reversed(students)
print(students)
# Для применения вышеописанных методов, необходимо условие, чтобы все элементы в списке были сравнимы (одного типа)
# Или с помощью Слайсинга
print(students[::-1])  # выводим список наоборот, начиная с последнего до первого.
# В этом подходе также изначальный список не меняется. Мы получаем новый список

# Используя данные операции, можно постепенно добавлять элементы в список
# Сначала создаем пустой список
# students = []
# и затем в цикле можем добавить в него элементы

# --------------------------------- ОСОБЕННОСТИ СПИСКОВ --------------------------
# То обстоятельство, что списки являются объектами, создает определенные особенности, которые надо учитывать
# при работе со списками.

# Что происходит при присвоении списков?
# Имеем переменную а со списком из 3-х элементов
a = [1, 'A', 2]
b = a  # Присваиваем переменной b значение переменной a
print(a, b)  # При выводе получаем одинаковые значения в обоих переменных
# Добавляем в переменную а первым значением число 42
a[0] = 42
# Выводим значения обоих переменных
print(a, b)  # при выводе видим, что первое значение в переменной b также изменилось, хотя явно мы его не меняли!
# Причина в том, что обе переменные имеют ссылку на один и тот же участок памяти, где хранятся их значения.
# Также мы можем изменять список через перменную b
b[2] = 30
print(a, b)  # значения обоих переменных изменились
# Это надо помнить! Имея переменные с сылками на один и тот же объект,
# меняя значения одной переменной, мы изменяем значения второй!

# ---------------------------------- Генерация элементов в списке -------------------------
# Обычно элементы в список добавляют, получая с клавиатуры или из файла, либо добавляя по одному с помощью цикла
# либо можно использовать специальные конструкции генерации списков

# Конструкция заполения списка одинаковыми элементами
print('Генерация элеметов списка')
a = [0] * 5  # добавляем 5 нулей в список
print(a)

# С помощью конструкции List comprehensive
a = [0 for i in range(5)]  # указываем значение 0, которое будет принимать переменная i в пяти итирациях
# переменная i пробегает все значения от 0 до 4, которым присваивает значение 0
print(a)  # формируется список из 5 нулей

# Сгенерируем список, который создает квадраты целых чисел
a = [i * i for i in range(5)]  # Переменная i пробегает значения от 0 до 4 и каждое значение умножает на его же величину
print(a)

# С этой конструкцией List comprehensive мы уже сталкивлись, когда производили чтение чисел из одной строки
# Это стандартная конструкция, которая позволяет получить и записать в переменную а знечения целых чисел,
# которые находятся в одноЙ строчке и представляют собой строковые значения

# a = [int(i) for i in input("Введите строку из чисел ").split()]
# input() читает строку
# split() разделяет эту стоку по пробельным символам
# и дальше для каждой части мы применяем функцию преобразования строчки в целое число int(i)
print(a)  # получаем список из чисел, которые были записаны в исходной строке

# Пример применения конструкции List comprehensive
# --------------------------------------------------------------------
print(*('_'.join(word) for word in 'programm select one'.split()))
# print(*('_'.join(word) for word in input("Введите слово ").split()))
# --------------------------------------------------------------------


# ВЫПОЛНЕНЕНИЕ ЗАДАЧ

# Напишите программу, на вход которой подается одна строка с целыми числами. Программа должна вывести сумму этих чисел.
# Используйте метод split строки.

# a = [int(i) for i in input("Введите строку из числел с пробелами ").split()]
# x = 0
# for i in a:
#     x += i
# print(x)

# --------------------------------------------------------------

'''
Напишите программу, на вход которой подаётся список чисел одной строкой. 
Программа должна для каждого элемента этого списка вывести сумму двух его соседей. 
Для элементов списка, являющихся крайними, одним из соседей считается элемент, 
находящий на противоположном конце этого списка. Например, если на вход подаётся список "1 3 5 6 10", 
то на выход ожидается список "13 6 9 15 7" (без кавычек).

Если на вход пришло только одно число, надо вывести его же.

Вывод должен содержать одну строку с числами нового списка, разделёнными пробелом.
'''
# Мое решение:

# a = [int(i) for i in input().split()]
# x = 0
# i = 0
# while i != len(a):
#     if len(a) > 1:  # Если введено больше одного значения
#         if i == 0:  # Если находися в первой ячейке
#              x  = a[i+1] + a[-1]  # Сумма следующего и последнего
#              print(x, end=" ")  # Выводим сумму с пробелом
#              i += 1  # Прибавляем счетчик
#         elif i == len(a)-1:  # Если позиция последняя, индекс ячейки равен длине списка -1 позиция
#             x = a[0] + a[i-1]  # Сумма содержимого первой и предпоследней ячейки
#             print(x, end=" ")  # Выводим сумму
#             i += 1  # Прибавляем счетчик
#         else:  # Если не первая и не последняя ячейки
#             x = a[i-1] + a[i+1]  # Прибавляем предыдущую и последующую ячейки (их содержимое) относительно текущей
#             print(x, end=" ")  # Выводим на экран сумму
#             i += 1  # Прибавляем счетчик
#     # elif len(a) == 2:
#     #     x = a[0] + a[0+1]
#     #     print(x, end=" ")
#     #     i += 1
#     #     break
#     else:  # Если введено всего одно число
#         x = a[i]  # Его значение присваиваем переменной х
#         print(x)  # Выводим
#         i += 1  # Прибавляем счетчик


# #Вариант решения 1 (короткий)
# a = [int(i) for i in input().split()]
# if len(a) > 1: # Если длина списка больше 1
# #     for i in range(len(a)):  # range() генерит последовательность от 0 до -1
# #  число итераций в цикле равно числу элементов списка a (Для в вода [1,3,5,6,10]=5)
#         print(a[i - 1] + a[i + 1 - len(a)], end=" ")  # Из первой позиции вычитаем 1 - получаем последнюю (зациклено)
# # python сам "зацикливает" массивы, позволяя брать элементы с отрицательным номерами. Надо только этим пользоваться
# # a[i-1] -получаем значение из списка по индексу. Для первой итерации т.е. i=0  a[i-1] =a[0-1]=a[-1]=10=a[4]
# # a[i+1-len(a)]  при i=0 a[0+1-5]=a[-4]=3=a[1]
# else:
#     print(a[0], end='')

# Необходимо использовать остаток от деления (оператор "%"), чтобы на последней итерации (когда i = len(numbers) - 1)
# вот этот участок кода: numbers[(i + 1)] не вызвал исключения из-за выхода за границы списка.
# Нам необходимо обратиться к соседу справа - по условию задачи это будет первый элемент (под индексом 0).
# Конечно, это проблему можно обойти используя оператор if, но так же красивее)
# print(numbers[i - 1] + numbers[(i + 1) % len(numbers)], end=" ")


# Игра с генератором последовательностей
# x = [int(i) for i in input().split(' ')]  # создаем список, напр [1, 2, 3, 4, 5]
#
# if len(x) <= 1:
#     print(x[0])
# else:
#
#     y = [x[i - 1] for i in range(len(x))]  # массив перестановка вправо [5, 1, 2, 3, 4]
#     z = [x[i] for i in range(-len(x) + 1, 1)]  # массив перестановка влево [2, 3, 4, 5, 1]
#
#     for i in range(len(x)): print(y[i] + z[i], end=' ')  # теперь просто поэлементно сложить


# -----------------------------------------------------------------------
# Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения,
# которые повторяются в нём более одного раза.
#
# Для решения задачи может пригодиться метод sort списка.
#
# Выводимые числа не должны повторяться, порядок их вывода может быть произвольным.

# Sample Input 1:
#
# 4 8 0 3 4 2 0 3
# Sample Output 1:
#
# 0 3 4
# Sample Input 2:
#
# 10
# Sample Output 2:
#
# Sample Input 3:
#
# 1 1 2 2 3 3
# Sample Output 3:
#
# 1 2 3
# Sample Input 4:
#
# 1 1 1 1 1 2 2 2
# Sample Output 4:
#
# 1 2


# # Решение 1 (мое)

# a = [int(i) for i in input().split()]
# n = sorted(a)
# x = 0
# for i in range(len(n)):
#     if n[i] == n[i+1 - len(n)]:
#         x += 1
#     else:
#         if x > 0:
#             print(n[i], sep="", end=" ")
#             x = 0


# # Решение 2 (мое)

# a = [int(i) for i in input().split()]
# n = []  # новый пустой массив
# for i in a:
#     if a.count(i) > 1:  # если значение повторяется
#         if i not in n:  # если его нет в новом массиве
#             n.append(i)  # добавляем в новый массив
# for i in n:
#     print(i, end='')  # выводим массив как стоку


# # Решение 3 (короткое)
#
# ls = [int(i) for i in input().split()]
# for i in set(ls):  # set() возвращает список без повторений (преобразует последовательность в множество)!
#     if ls.count(i) > 1:
#         print(i, end=' ')


# Решение 4 (коткое)

# s = input().split()
# print (*(i for i in set(s) if s.count(i) > 1))  # звездочка(*) склеивает нужные нам i. Алалогично .join


# Решение 5 (Уличная магия)

# str = [int(i) for i in input().split()]
# ans = []
# [ans.append(x) for x in str if x not in ans and str.count(x) > 1]
# print(*ans)  # эквивалентно for i in ans: print(i, end=" ")  # распаковка итируемого объекта

# Строка print(*ans) передаёт все элементы списка ans в вызов print() как отдельные аргументы,
# поэтому нам даже не нужно знать, сколько элементов в списке.
#
# Здесь оператор * — не просто синтаксический сахар.
# Без фиксированной длины списка было бы невозможно передать элементы
# итерируемого объекта как отдельные аргументы, не используя *.

# Но для публичного использования не советуется. Слишком большая концентрация логики и неявного поведения
# на количество строк кода. При необходимости что-то поправить придётся отслеживать аффекты этих изменений.
# Первое правило - не использовать магию в продакшене

# Решение 6

# a = input().split()
# [a.remove(i) for i in set(a)]
# print(*set(a))

# set(a) - дает уникальные значения (без повторов)
# перебираем уникальные значения и удаляем их из входного списка
# в итого у нас остаются только дубли во входном списке
# снова берем set(a) и выводим его, распаковыывая через *

# Решение 7

# x = [int(i) for i in input().split()]
# x.sort()
# i = 0
# while i < (len(x)):
#     if x.count(x[i]) >= 2:
#         print(x[i], end=' ')
#     i += x.count(x[i])

# Отсортировываем.
# Если элемент встречается несколько раз, выводим его на экран
# и перепрыгиваем "вперёд" на столько элементов, сколько он встречается.


# --------------------------- ДВУМЕРНЫЕ СПИСКИ ---------------------------------

# a = [[1,2,3],[4,5,6],[7,8,9]]
#
# 0 -> 1 2 3
# 1 -> 4 5 6
# 2 -> 7 8 9

# Так как саписок а, это просто список, мы можем явно обратиться к любому элементу этого списка

# a[1]
# это будет список их трех элементов
# [4,5,6]
# который тоже является элементом

# Мы можем взять любой элемент из списка с указанием полного адреса
# a[1][1] # Конструкция из двух индексов: 1-й - индекс строки, 2-й - позиция элемента в списке (индекс столбца) = 5

# Генерация (инициализация) двумерных списков

# Генерироват список из одних нулей мы умеем - a = [0]*n
# Чтобы получить n списков из n нулей, мы должны умножить результат на n - a = [[0]*n]*n

# List Comprahance для генерации двумерных списков
# a = [[0]*n for i in range(n)] - для каждого i от 0 до i-1 генерируем список из n-элементов
# создается n списков из n нулей, где каждый из этих списков будет независимым
# Так же для этого можно использовать и вложенные конструкции
# a = [[0 for j in range(n)] for i in range(n)] - внутренняя конструкция создает с помощью генератора
# n список из n нулей и запускаем мы ее n раз (range(n))
# Получаем матрицу из одних нулей
# 0 -> 0 0 0
# 1 -> 0 0 0
# 2 -> 0 0 0


# Алгоритм поиска минимального значения в списке
# s = [int(i) for i in input().split()]  # читаем строку, разбиваем по пробелам
# # и каждый полученый фрагмент преобразовываем в число
# x = s[0]  # переменной х присваиваем значение первого элемента в списке
# for i in s:
#     if i < x:
#         x = i
# print(x)


# ------------------------------------------------------
# Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор,
# пока сумма введённых чисел не будет равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел.
#
# Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0,
# после этого считывание продолжать не нужно.
#
# В примере мы считываем числа 1, -3, 5, -6, -10, 13; в этот момент замечаем, что сумма этих чисел равна нулю
# и выводим сумму их квадратов, не обращая внимания на то, что остались ещё не прочитанные значения.

# Sample Input:
#
# 1
# -3
# 5
# -6
# -10
# 13
# 4
# -8
# Sample Output:
#
# 340


# x = 0
# y = 0
# while True:
#     # s = [int(i) for i in input().split()]
#     s = int(input())
#     x += s
#     y += s*s
#     if x == 0:
#         break
# print(y)

# ------------------------------------------------

# Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ...
# (число повторяется столько раз, чему равно). На вход программе передаётся неотрицательное целое число n —
# столько элементов последовательности должна отобразить программа. На выходе ожидается последовательность чисел,
# записанных через пробел в одну строку.
#
# Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.

# Sample Input:
#
# 7
# Sample Output:
#
# 1 2 2 3 3 3 4

# Мое решение

# n = int(input())
# x = 0
# y = 0
# while x != n and y != n:
#     x += 1
#     i = 0
#     while i != x:
#         i += 1
#         print(x, end=" ")
#         y += 1
#         if y == n:
#             break

# Решение № 2

# n = int(input())
# a = []
# i = 0
# while len(a) < n:
#     a += [i] * i
#     i += 1
# print(*a[:n])  # <звездочка> - это передача в функцию print “неопределенного количества позиционных
# или именованных аргументов“, т. е. нашего списка и означает «распаковать список»
# После завершения цикла список a содержит i раз последнее значение i.
# При этом длина списка уже становится >= n. Поэтому и берется срез.
# Пример:
# При n = 11
# a = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]
# А print(*a[:n]) даст вывод 1 2 2 3 3 3 4 4 4 4 5

# Решение № 3

# n=int(input())
# s=[]
# for i in range(1,n+1):
#     s+=[i]*i
# for i in range(n):
#     print(s[i], end =' ')

# Решение № 4

# s=int(input())
# a=[]
# for i in range(s+1):
#     a+=[i]*i
# print(*a[:s])

# Решение № 5

# n, a = int(input()), []
# for i in range(1, n + 1):
#     a += ([i] * i)
# print(*a[:n])

# Решение № 6

# n,a = int(input()),[]
# [[a.append(i) for j in range(i)] for i in range(n+1)]
# print(*a[:n])

# ----------------------------------------------------------
# РАЗНЫЕ ВАРИАНТЫ ВЫВОДА МАССИВА
# L = [1, 2, 3, 4, 5]
# print(" ".join(str(x) for x in L))

# -------------------------------------------------------

# Напишите программу, которая считывает список чисел lst из первой строки и число x из второй строки,
# которая выводит все позиции, на которых встречается число x в переданном списке lst.
#
# Позиции нумеруются с нуля, если число x не встречается в списке,
# вывести строку "Отсутствует" (без кавычек, с большой буквы).
#
# Позиции должны быть выведены в одну строку, по возрастанию абсолютного значения.

# Sample Input 1:
# 5 8 2 7 8 8 2 4
# 8
# Sample Output 1:
# 1 4 5

# Sample Input 2:
# 5 8 2 7 8 8 2 4
# 10
# Sample Output 2:
# Отсутствует

# Мое решение
# lst = [int(i) for i in input().split()]
# x = int(input())
# s = 0
# for i in range(len(lst)):
#     if lst[i] == x:
#         print(i, end=' ')
#         s += 1
# if s == 0:
#     print('Отсутствует')

# Варинат решения № 1
# l = [int(i) for i in input().split()]
# x = int(input())
# if not x in l: print('Отсутствует')
# for i in range(len(l)):
#     if l[i] == x: print(i, end = ' ')

'''
Чтобы перебрать все элементы списка ( s ), вместо:
for i in range( len( s ) ):
Можно использовать:
for i, item in enumerate( s ):
Получаете сразу номер элемента ( i ) и сам элемент ( item )
#  пример использования ниже
'''

# Вариант решения № 2
# numbers = [int(i) for i in input().split()]
# needed = int(input())
# if needed not in numbers:
#     print("Отсутствует")
# else:
#     [print(i, end=" ") for i, x in enumerate(numbers) if x == needed]  # интересное выражение, читается с конца
# # Последнюю строку можно и так записать
# # print(*[i for i, x in enumerate(numbers) if x == needed])
# но, в последнем варианте вывода, нужно держать в голове что мы создаем лишнюю коллекцию
# и лишь потом её выводим (что не оптимально по памяти).
# Здесь это совсем не принципиально, однако это лучше понимать на будущее
# В первом варианте вывода тоже конечно создается список, только не из функций,
# а из возвращаемых значений функции print (то есть None)

# или еще более короткий вариант
# numbers = [int(i) for i in input().split()]
# needed = int(input())
# if [print(i, end=" ") for i, x in enumerate(numbers) if x == needed] == []:
#     print("Отсутствует")

# Вариант вешения № 3 (короткий вариант)
# l, n = [int(i) for i in input().split()], int(input())
# print(*[x for x in range(len(l)) if l[x] == n] if n in l else ["Отсутствует"])  # читается наоборот

# Вариант вешения № 4 (короткий вариант)
# a,b=input(),input()
# print('Отсутствует' if not b in a else ' '.join([str(i) for i,x in enumerate(a.split()) if x==b]))

# Вариант вешения № 5
# a = [int(i) for i in input().split()]
# # b = int(input())
# # if b in a:
# #     while b in a:
# #         print(a.index(b), end=' ')
# #         a[a.index(b)] = b+1
# # else:
# #     print('Отсутствует')

# или так

# lst = [int(i) for i in input().split()]
# x = int(input())
# if x in lst:
#   for i in lst:
#     if i == x:
#       print(lst.index(i), end=' ')
#       lst[lst.index(i)] = x+1
# else:
#   print('Отсутствует')

# Но, есть один момент. Не оптимально использовать логический оператор "in" для проверки принадлежности
# элемента к списку в условии цикла, так как поиск in в списках выполняется последовательно,
# и в длинном списке будет выполняться очень долго

# Вариант 6
# lst = [int(i) for i in input().split()] # список чисел
# x = int(input())                        # значение для поиска в списке
# # компактный сбор индексов
# indexes = [i for i, v in enumerate(lst) if v == x] # список индексов
#
# if len(indexes) == 0:
#     print('Отсутствует')
# else:
#     print(' '.join(map(str,indexes)))

#  или то же самое, только с более коротким вариантом вывода
# lst, x = map(int, input().strip().split()), int(input())
# idx = [i for i, e in enumerate(lst) if e == x]
# print(*idx) if idx else print("Отсутствует")

# Вариант 7 (Изящое решение)
# a = input().split()
# b = input()
# c = a.count(b)
# if c > 0:
#     for i in range(len(a)):
#         if a[i] == b:
#             print(i, end=' ')
# else:
#     print('Отсутствует')

# Варинат 8
# lst = [int(i) for i in input().split()]
# x = int(input())
# a = []
# for i in range(len(lst)):
#     if lst[i] == x:
#         a.append(i)
# print(*a)
# if a == []:
#     print("Отсутствует")

'''
ЗАДАЧА

Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк, 
заканчивающихся строкой, содержащей только строку "end" (без кавычек)

Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j 
равен сумме элементов первой матрицы на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). 
У крайних символов соседний элемент находится с противоположной стороны матрицы.

Sample Input 1:
9 5 3
0 7 -1
-5 2 9
end

Sample Output 1:
3 21 22
10 6 19
20 16 -1


В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.
Sample Input 2:
1
end

Sample Output 2:
4

'''
'''

n = [int(i) for i in input("Введите последовательность чисел")]
s = input('Если закончили ввод, введите слово end')

x = 0
if s in n:
    for i in range(len(n)):
        x = n.count(i) - 1  # отделяем от последовательности слово end
else:
    print('Если ввод закончен, введите слово end')
print(x)


a = [[0 for j in range(y)] for i in range(x)]


for i in range(x):
    for j in range(y):
    
'''

# multi_elements_list = list('danger!')
# print(multi_elements_list)  # ['d', 'a', 'n', 'g', 'e', 'r', '!']
#
# single_element_list = ['danger!']
# print(single_element_list)  # ['danger!']


# Варианты вывода на печать

# L = [1, 2, 3, 4, 5]
# for i, x in enumerate(L):
#     print(" " if i > 0 else "", x, sep="", end="")
# print()

# Разделеине массива с помощью *
# L = [1, 2, 3, 4, 5]
# print(*L)
# print(*L, sep=', ')
# print(*L, sep=' -> ')

# Если надо объединить строку с чем-то еще, это лучший метод
# joined_string = '!!'.join([str(v) for v in L])  # добавляем пробелы между цифрами или что-нибудь еще
# print(joined_string)

# ---------------------------------------------------------

# ЗАДАЧА
# Выведите таблицу размером n×n, заполненную числами от 1до n ^ 2 по спирали, выходящей из левого верхнего угла
# и закрученной по часовой стрелке, как показано в примере (здесь n = 5):
#
# Sample Input:
# 5
#
# Sample Output:
#
# 1 2 3 4 5
# 16 17 18 19 6
# 15 24 25 20 7
# 14 23 22 21 8
# 13 12 11 10 9


x = int(input())
a = [[0 for j in range(x)] for i in range(x)]
print(a)
