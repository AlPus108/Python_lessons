# Тестирование класса Dice_incap из модуля tst_classa_pytest
# Импортируем модуль

from tst_classa_pytest_4 import Dice_incap
import pytest

# Для теста нам подребуется создать специальный класс

class TestDice_pytest:
    # Далее создаем ф-ю setup()
    # Зачем нужна ф-я setup()? Мы в каждом тесте ниже создаем некоторый объект, который в дальшейшем тестируется.
    # То есть, каждая ф-я содержит в себе одинаковый код. Это дублирование кода. Чтобы этого избежать,
    # в этой ф-и setup() прописываем то, что будет испольняться перед каждой ф-ей.
    # То есть, это некоторая настройка среды перед тестом. Это могут быть укакие-то еще более сложне объкты:
    # подключение к базе денных, установление соединения с сервером или что-то еще. В нашем случае, это
    # создаине объекта Dice_incap. Это и сделаем. В ф-и setup() пропишем создание объекта Dice_incap
    # Сделаем его атрибутом класса TestDice_pytest, то есть пишем через self. Теперь во всем коде мы можем к нему
    # обращаться через self
    def setup(self):
        self.dice_game = Dice_incap(2)  # и в каждой ф-и ниже удаляем созданные ранее объекты dice_game
        print('Start-test:')  # Выводим сообщение о начале теста.

    # Ф-я teardown() - то, что выполняется после завершения тестирования.
    # Это может быть удаление каких-то объектов, очистка памяти или отключение соединения с базой данных или сервером.
    # Но, в нашем случае ничего делать не надо. Просто сообщим о завершении теста.
    def teardown(self):
        self.dice_game.current_throw = 0  # здесь, например, мы можем каждый раз обнулять текущее значение
        # ф-и current_throw
        print('Test has done!')

    # С начала протестируем ф-ю _init_.
    # Мы должны быть уверены, что когда передаем в ф-ю _init_ значение N, ее параметр throw_num принимает ее значение.
    # Конечно, тестировать тут нечего, но сделаем это ради примера.

    def test_init(self):
        # Создаем обект
        # dice_game = Dice_incap(2) - удалили этот объект, так как создали такой же в первой ф-и setup()
        # дальше через ключевое слов assert выполняем тестирование
        assert self.dice_game.throw_num == 2  # проверяем, что throw_num действительно == 2, если нет - вызываем assert
        assert self.dice_game.current_throw == 0  # проверяем, что текущий бросок == 0
        # это самый простой текст для _init_
        # assert dice_game.current_throw == -1 - если вместо 0 поставим -1, будет выдана ошибка.


# Для запуска теста, выполняем команду в копандной строке терминала: pytest

# init протестировали. Дальше протестируем ф-ю сеттера
    def test_dice_setter(self):
        # снова создаем объект
        # dice_game = Dice_incap(3)  - удалили этот объект, так как создали такой же в первой ф-и setup()
        # и сразу присваиваем созданному объекту
        self.dice_game.hidden_num_1 = 5
        self.dice_game.hidden_num_2 = 5
        # делаем условие через логическое 'и', что оба должны быть равны одному числу
        assert (self.dice_game.hidden_num_1 == 5) & (self.dice_game.hidden_num_2 == 5)

        # Видим, что если мы присваиваем число, кторое выходит за пределы установленного диапазона,
        # тогда выбрасываесят ошибка ValueError
        # В тестах мы можем ловить конкретную ошибку для этой ситуации.
        # Для этого в pytest предусмотрен некоторый синтаксис, который мы сейчас изучим.
        # Он очень похож на менеджер контекста

        # Сейчас протестируем ф-ю присванивания при помощи Сеттера

        with pytest.raises(ValueError):  # в скобках указываем ошибку, которую мы пытаемся поймать.
            # Это ValueError. Если напишем другую, например TypeError, то тест не пройдет: Assertion failed
            # и далее идет код, вызывающий ошибку
            self.dice_game.hidden_num_1 = 8  # происходит присваивание значение за пределами диапазона
            # Это одни небольшой момент для отлавливания поведения логики программы

    # Далее напишим ф-ю проверки current_throw, которая считает количество попыток.
    # Она находится в ф-и throw_daces().

    def test_throw_daces(self):
        # также создаем объект
        # dice_game = Dice_incap(3)  - удалили этот объект, так как создали такой же в первой ф-и setup()
        self.dice_game.set_hidden_numbers()
        self.dice_game.throw_daces()  # бросаем кость один раз.
        assert self.dice_game.current_throw == 1  # Теперь current_throw примит значение 1. Это мы и проверяем здесь


