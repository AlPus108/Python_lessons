# СЛОВАРИ
# Это структура данных, которая содержит не упорядоченную последовательность.
# Если в списках элементы упорядочены по индексам, то в Словарях объекты распалагаются в парах: ключ-значение
# Словари напоминают списки, но есть одно принцимпиальное различие: они состоят из ключей и значений.
# Ключ, это тот элемент, по котрому мы получаем значение

dictionaty_list = {'name' : 'Ariel'}  # сначала ключ 'name', потом значение 'Ariel' в фигурных скобках
# ключ является не изменяемым объектом, тогда как значение может быть любым объектом.
# В словаре не моэет быть одинаковых ключей, тогда как их значения могут повторяться (совпадать).
# в качестве значения можно использовать объекты любого типа, в том числе списки и сами словари.
# В словаре доступ к значениям происходит по ключам, тогда как в списках - по индексам.
# Марка автомобиля - ключ, цена автомобиля - значение
car_prices = {'opel': 5000, 'toyota': 7000, 'bmw': 10000}
# Все как в книжном словаре - находим слово(ключ) и получаем его значение.
print('Выводим цены на автомобили', car_prices)  # Вывод {'opel': 5000, 'toyota': 7000, 'bmw': 10000}
# Такая структура данных называется dictionaty / словарь
# Все операции в словаре происходят очень быстро. Это эффективно реализованная конструкция.

# ---------------------- Способы инициализации словарей ----------------------
# 1 Способ
# Словари объявляются (инициализируются) фигурными скобками {}
# dict_temp = {}
# Заполняем словарь ключ-значение
dict_temp = {'dict1': 1, 'dict2': 2.1, 'dict3': 'name', 'dict4': [1,2,3]}
print(type(dict_temp), dict_temp)  # выводим тип словаря и сам словарь

# 2 Способ
# с помощью метода fromkeys()
dict_temp = dict.fromkeys(['a', 'b'])  # dict - указание класса
# Здесь создан словарь, где указаны ключи a и b с пустыми значениями.
print(type(dict_temp), dict_temp)  # получаем на выходе  <class 'dict'> {'a': None, 'b': None}
# для установки значений нужно подать еще один список
dict_temp = dict.fromkeys(['a', 'b'], [12, '2020'])  # dict - указание класса
print(type(dict_temp), dict_temp)  # получаем на выходе  <class 'dict'> {'a': [12, '2020'], 'b': [12, '2020']}

# 3 Способ
# Инициализация словаря с помощью генератора
dict_temp = {a: a**2 for a in range(10)}  # конструкция такая же, как и в списках.
# a - ключ, a**2 - значение, далее конструкция цикла
print('Инициализация с помощью генератора', type(dict_temp), dict_temp)
# получаем на выходе  <class 'dict'> {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

# 4 Способ (редко используется, так как все ключи-значения надо вносить вручную)
dict_temp = dict(brend = 'volvo', price = 5000)
print(type(dict_temp), dict_temp)  # получаем на выходе  <class 'dict'> {'brend': 'volvo', 'price': 5000}


# ----------------------- Обращение к содержимому словаря --------------------------

# Обращение к содержимому происходит по ключу, который указываем в квадратых скобках.
print("Выводим марку автомобиля: ", dict_temp['brend'])  # выводим значение, указывая ключ
print('Выводим цену Тойоты: ', car_prices['toyota'])

# ------------------ Функции со словарями ------------------------------

# Часто необходимо знать все ключи словаря и все значения
# Получим все ключи словаря
print(dict_temp.keys())  # Возвращается специальный тип dict_keys
# на выходе имеем dict_keys(['brend', 'price'])
# Но, как правило, с этим типом не работают. Его приводят к листу:
print(list(dict_temp.keys()))  # на выходе получаем ['brend', 'price']
# И дальше, все операции, которые необходимо проверсти с ключами, делают с типом list

# Значения получают через ф-ю value
print(list(dict_temp.values()))  # на выходе имеем ['volvo', 5000]
# В таком формате вывода,при работе с коючами и со значениями можно использовать все методы, которые имеются в листах.

# Также можно работать с парами ключ-значение. Для этого нужно использовать метод items()
# items() возвращает лист из картежей - пара ключ-значение (Картеж, это тот же самый лист, только неизменяемый)
print(list(dict_temp.items()))  # на выходе имеем [('brend', 'volvo'), ('price', 5000)]

# ------------------------ Работа с элементами ---------------------------------

# Нам необходимо получать значения, изменять их (потому что словарь, это изменяемый тип) и добавлять новые

# Переинициализируем переменную для рассмотрения следующих задач
dict_temp = {a: a for a in range(10)}
print('Переинициализация', dict_temp)  # На выходе: {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}

# МЕНЯЕМ значение.
# Какому-то ключу присвоим другое значение
dict_temp[0] = 100
print(dict_temp)  # на выходе имеем {0: 100, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}
#  Нулевому ключу теперь соответствует значение 100

# ДОБАВЛЯЕМ пары ключ-значение
dict_temp['name'] = 'Alex'  # Создаем новый ключ и присваиваем ему значение.
print(dict_temp)  # Вывод на экран: {0: 100, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, 'name': 'Alex'}
car_prices['mazda'] = 4000
print('Добавление нового Ключа \'mazda\' в список автомобилей: ', car_prices)
# Вывод: {'opel': 5000, 'toyota': 7000, 'bmw': 10000, 'mazda': 4000}
# В словаре можно изменить Значение, но нельзя изменить Ключ
car_prices['opel'] = 2000  # Здесь мы пытаемся добавить элемент с Ключом 'opel', который уже есть в словаре
print('Пытаемся добавить второй колюч \'opel\' в словарь ', car_prices)
# Вывод: {'opel': 2000, 'toyota': 7000, 'bmw': 10000, 'mazda': 4000}
# Но добавления не происходит. Происходит изменение значения старого на новое
# Это способ изменения значения в словаре
# Удаление значений из Словаря происходит при помощи команды del

# ----------------------- мЕТОДЫ СЛОВАРЕЙ ---------------------------------
# У словарей большое количество методов. Какие-то мы уже рассмотрели, это keys(), values(), items()
# C помощью методов словарь можно очищать, копировать, удалять

# -------------------- del -----------------------
# Удаляет значение в словаре по ключу
del car_prices['toyota']
print('Удалиил из списка машин Тойоту ', car_prices)
# Вывод: {'opel': 2000, 'bmw': 10000, 'mazda': 4000}
# Но, с командой del надо быть осторожным. Если вы забудите указать Ключ, значение которого хотите удалить,
# то эта команда УДАЛИТ ВЕСЬ СЛОВАРЬ ВМЕСТЕ С ПЕРЕМЕННОЙ!
# Значение при этом не возвращается. Если нужно получить удаленное значение, тогда надо использовать метод pop()

# --------------------------- pop() ------------------------
# Удаляет значение по Ключу
temp = dict_temp.pop('name')  # удаляем ключ 'name', в месте с ним удаляется и его значение 'Alex'
# При этом он возвращает удаленное ключ-значение через новую пересенную
print(dict_temp)  # Вывод на экран: {0: 100, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}
print(temp)  # Вывод на экран: Alex
# Если такого ключа нет, будет возвращено default без выбрасывания каких-то исключений

# ------------------ clear() ----------------------
# Метод clear() очищает Словарь
car_prices.clear()
print('Очищаем словарь car_prices ', car_prices)  # Вывод: {}


# ------------------------- Многоструктурность словарей -----------------------------

# Словари могут содержать не просто парв Ключ - Значение, но и более сложные структуры,
# как, например, другой Словарь.
# Словари часто используются для описания каких-то объектов.
# Для удобства, их можно записывать в несколько строк
person = {
    'first name': 'Jack',
    'second name': "Brown",
    'age': 23,
    'hobbies': ['footbal', 'singing', 'photo'],  # Список
    'children': {'son': 'Alex', 'daugter': 'Marry'}  # Другой Словарь
}
# Как получить доступ к содержимому этого словаря?
print('Получаем информацию из словаря: возраст человека ', person['age'])  # Вывод: 23
# То есть указываем Ключ и по Ключу получаем его значение.

# Как получить список значений?
print('Получаем Список значений из Словаря ', person['hobbies'])  # Вывод: ['footbal', 'singing', 'photo']
# Здесь получаем весь список, Но, что делать, если мы хотим получить одно из значений в списке?
# Например к последнему - 'photo'? Это можно сделать в два этапа.
# 1 этап - передача списка в новую переменную
hobbies = person['hobbies']  # Передаем в переменную весь список
# 2 этап - получаем значение из переменной по индексу
print('Получаем значение из переменной по индексу', hobbies[2])  # Вывод: photo
# Это можно сделать и более короткой записью
print('Получаем значение из вложенного Списка коротким спосбом ',
      person['hobbies'][2])

# Как получить доступ к вложенному Словарю?
# Также в два этапа:
# 1 этап - объявляем новый Список и присваиваем ему значения из вложенного Словаря
childrens = person['children']  #
# 2 этап - выводим на экран значение, указывая нужное поля из вложенного Словаря
print('Получаем доступ к вложенному Словарю ', childrens['son'])  # указываем объявленную до этого переменную
# Более короткий способ записи:
print('Получаем значение из вложенного Словаря коротким способом ',
      person['children']['son'])

# Добавление данных в Многоструктурный Словарь

person['car'] = 'Mazda'  # добавляем новые Ключ-Значение
print('Выводим на экран весь Многоструктурный Словарь', person)
# Вывод: {'first name': 'Jack', 'second name': 'Brown', 'age': 23, 'hobbies': ['footbal', 'singing', 'photo'],
# 'children': {'son': 'Alex', 'daugter': 'Marry'}, 'car': 'Mazda'}
# в конце добавлена информация о машине.

# Изменение данных в Многоструктурном Словаре

# Допусти, мы хотим поменять информацию во Вложенном Списке - 'footbal' на 'basketbal'
person['hobbies'][0] = 'basketbal'  # получаем доступ к Вложенному Списку и по индексу меняем его значение
print('Меняем значение во Вложенном Списке', person)
# Вывод: {'first name': 'Jack', 'second name': 'Brown', 'age': 23, 'hobbies': ['basketbal', 'singing', 'photo'],
# 'children': {'son': 'Alex', 'daugter': 'Marry'}, 'car': 'Mazda'}

# Еще один метод доступа к Многоструктурному Словарю
print('Получаем список ключей Многостр. Словаря', person.keys())  # С помощью ф-и keys()
# Вывод: dict_keys(['first name', 'second name', 'age', 'hobbies', 'children', 'car'])
print('Получаем список значений Многостр. Словаря', person.values())  # С помощью ф-и values()
# Вывод:
# dict_values(['Jack', 'Brown', 23, ['basketbal', 'singing', 'photo'], {'son': 'Alex', 'daugter': 'Marry'}, 'Mazda'])
print('Получаем список элементов Многостр. Словаря', person.items())  # С помощью ф-и items()
# Вывод: dict_items([('first name', 'Jack'), ('second name', 'Brown'), ('age', 23),
# ('hobbies', ['basketbal', 'singing', 'photo']), ('children', {'son': 'Alex', 'daugter': 'Marry'}), ('car', 'Mazda')])

# Вот такая струтура в скобках ('first name', 'Jack') называесят Tiple - Картеж.

# --------------------- Итерирование по словарю ------------------------------------

# Итерация по Словарям происходит также, как и по Спискам

for pair in dict_temp.items():
    print(pair)

# На выходе получаем список пар ключ-значение:
# (0, 100)
# (1, 1)
# (2, 2)
# (3, 3)
# (4, 4)
# (5, 5)
# (6, 6)
# (7, 7)
# (8, 8)
# (9, 9)

# Также можно итерироваться, работая с комплектными элементами

for key, value in dict_temp.items():  # key - первое значение в паре, value - второе значение в паре
    print(key, value)

# На выходе:
# 0 100
# 1 1
# 2 2
# 3 3
# 4 4
# 5 5
# 6 6
# 7 7
# 8 8
# 9 9

# Можно тем же способом итерироваться по отдельным элементам конструкции
# По ключам:

for key in dict_temp.keys():
    print(key)

# По значениям:

for value in dict_temp.values():
    print(value)


# Операции со значениями
for value in dict_temp.values():
    print(value + 10, end=' ')  # 110 11 12 13 14 15 16 17 18 19
