# Как использовать декоратор для тестирования скорости выполнения какого-то кода

# Мы уже проверяли скорость выполнения кода в разделе Генераторы
# Мы тестировали скорость выполнения суммирования при помощи list и при помощи generator expression
# Тогда мы использовали модуль time

from time import time

# список
start_time = time()
sum([number for number in range(1000000)])
end_time_l = time() - start_time
print(f'Время работы со списком {end_time_l}')

# генератор списков
start_time = time()
sum(number for number in range(1000000))
end_time_d = time() - start_time
print(f'Время работы c декоратором {end_time_d}')

# Каждый раз нам приходится писать один и тот же код для тестироваиня скорости.
# Чтобы это исправить, нам пригодится ф-я декоратор

# Повторим тестирование скорости выполнения кода этих двух выражений, но уже при помощи декоратора
# Создадим ф-ю декоратора
# Для этого импортируем ф-ю wraps

from functools import wraps


# Использование wraps, это хорошая манера написания кода декораторов, чтобы не терялась внутренняя документация ф-й

def speed_test(function):
    @wraps(function)
    def wrapper(*args, **kwargs):  # использование *args и **kwargs также хорошая практика для того,
        # чтобы можно было использовать этот декоратор для ф-й с любыми аргументами.
        started_time = time()
        result = function(*args, **kwargs)
        end_time = time()
        print(f' "По декоратору ": время выполнения кода: {end_time - started_time}')
        return result

    return wrapper


# Теперь мы можем использовать эту ф-ю декоратора для тестирования скорости выполнения любого кода.

# Ф-я складывает всю последовательность чисел из заданного диапазона
@speed_test
def sum_with_list():
    return sum([number for number in range(10000000)])  # c квадратными скобками, это выражение для листа


# запускаем ф-ю с выводом на экран, чтобы увидеть результат выполнения ф-и
print(sum_with_list())


# Время выполнения кода "по декоратору "1.5121326446533203
# 49999995000000  - сумма


# То же самое теперь с генератором
@speed_test
def sum_with_gen():
    return sum(number for number in range(10000000))  # здесь просто убираем квадратные скобки и получаем генератор


# запускаем ф-ю с выводом на экран, чтобы увидеть результат выполнения ф-и
print(sum_with_gen())


# Время выполнения кода "по декоратору "2.0706677436828613
# 49999995000000

# Почему-то с выражение декоратора у меня время больше, чем слистом, хотя должно быть наоборот.


# Таким образом мы можем создать любую ф-ю
# Ф-я перемножения всех цифр заданного диапазона
@speed_test
def product(range_value):
    result = 1
    for number in range(1, range_value):  # диапазон начинается с 1, иначе результатом будет 0
        result *= number
    return result


print(f'Произведение всех чисел диапазона {product(10000)}')
# "По декоратору ": время старта: 1587385837.6306536, время оконочания: 1587385837.682657,
# время выполнения кода: 0.05200338363647461
# Произведение всех чисел диапазона 284625968091705451890641321211986889014805140170279923079417999427441134000376444
# 37729907867577847758158840621423175288300423399401535187390524211613827161748198241998275924182892597878981242531205
# 946599625986706560161572036032397926328736717055741975962099479720346153698119897092611277500484198845410475544642442


# Суть в том, что этот декораторский тест теперь можно применять к любой ф-и для измерения времени выполнения этой ф-и.
# Это пример из реальной жизни, который можно применять на приктике.
