# Декораторы с аргументами

# До этого мы создаввали декораторы, которые не принимают никакие аргументы.
# Но, возможны ситуации, когда нам нужен будет декоратор с аргументами.

# Создадим декоратор, который будет проверять первый аргумент задекорированной этим декоратором ф-и.
# Если этот аргумент не будет равен какому-то нужному значению, то он будет выводить этот декоратор на экран.

from functools import wraps


# Создаем декоратор
def check_if_first_arg_is(value):
    # чтобы создать декоратор с аргументом, нам нужен еще один дополнительный слой внутри декоратора,
    # мы должны создать еще одну внутреннюю ф-ю, которая в свою очередь будет принимать ф-ю в качестве параметра,
    # которую мы будем декорировать. Так как внешняя часть декоратлра принимает значение, которое мы будем проверять.
    def inner_dec(func):  # внутренняя ф-я, это по сути внутренний декоратор, который уже принимает на проверку ф-ю
        @wraps(func)
        def wrapper(*args, **kwargs):
            # далее будем делать проверку, что первый параметр args, переданый с ф-ей, равен какому-то значению.
            # для этого надо удостовериться, существует ли вообще args
            if args and args[0] != value:
                print(f'Первый аргумент должен быть {value}')
            return func(*args, **kwargs)

        return wrapper

    return inner_dec  # то есть, у нас появляется еще одни декоратор, который декорирует внутренниюю часть,
    # которую мы потребляем. Потому что во внешнюю часть мы передаем значение, кторое мы будем проверять,
    # а во внутренюю часть мы передаем ф-ю, которую мы будем декорировать.


# Создадим ф-ю для проверки
def print_rainbow_colors(*colors):  # ф-я принимает список параметров (не позиционные)
    print(colors)


# Вызываем ф-ю и передаем ей параметр с цветами
print_rainbow_colors('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')


# ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet') - получаем цвета в списке Тьюпл


# Теперь задекорируем эту ф-ю с указанием параметра
@check_if_first_arg_is('red')  # здесь указываем, что первый параметр должне быть 'red'
def print_rainbow_colors_1(*colors):  # ф-я принимает список параметров (не позиционные)
    print(colors)


print_rainbow_colors_1('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet')
# ('red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet') - все корректно, потому что у нас действительо
# первый параметр - 'red'

# Но, если мы уберем из списка red
print_rainbow_colors_1('orange', 'yellow', 'green', 'blue', 'indigo', 'violet')


# Первый аргумент должен быть red
# ('orange', 'yellow', 'green', 'blue', 'indigo', 'violet')
# Вывод на экран мы получаем, но и с этим получаем предупреждение, что Первый аргумент должен быть red

# В принципе, мы бы могли вызвать ошибку вместо распечатки, но тогда бы не происходил вывод списка на экран.
# Но это уже по нашему успотрению, мы можем определять сами какую-то логику.


# Создадим другую ф-ю, которая будет умножать цифру 7 на какую-то другую
# Для этого мы должны удостовериться, что первый параметр - 7
@check_if_first_arg_is(7)  # здесь указываем, что первый параметр должен быть - 7
def multiply_7(a, b):
    return a * b


# Проверяем
print(multiply_7(7, 3))
# Без декоратора - 21

print(multiply_7(6, 3))  # первый аргумент не 7


# С декоратором:
# Первый аргумент должен быть 7
# 18


# Создадим декоратор, который будет приводить аргументы к нужному типу.

def enforce(*types):  # внешний декоратор принимает типы, в котором должны быть все передаваемые аргументы
    def inner_dec(func):  # внутренний декоратор, который принимает уже саму ф-ю
        @wraps(func)
        def wrapper(*args, **kwargs):
            # далее нам нужно создать пустой массив, так как args мы получаем в форме Тьюпл
            # Тьюпл не изменяемый объект, а нам надо будет дополнять список, потому создаем
            new_args = []  # задаем пустой list, так как list мы можем изменять.
            for a, t in zip(args, types):  # здесь в цикле мы будем 'зиповать' args и types
                # ф-я zip создает из двух последовательностей новую последовательность,
                # в которой каждому из элементов первой последовательности будет сопоставлен
                # каждый элемент из второй последовательности
                new_args.append(t(a))  # эти пары будем добавлять в новый массив и приводить аргумент 'a' к типу 't'
            return func(*new_args, **kwargs)  # возвращаем исходный func уже не с args, а с new_args, kwargs не меняются

        return wrapper

    return inner_dec


# Создаем ф-ю для применения этого декоратора
# Ф-я распечатыает текст несколько 'n' раз.
def print_text_n_times(text, n):  # в параметры передаем сам текст и 'n' - сколько раз распечатать.
    # 'n' - это аргумент типа int
    for number in range(n):
        print(text)


print(print_text_n_times('Харе Кришна!', 5))
# Харе Кришна!
# Харе Кришна!
# Харе Кришна!
# Харе Кришна!
# Харе Кришна!


# Но, что будет, если вместо числа мы в аргументы передадим строку (второй аргумент)
# print(print_text_n_times('Харе Кришна!', '3'))
# Получим ошибку Типа
# TypeError: 'str' object cannot be interpreted as an integer


# Но, если мы применим декоратор
@enforce(str, int)  # передаем нужные типы передаваемых параметров
def print_text_n_times_1(text, n):
    for number in range(n):
        print(text)

print(print_text_n_times_1('Харе Кришна!', '3'))
# Харе Кришна!
# Харе Кришна!
# Харе Кришна!
# Все получилось

# Еще один пример

def divide(a, b):
    return a / b

print(divide(4, 2))  # 2

# print(divide('4', '2'))  # передаем цифры в строковом типе
# 2
# TypeError: unsupported operand type(s) for /: 'str' and 'str'
# Здесь получаем ошибку, так как мы не можем делить строковые значения

# Применяем декоратор
@enforce(float, float)
def divide_1(a, b):
    return a / b

print(divide_1('4', '2'))  # 2.0

