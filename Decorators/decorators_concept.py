# Декораторы, их суть

# 1
# Допустим, у нас есть ф-ия


def simple_function():
    print('Simple function code')


# Мы можем использовать эту ф-ю в нашем коде.

simple_function()  # Simple function code


# Допустим, теперь для какой-то функциональности, нам надо испльзовать эту ф-ию, плюс, добавить к ней какой-то код.
# То есть, нам надо ее расширить, как-то усложнить.
# Для этого есть разные пути.
# Мы можем усложнить саму ф-ю, добавить в ее тело какой-то код.

def simple_function_1():
    print('Code before')
    print('Simple function code')
    print('Code after')


simple_function_1()
# Code before
# Simple function code
# Code after

# Но, в этом случае мы теряем функциональность, которая была изначально в этой ф-и.
# Это обновленная версия. И, если возникнет нужна в старой версии, мы не можем ее использовать в этой ф-и.

# Если обе версии кода этой ф-и нам важны, то в этом случае можно использовать декораторы.
# Проделаем с ф-ей то же самое, то есть добавим в нее функциональнось, но при помощи декораторов.


# Определяем новую ф-и, в которую будем передавать исходную ф-ю,
# Это ф-я с декоратором

def decorator_function(original_function):  # сюда в аргументы передаем исходную ф-ю.
    # внутри этой ф-и определяем еще одну ф-ю - оберточная ф-ю wrap
    def wrap_function():  # в этой оберточной ф-и мы будем использвать новую функциональность.
        print('Code before')
        original_function()
        print('Code after')

    return wrap_function  # возвращаем без скобок! Это не вызов.


# Теперь, чтобы воспроизвести функциональность, которая будет выволнять весь код: и оригинальный и добавочный
# Создаем переменную, присваиваем ей ф-ю декоратора, которому в аргументы передаем имя изначальной ф-и без вызова.

decorated_function = decorator_function(simple_function)  # в скобках изначальная ф-ия без круглых скобок (без вызова)

# Далее, делаем вызов переменной со скобками
decorated_function()  # добавляем скобки для вызова ф-и переданной в качестве аргумента.
# Code before
# Simple function code
# Code after


# Но, может возникнуть ситуация, кода нужно использовать изначальный код и добавочный надо откючить
# Это делается очень просто при помощи записи с "собачкой" @ 'add - на англ'

@decorator_function
def simple_function():  # это изначальная ф-я с декоратором
    print('Simple function code')


simple_function()  # вызываем ф-ю
# Code before
# Simple function code
# Code after
# Так выводится полный текст

# Но, если закомментировать текст с собачкой, то выведется изначальный текст в одну строку
# То есть, получаем простую функциональность.

# @decorator_function
def simple_function():
    print('Simple function code')


simple_function()
# Simple function code

# То есть, используя запись с 'сабакой' и указанием функции декоратора,
# мы можем добавлять или отключать функциональность.


# Для примера создадим еще одну простую ф-ю -> 1/1

# 3
# Автоматисчески создается одноименная ф-я с 'pass', который мы сразу удаляем и пишем тело ф-и
def make_complement(func):  # в скобках указываем, что в качестве параметра принимаем ф-ю
    def wrapper():  # дальше пишем оберточную ф-ю. Можем назвать как угодно.
        # Добавляем функциональности
        print('Рад познакомиться!')
        func()  # вызываем ф-ю, переданную в аргументах make_complement
        print('Отлично выглядишь!')
    return wrapper  # возвращаем оберточную ф-ию без вызова!  -> 4


# 2 Добавляем декоратор
@make_complement  # после написания этой строки она будет подчеркнута красным и с красной лампочкой.
# Раскрыть список красной лампочки и выбрать пункт - Create function 'make_complement' -> 3
# 1/1
def ask_name():
    print('Как вас зовут?')


# Запускаем ее, чтобы проверить, как работает
ask_name()  # Как вас зовут?

# Теперь создадим декоратор для этой ф-и. -> 2

# 4
# Если теперь вызовем нашу изначальную ф-ию,
ask_name()
# Рад познакомиться!
# Как вас зовут?
# Отлично выглядишь!
# Получаем дополнительную функциональность.

# Если мы закомментирует декоратор,
@make_complement
def ask_name():
    print('Как вас зовут?')


ask_name()


# Возвращается старая функциональность
# Как вас зовут?


# Почему 'декоратор'? Потому что он декорирует исходную ф-ю, заворачивает ее в "обертку", внутри которой используется
# старая ф-я и дополняет какую-то новую функциональность.

# Создал свою, чтобы закрепить.
def greeting(f):
    def wrapp():
        print('Здорова!')
        f()
        print('Пока!')

    return wrapp


# @greeting  # при отключении этой строки выводится перваначальная функциональность при вызове изначальной ф-и.
def ddl():
    print('Привет!')


ddl()


# Итак, мы рассмотрели случай, когда в исходную ф-ю не передается никакой аргумент.
# А что делать, если у нас есть ф-я с каким-то аргументом?

# def say_name(name):
#     print(f'Меня зовут {name}')
#
# say_name('Александр')

# Но, если мы захотим использовать декоратор к этой ф-и,
@make_complement
def say_name(name):
    print(f'Меня зовут {name}')


# say_name('Андрей')
# Получим ошибку, так как внутреняя ф-я wrapper не принимает никаких аргументов
# def make_complement(func):
#     def wrapper():  .....
# Но, мы передаем def say_name(name): - в скобках
# Поэтом, все, что нам нужно, это передать этот параметр в ф-ю wrapper


def make_complement_1(func):  # в скобках указываем, что в качестве параметра примимаем ф-ю
    def wrapper(name):  # дальше пишем оберточную ф-ю, но у же с аргументом
        # Добавляем функциональности
        print('Рад познакомиться!')
        func(name)  # вызываем ф-ю, переданную в аргументах make_complement_1 с указанием аргумента
        print('Отлично выглядишь!')

    return wrapper  # возвращаем оберточную ф-ию без вызова!


@make_complement_1
def say_name_1(name):
    print(f'Меня зовут {name}')


say_name_1('Андрей')

# Но, что делать, если мы захотим использовать этот же декоратор и для ask_name, который у нас не передает аргумент?


@make_complement_1
def ask_name_1():
    print('Как вас зовут?')


# ask_name_1() # без аргумента не принимается
# При запуске мы получим ошибку отсутствия аргумента:
# TypeError: wrapper() missing 1 required positional argument: 'name'
# Ф-я wrapper его требует, но его нет при определении ф-и def ask_name_1():, и мы также его не передаем при вызове ф-и.


# Для решения это пробелмы можно использовать аргументы *args, **kwargs

def make_complement_2(func):
    def wrapper(*args):  # вместо аргумента указываем *args
        print('Рад познакомиться! с *args)')
        func(*args)  # вместо аргумента указываем *args
        print('Отлично выглядишь! с *args')
    return wrapper  # возвращаем оберточную ф-ию без вызова!
# Теперь мы можем передавать этой ф-и любое количество аргументов

@make_complement_2
def say_name_2(name):
    print(f'Меня зовут {name} с *args')


say_name_2('Андрей')

# Но, что делать, если мы захотим использовать этот же декоратор и для ask_name, который у нас не передает аргумент?


@make_complement_2
def ask_name_2():
    print('Как вас зовут? без аргумента, но с *args')


ask_name_2()

# Чтобы наша ф-я декоратор была более гибкой и доступна для любого вида ф-и, мы можем также указать и **kwargs

def make_order(func):
    def wrapper(*args, **kwargs):  # вместо аргумента указываем *args и **kwargs
        print('Рады, что вы к нам заглянули! с *args и **kwargs)')
        func(*args, **kwargs)  # вместо аргумента указываем *args и **kwargs
        print('Сделаем через минуту! с *args и **kwargs')
    return wrapper  # возвращаем оберточную ф-ию без вызова!
# Теперь эта ф-я доступна для любого вида ф-и, в том числе и для ф-й с **kwargs - аргументами

# Создадим такую ф-ю и задекорируем ее
@make_order
def order(food, drink):
    print(f'Я бы хотел {food} и {drink}')

# Этот вызов использует *args
order('Чипсы', 'Колу *args')
# Без ф-и декоратора мы получим вывод: Я бы хотел Чипсы и Колу
# С декоратором:
# Рады, что вы к нам заглянули! с *args)
# Я бы хотел Чипсы и Колу
# Сделаем через минуту! с *args и **kwargs

# Этот вызов использует **kwargs
# Этот вызов использует *args
order(food='Чипсы', drink='Колу с **kwargs')
# Рады, что вы к нам заглянули! с *args и **kwargs)
# Я бы хотел Чипсы и Колу с **kwargs
# Сделаем через минуту! с *args и **kwargs
# Получаем то же самое.
# То есть, с ипользованием *args и **kwargs наша ф-я становится очень гибкой

