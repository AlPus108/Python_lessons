# ДЕКОРАТОРЫ

# 1
# Декораторы, это способ оптимизации кода.
# Декораторы испльзуют, когда необходимо ряд ф-й обернуть в одну и ту же обертку.

# Самый типичный пример - вывод времени исполнения функции.
# Мы измеряем время исполнения разных ф-й. И, чтобы каждый раз не писать один и тот же код по измерению времени
# для каждой ф-и отдельно, мы пишем одну ф-ю, которая является оберткой для каждой из них. И, с помощью декораторов
# добавляем это функционал в каждую ф-ю, при этом создавая каждый раз новую ф-ю.
# Декораторы помечаются с помощью символа '@' -> 1/1

# ------------------------- Простой декоратор (без параметров) -----------------------

# -> 2
# Эта ф-я будет возвращать ф-ю, до которой стоит какой-то код, и после которой стоит какой-то код.
def show_information(f):
    # в этой ф-и мы должны создать другую ф-ю, называемую "обертка"
    def wrapper():
        print('Код до ф-и')
        # выполняем саму ф-ю
        f()
        print('Код после ф-и')

    return wrapper
    # Далее будем использвать этот декоратор -> 3


# 1/1

# Для примера создадим простую ф-ю.

def simple_function():
    print('Я простая функция')


# Допустим, нам надо после этой ф-и выполнить какой-то код, и перед этой ф-й выполнить какой-то код.
# Нам нично не мешает эту ф-ю передать в качестве параметра другой ф-и.

# Проверяем работу нашей ф-и

simple_function()
# Я простая функция

# До этой ф-и создадим другую ф-ю, которая будет обрабатывать код до этой ф-и -> 2

# -> 3
# Далее передаем декаратору нашу ф-ю.
# В новую переменную присваиваем результат работы декоратора, в который передаем нашу ф-ю
simple_function_decorated = show_information(simple_function)
# Вызов делаем со скобками
simple_function_decorated()


# Код до ф-и
# Я простая функция
# Код после ф-и

# Но, конечно, такая структура записи очень не удобно. Она созадет лишние объекты.
# Поэтому придумали декораторы

# Создадим нову ф-ю и зепляем к ней декоратор через ключ @
@show_information
def simple_function_1():
    print('Я тоже простая функция')


# Запускаем ее
simple_function_1()


# Код до ф-и
# Я тоже простая функция
# Код после ф-и

# ------------------------- Декоратор с параметрами ---------------------


# Напишем декоратор, который выводит типы переменных, которые есть в ф-и.

def show_type(f):
    def wrapper(*args, **kwargs):  # здесь уже в обертку мы должны передать параметры ф-и.
        # но, проблема в том, что мы не знаем, какие будут параметры у ф-и f
        # поэтому на помощь приходят args и kwargs
        print('Код до ф-и', type(args[0]))  # выводим тип первого аргумента ф-и
        # выполняем саму ф-ю
        print(f(*args, **kwargs))
        print('Код после ф-и', type(args[1]))  # тип второго аргумента ф-и

    return wrapper


@show_type
def sum(a, b):
    return a + b


sum(3, 5)

# Код до ф-и <class 'int'>
# 8
# Код после ф-и <class 'int'>

# Декораторы также можно использвать каскадно
print('Вывод коскадного декоратора')


# чтобы он работал, там надо везде вставлять аргументы *args и **kwargs, это чисто для примера
@show_information
@show_type
def sum(a, b):
    return a + b


# Декораторы бывают и у методов объектов в классе.
# Напишем ф-ю измереющую время работы ф-и

import time


# Декоратор, измеряющий время работы ф-и
def show_time(f):
    def wrapper(*args, **kwargs):
        print(f'Время до выполнения ф-и {time.time()}')
        t_s = time.time()
        print('URL: ', args[0])
        print(f(*args, **kwargs))
        print(f'Время после выполнения ф-и {time.time()}')
        t_f = time.time()
        print(f'Время выполнения ф-и {t_f - t_s}')

    return wrapper


# Для запросов импортируем ф-ю requests
import requests

@show_time
def requests_example(url):  # ф-я делает запрос какого-то url
    webpage = requests.get(url)
    return webpage.text


url = 'https://yandex.ru'

data = requests_example(url)

print(data)

# или в одну строку
# print(requests_example('https://yandex.ru'))

# Декораторы испльзуется очень часто. Они испльзуются во flask, jango и во многих других пакетах

