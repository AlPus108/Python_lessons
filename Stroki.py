# СТРОКИ
# Вывод букв строки каждую в отедльности на отедельных строках

# a = "ABCD"
# for i in range(4): # перебор символов строки в цикле
#     print(a[i])

# # или более удачная конструкция
# # здесь нет явной индексации, как в предыдущем примере
# a = "ABCD"
# for i in a:  # перебор символов строки в цикле
#     print(i)
# #  такая конструкция вообще хорошо работает с любыми последовательностями

# ----------------------------------------

# Сколько раз встречается символ в строке?
# a = 'ABBCABCC'
# x = 0
# for i in a:
#     if i == 'C':
#         x += 1
# print(x)
#
# # второй способ (более короткий)
# a = 'ABBCABCC'
# print(a.count('C'))

# Строки, это объекты, которые имеют методы.
# В данном случае применяется функция(метод) s.count(p) - сколько раз символ 'p' (или слово) встречается в строке 's'

# ------------------------------------------------

# МЕТОДЫ СТРОК

# s = 'aTGCC'
# p = 'cc'
#
# s.upper()  # заменяет все буквы в строке на большие. Если есть символы, которые не являются буквами, они игнорируются
# s.lower()  # заменяет все буквы в строке на маленькие. При этом самас строка s остается не изменной
# # метод возвращает результат, который можно присвоить другой переменной res = s.lower()
# s.count(p)  # подсчитывает, сколько раз подстрока р встерчается в строке s.
# # Рассматриваются только не перекрываютщиеся значения сссс - 2 сс; внутренее сс не рассматривается
# s.find(p)  # находит позицию подстроки р в строке s. Возвращает индекс первой буквы (первое вхождение).
# # Если такой подстроки нет в строке s, то результат  -1
# # Если мы хотим проверить входит подстрока в строку или нет, лучше использовать конструкцию if 'TG' in s: ...
# s.replace('c', 'C') # заменяет одни буквы на другие. При этом сама строка s остается не изменной.
# # Результат нужно присваивать переменной
#
#
# #  ПОСЛЕДОВАТЕЛЬНЫЕ ВЫЗОВЫ МЕТОДОВ
#
# S = 'agTtcAGtc'
# s.upper().count('gt'.upper())
# #  Первым шагом - изменяем все буквы на большие.
# # Второй шаг - поиск уже в изменненой строке сочетания 'gt', измененные на большие. Результат: 2
#---------------------------------------------


'''
Напишите программу, которая вычисляет процентное содержание символов G (гуанин) и C (цитозин) в введенной строке
(программа не должна зависеть от регистра вводимых символов).

Например, в строке "acggtgttat" процентное содержание символов G и C равно (4/10)*100 = 40.0
где 4 -- это количество символов G и C,  а 10 -- это длина строки.
'''

# s = input().lower()
# print(s)  # проверяем, что все буквы в нижнем регистре
# p1 = 'g'
# p2 = 'c'
#
# x = len(s)  # длина строки
# x1 = s.count(p1)
# x2 = s.count(p2)
#
# print(((x1 + x2)/x)*100)

# -----------------------------------

# Как брать диапазон символов у строк
#  Для этого существует механизм Slicing

# s = 'ATGTVS'
# x = s[1]  # берем второй символ строки с индексом 1 -> T (первый символ - индекс 0)
# x2 = s[1:4]  # берем диапазон символов строки с 1 по 4. При этом 4-й (последний символ не включается!)
# # в Питоне всегда левая граница влчается в интервал, правая не включается!
# x3 = s[:4]  # при взятии диапазона можно не указывать явно начало. Последний символ не включается в интервал!
# x4 = s[4:]  # аналогично, можно не указывать правую границу. Берем символы с 4-го до последнего
# x5 = s[-4:] # берем отрицательный индекс. Делаем выборку начиная с 4-го символа с конца и остальные до конца строки
# x6 = s[1:-1] # указываем обе границы, при этом символы могут быть как положительные, так и отрицательные.
# # при этом последний символ не включается в интервал!
# x7 = s[1:-1:2] # указываем шаг, с которым мы берем символ: шаг - 2 (индексы: 1,3,5)
# # последний символ не включается в интервал!
# x8 = s[::-1] # отрицательный шаг. Выводим все символы в обратном порядке. То есть, переворачиваем слово наоборот.

# -------------------------------------------------------

# Проверяем, является ли строка палиндромом (читается одинаково с обоих концов)

# s = input()
# i = 0
# j = len(s)-1  # измеряем длину строки исключая 0
# is_palindrom = True
# while i < j: # цикл крутиться, пока переменная i меньше переменной j
#     # для начлла првоеряем равность первого и последнего символов.
#     if s[i] != s[j]:   # Если они не равны -
#         is_palindrom = False  # строка точно не палиндром
#           break # досрочно прерываем цикл, так как уже понятно, что это не палиндром
#     # уменьшаем диапазон с двух сторон
#     i += 1  # переходим на следующий символ с начала
#     j -= 1  # переходим на следующий символ с конца
# if is_palindrom:   # если же эти два символа равны
#     print('YES')

# Короткий варинат решения задачи на Палиндром

# s = input()
# r = s[::-1]
# if s == r:
#     print('YES')
# else:
#     print('NO')
# Единственный недостаток в этом решении в том, что код использует дополнительную память, если строка очень длинная
# -------------------------------------------------

# s = 'abcdefghijk'
# x1 = s[3:6]
# x2 = s[:6]
# x3 = s[3:]
# x4 = s[::-1]
# x5 = s[-3:]
# x6 = s[:-6]
# x7 = s[-1:-10:-2]
#
# print(x1, x2, x3, x4, x5, x6, x7)

# ------------------------------------------------

'''
Реализуйте алгоритм сжатия, который сжимает повторяющиеся символы в строке.

Кодирование осуществляется следующим образом:
s = 'aaaabbсaa' преобразуется в 'a4b2с1a2',
то есть группы одинаковых символов исходной строки заменяются на этот символ 
и количество его повторений в этой позиции строки.

Напишите программу, которая считывает строку, кодирует её предложенным алгоритмом 
и выводит закодированную последовательность на стандартный вывод. Кодирование должно учитывать регистр символов.
'''

# s = input().lower()
# i = -1
# x = 0
# ss = ''
#
# while i != len(s)-1:
#     if s[i] == s[i+1]:
#         x += 1
#         i += 1
#         ss = s[i] + str(x)
#
#     print(ss, end='')
#     x = 0
#     ss = ''

# -----------------------------------------------
# s = input().lower()
# k = 1
# for i in range(len(s)-1):
#     if s[i] == s[i+1]:
#         k += 1
#     elif s[i] != s[i+1]:
#         print(s[i], str(k), sep='', end='')
#         k = 1

#-----------------------------------------------------------------

s = input().lower()
l = len(s)  # длина строки
p = s[0]  # первый символ
count = 1  # счетчик
res = ""  # здесь будет результат
for i in range(l - 1):
    c = s[i + 1]  # следующий символ
    if (c == p):  # если совпадает со следующим - увеличим счетчик
        count += 1
    else:  # иначе выведем пару
        res += p + str(count)
        count = 1
    p = c  # текущий стал следующим
res += p + str(count)  # вывод последней пары
print(res)




# --------------------------------------------------------------------
# print(*('_'.join(word) for word in 'programm select one'.split()))
# --------------------------------------------------------------------